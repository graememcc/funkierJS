(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var CPTestDataHelper = require('../test/docgen/CPTestDataHelper');
  var testAPIFunction = require('../test/docgen/testAPIFunction');
  var testAPIObject = require('../test/docgen/testAPIObject');
  var testAPIPrototype = require('../test/docgen/testAPIPrototype');
  var testCollator = require('../test/docgen/testCollator');
  var testCommentProcessor = require('../test/docgen/testCommentProcessor');
  var testCPTestDataHelper = require('../test/docgen/testCPTestDataHelper');
  var testLineProcessor = require('../test/docgen/testLineProcessor');
  var testMarkdownCreator = require('../test/docgen/testMarkdownCreator');
  var testMarkdownRenderer = require('../test/docgen/testMarkdownRenderer');
  var testAPI = require('../test/funkierJS/testAPI');
  var testArray = require('../test/funkierJS/testArray');
  var testBase = require('../test/funkierJS/testBase');
  var testCurry = require('../test/funkierJS/testCurry');
  var testDate = require('../test/funkierJS/testDate');
  var testFn = require('../test/funkierJS/testFn');
  var testFuncUtils = require('../test/funkierJS/testFuncUtils');
  var testFunkier = require('../test/funkierJS/testFunkier');
  var testingUtilities = require('../test/funkierJS/testingUtilities');
  var testInternalUtilities = require('../test/funkierJS/testInternalUtilities');
  var testLogical = require('../test/funkierJS/testLogical');
  var testMaths = require('../test/funkierJS/testMaths');
  var testMaybe = require('../test/funkierJS/testMaybe');
  var testObject = require('../test/funkierJS/testObject');
  var testPair = require('../test/funkierJS/testPair');
  var testResult = require('../test/funkierJS/testResult');
  var testString = require('../test/funkierJS/testString');
  var testTypes = require('../test/funkierJS/testTypes');
})();

},{"../test/docgen/CPTestDataHelper":36,"../test/docgen/testAPIFunction":37,"../test/docgen/testAPIObject":38,"../test/docgen/testAPIPrototype":39,"../test/docgen/testCPTestDataHelper":40,"../test/docgen/testCollator":41,"../test/docgen/testCommentProcessor":42,"../test/docgen/testLineProcessor":43,"../test/docgen/testMarkdownCreator":44,"../test/docgen/testMarkdownRenderer":45,"../test/funkierJS/testAPI":46,"../test/funkierJS/testArray":47,"../test/funkierJS/testBase":48,"../test/funkierJS/testCurry":49,"../test/funkierJS/testDate":50,"../test/funkierJS/testFn":51,"../test/funkierJS/testFuncUtils":52,"../test/funkierJS/testFunkier":53,"../test/funkierJS/testInternalUtilities":54,"../test/funkierJS/testLogical":55,"../test/funkierJS/testMaths":56,"../test/funkierJS/testMaybe":57,"../test/funkierJS/testObject":58,"../test/funkierJS/testPair":59,"../test/funkierJS/testResult":60,"../test/funkierJS/testString":61,"../test/funkierJS/testTypes":62,"../test/funkierJS/testingUtilities":63}],2:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /*
   * An APIFunction is an object representing the documentation of a function found in the source code. The constructor
   * takes the following parameters:
   *
   *   name: the name of the function being described as a string.
   *   filename: the file in which the function was found
   *   category: all documented values are assumed to be grouped into categories. This string denotes such a
   *             category.
   *   summary: a string containing a brief overview of the function's functionality. This is assumed to be a brief
   *            paragraph. The caller must add any required line endings - see below
   *   options: an object containing additional information. See below.
   *
   * The supplied category will be transformed to uppercase the first letter of the category name. In other words,
   * categories "functions" and "Functions" are assumed to be the same category.
   *
   * As noted above, additional detail can be supplied in the options object. The following properties are recognised:
   *   synonyms: An array of strings representing alternate names that can be used to invoke the function. This will
   *             be an empty array if not supplied.
   *   returnType: An array of strings representing the possible types that might be returned by an invocation of the
   *               function. This will be an empty array if not supplied.
   *   details: An array of strings, each string representing a line of explanatory text. In totality, it is assumed
   *            that the details provide further explanation on function usage beyond that provided by the summary
   *            line. This will be an empty array if not supplied. Any trailing line endings will be stripped: it is
   *            assumed output routines can add these where necessary. Paragraph breaks should be denoted by empty
   *            lines.
   *   examples: An array of strings, each of which represents a line of Javascript illuminating typical usage of the
   *             function. This will be an empty array if not supplied.
   *   parameters: See below. This will be an empty array if not supplied.
   *
   * The parameters option should be an array of parameters objects. Each such object should have the following
   * properties:
   *   name: A string containing the name of the parameter
   *   type: A non-empty array containing the possible types that the parameter can take
   *
   * It is intended that when output to the console, the summary string will be output verbatim: thus it is incumbent
   * on the client to insert appropriate line endings to ensure that line length is appropriate. Note however that the
   * trailing line length will be stripped, as it is assumed the console output function will add this.
   *
   * Similarly, each entry in the details array is assumed to be a paragraph. It is intended that the in-app help
   * outputs each paragraph separately, but the client must add line-endings to the individual strings to control line
   * length.
   *
   * Each line of the examples array is assumed to be a line that should be output in a code block. It is assumed that
   * when converted to Markdown line endings will be added as required, so line endings will be automatically stripped.
   *
   * Newline characters within each examples or details line (in other words, not occurring at the end) will cause the
   * line to be split at that point.
   *
   */


  var APIPrototype = require('./APIPrototype');


  var verifyParameterProperty = function(elem) {
    var isString = function(s) {
      return typeof(s) === 'string';
    };

    var isObject = elem !== null && !Array.isArray(elem);
    if (!isObject) return false;

    return typeof(elem.name) === 'string' && Array.isArray(elem.type) && elem.type.length > 0 &&
           elem.type.every(isString);
  };


  var verifyOptions = function(options) {
    if (typeof(options) !== 'object' || options === null || Array.isArray(options))
      throw new TypeError('Invalid parameter: options is not an object');

    var optionals = ['returnType',  'synonyms', 'parameters'];
    var optionTypes = ['string', 'string', 'object'];

    var failPoint = -1;
    var optionalsOK = optionals.every(function(optProp, i) {
      var opt = options[optProp];
      if (opt !== undefined && (!Array.isArray(opt) || !opt.every(function(elem) {
        return typeof(elem) === optionTypes[i];
      }))) {
        failPoint = i;
        return false;
      }

      return true;
    });

    if (!optionalsOK)
      throw new TypeError(optionals[failPoint] + ' is invalid!');

    if (options.parameters !== undefined)
      optionalsOK = options.parameters.every(verifyParameterProperty);

    if (!optionalsOK)
      throw new TypeError('Invalid optional parameter!');
  };


  function APIFunction(name, filename, category, summary, options) {
    if (!(this instanceof APIFunction))
      return new APIFunction(name, filename, category, summary, options);

    verifyOptions(options);

    this.name = name;
    this.filename =filename;
    this.summary = summary;
    this.category = category;
    this.details = options.details ? options.details : [];
    this.examples = options.examples ? options.examples : [];

    this.returnType = options.returnType ? options.returnType.slice() : [];
    this.synonyms = options.synonyms ? options.synonyms.slice() : [];
    this.parameters = options.parameters ? options.parameters.map(function(param) {
      var paramType = param.type.slice();
      Object.freeze(paramType);
      return {name: param.name, type: paramType};
    }) : [];

    ['returnType', 'synonyms', 'parameters'].forEach(function(prop) {
      Object.freeze(this[prop]);
    }, this);

    this.parameters.forEach(function(param) {
      Object.freeze(param);
    });

    Object.freeze(this);
  }


  APIFunction.prototype = Object.create(APIPrototype);


  return APIFunction;
})();

},{"./APIPrototype":4}],3:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /*
   * An APIObject is an object representing the documentation of an object found in the source code. The constructor
   * takes the following parameters:
   *
   *   name: the name of the object being described as a string.
   *   filename: the name of the file in which the object was found.
   *   category: all documented values are assumed to be grouped into categories. This string denotes such a
   *             category.
   *   summary: a string containing a brief overview of the object's purpose. This is assumed to be a brief
   *            paragraph. The caller must add any required line endings - see below
   *   options: an object containing additional information. See below.
   *
   * The supplied category will be transformed to uppercase the first letter of the category name. In other words,
   * categories "functions" and "Functions" are assumed to be the same category.
   *
   * As noted above, additional detail can be supplied in the options object. The following properties are recognised:
   *   details: An array of strings, each string representing a line of explanatory text. In totality, it is assumed
   *            that the details provide further explanation on usage beyond that provided by the summary line. This
   *            will be an empty array if not supplied. Any trailing line endings will be stripped: it is assumed
   *            output routines can add these where necessary. Paragraph breaks should be denoted by empty lines.
   *   examples: An array of strings, each of which represents a line of Javascript illuminating typical usage of the
   *             value. This will be an empty array if not supplied.
   *
   * It is intended that when output to the console, the summary string will be output verbatim: thus it is incumbent
   * on the client to insert appropriate line endings to ensure that line length is appropriate. Note however that the
   * trailing line length will be stripped, as it is assumed the console output function will add this.
   *
   * Similarly, each entry in the details array is assumed to be a paragraph. It is intended that the in-app help
   * outputs each paragraph separately, but the client must add line-endings to the individual strings to control line
   * length.
   *
   * Each line of the examples array is assumed to be a line that should be output in a code block. It is assumed that
   * when converted to Markdown line endings will be added as required, so line endings will be automatically stripped.
   *
   * Newline characters within each examples or details line (in other words, not occurring at the end) will cause the
   * line to be split at that point.
   *
   */


  var APIPrototype = require('./APIPrototype');


  function APIObject(name, filename, category, summary, options) {
    if (!(this instanceof APIObject))
      return new APIObject(name, filename, category, summary, options);

    if (typeof(options) !== 'object' || options === null || Array.isArray(options))
      throw new TypeError('Options is not an object!');

    this.name = name;
    this.filename = filename;
    this.summary = summary;
    this.category = category;
    this.details = options.details ? options.details : [];
    this.examples = options.examples ? options.examples : [];

    Object.freeze(this);
  }


  APIObject.prototype = Object.create(APIPrototype);


  return APIObject;
})();

},{"./APIPrototype":4}],4:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /*
   * We wish to document various functions and objects in funkierJS. The documentation of these types of objects
   * contain some commonality, which is factored out here, to avoid repeating the verification in both files.
   *
   * See the APIFunction and APIObject files for details.
   *
   */


  /*
   * Process an array of lines, removing trailing line endings, and splitting on any other line endings. Returns an
   * empty array when passed undefined.
   *
   */

  var processLineArray = function(arr) {
    if (arr === undefined)
      return [];

    // Note: whitespace might be significant for examples, so we cannot use trim
    var result = arr.reduce(function(soFar, current) {
      // We must delete any trailing newlines first
      var lines = current.replace(/\s*$/, '').split('\n');

      // Trim trailing whitespace from the remaining lines
      return soFar.concat(lines.map(function(s) { return s.replace(/\s*$/, ''); }));
    }, []);

    Object.freeze(result);
    return result;
  };


  var verifyStringArray = function(val, paramName) {
    if (!Array.isArray(val))
      throw new TypeError('Invalid parameter: ' + paramName + ' is not an array');

    if (!val.every(function(s) { return typeof(s) === 'string'; }))
      throw new TypeError('Invalid parameter: ' + paramName + ' contains a non-string member');
  };


  var verifyString = function(val, paramName) {
    if (typeof(val) !== 'string')
      throw new TypeError('Invalid parameter: ' + paramName + ' is not a string!');
  };


  var verifyNameCat = function(val, self, otherProp) {
    var other = self[otherProp];
    if (other === undefined) return;
    if (val.toLowerCase() === other.toLowerCase())
      throw new Error('name and category cannot match (even approximately)');
  };


  return {
    get name() { return this.__name; },
    set name(val) { verifyString(val, 'name'); verifyNameCat(val, this, '__category'); this.__name = val; },

    get filename() { return this.__filename; },
    set filename(val) { verifyString(val, 'filename'); this.__filename = val; },

    get category() { return this.__category; },
    set category(val) {
      verifyString(val, 'category');
      verifyNameCat(val, this, '__name');
      this.__category = val[0].toUpperCase() + val.slice(1);
    },

    get summary() { return this.__summary; },
    set summary(val) { verifyString(val, 'summary'); this.__summary = val.trim(); },

    get details() {
      if (this.__details === undefined) {
        this.__details = [];
        Object.freeze(this.__details);
      }
      return this.__details;
    },
    set details(arr) { verifyStringArray(arr, 'details'); this.__details = processLineArray(arr); },

    get examples() {
      if (this.__examples === undefined) {
        this.__examples = [];
        Object.freeze(this.__examples);
      }
      return this.__examples;
    },
    set examples(arr) { verifyStringArray(arr, 'examples'); this.__examples = processLineArray(arr); },
  };
})();

},{}],5:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var APIFunction = require('./APIFunction');
  var APIObject = require('./APIObject');


  /*
   * A collator object is used to describe all the documented values found by the documentation generation system,
   * and allows a client to query them in various interesting ways. It takes as input an array of arrays, each array
   * containing APIFunction and APIObject objects (the assumption being that all the values in the same array originate
   * from the same source file) and returns an object with the following methods:
   *
   *  - getNames: returns an array, sorted in lexicograohical order, of the names of all the values encountered. This
   *              includes entries for each synonym where values have synonyms.
   *
   *  - getCategories: returns an array, sorted in lexicograohical order, of all the categories the documented values
   *                   were ascribed to. Each category shall appear only once, regardless of how many objects were
   *                   found.
   *
   *  - getFileNames: returns an array, sorted in lexicograohical order, of all the filenames that were found to contain
   *                  the documented values.
   *
   *  - byName: returns an array of all the documented values found, sorted by name. Where a value has synonyms, there
   *            will be an entry for the synonym: this will be an object with three properties:
   *              * name: the name of the synonym
   *              * filename: the filename in which it was found
   *              * synonymFor: the value that is aliased
   *
   *            All other values will be the original APIFunction and APIObjects created from parsing the documentation
   *            comments.
   *
   *  - byCategory: given the name of a category from the array returned by getCategories, returns an array containing
   *                all the values belonging to this category. As with 'byName' above, this will include additional
   *                objects to represent synonyms of other values. See the comment for 'byName' above regarding the
   *                form of such objects. The array is sorted by the name of the values.
   *
   * The collator imposes some constraints on the data it is provided with. It will throw if any of the following occur:
   *
   *  - Two objects represent a value with the same name
   *
   *  - The synonym of one documentation object matches the name or synonym of another
   *
   *  - The lowercase equivalent of the name or synonym of an object matches the name of a category
   *
   */

  var sort = function(a, b) {
    var name1 = a.name;
    var name2 = b.name;
    return name1 < name2 ? -1 : (name1 === name2 ? 0 : 1);
  };


  var Collator = function(arrays) {
    if (!(this instanceof Collator))
      return new Collator(arrays);

    if (!Array.isArray(arrays)) throw new Error('Value must be an array');

    var values = {};
    var namesFound = [];
    var filesFound = [];
    var all = [];

    arrays.forEach(function(arr) {
      if (!Array.isArray(arrays)) throw new Error('Value must contain only arrays');

      arr.forEach(function(val) {
        if (!(val instanceof APIFunction) && !(val instanceof APIObject))
          throw new Error('Non-APIFunction/APIObject value found');

        var cat = val.category;
        if (namesFound.indexOf(cat) !== -1)
          throw new Error('Category matches an earlier function name');

        if (namesFound.indexOf(val.name) !== -1)
          throw new Error('Duplicate name found');

        if ('synonyms' in val) {
          val.synonyms.forEach(function(syn) {
            if (namesFound.indexOf(syn) !== -1)
              throw new Error('Duplicate name found');
          });
        }

        var filename = val.filename;
        if (filesFound.indexOf(filename) === -1) filesFound.push(filename);

        var existingCategories = Object.keys(values);
        var alreadyHaveNameAsCategory = function(s) {
          return existingCategories.some(function(t) {
            return s.toLowerCase() === t.toLowerCase();
          });
        };

        if (alreadyHaveNameAsCategory(val.name) ||
            (Array.isArray(val.synonyms) && val.synonyms.some(alreadyHaveNameAsCategory)))
          throw new Error('Name matches a category');

        if (values[cat] === undefined) values[cat] = [];

        namesFound.push(val.name);
        if ('synonyms' in val) {
          val.synonyms.forEach(function(syn) {
            namesFound.push(syn);
            var synonymInfo = {name: syn, filename: filename, synonymFor: val.name};
            Object.freeze(synonymInfo);
            values[cat].push(synonymInfo);
            all.push(synonymInfo);
          });
        }

        values[cat].push(val);
        all.push(val);
      });
    });

    var keys = Object.keys(values);
    keys.sort();
    Object.freeze(keys);
    keys.forEach(function(k) {
      values[k].sort(sort);
      Object.freeze(values[k]);
    });

    this._categories = keys;
    all.sort(sort);

    Object.freeze(all);
    this._byName = all;

    Object.freeze(values);
    this._byCategory = values;

    namesFound.sort();
    Object.freeze(namesFound);
    this._names = namesFound;

    filesFound.sort();
    Object.freeze(filesFound);
    this._files = filesFound;

    Object.freeze(this);
  };


  Collator.prototype.getNames = function() {
    return this._names;
  };


  Collator.prototype.getCategories = function() {
    return this._categories;
  };


  Collator.prototype.getFileNames = function() {
    return this._files;
  };


  Collator.prototype.byName = function() {
    return this._byName;
  };


  Collator.prototype.byCategory = function(cat) {
    var byCat = this._byCategory[cat];
    return byCat === undefined ? [] : byCat;
  };


  return Collator;
})();

},{"./APIFunction":2,"./APIObject":3}],6:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /*
   * The commentProcessor module takes an array of strings, and transforms it into an APIFunction or APIObject object,
   * depending on the tag assigned by LineProcessor, verifying the rules for API function documentation layout.
   * Specifically, we expect the following:
   *
   * The first non-empty line should contain the name of the function, and nothing else
   *
   * (APIFunctions only) There should be a line containing the category of functions the function in question belongs
   * to. Such a line should begin with "Category: " followed by the category and nothing else.
   *
   * (APIFunctions only) There may optionally be a line containing synonyms for the function. Such a line should begin
   * with "Synonyms: " * followed by a list of the synonyms, separated by commas, vertical bars, or the word "or".
   *
   * (APIFunctions only) There may optionally be a line containing a list of parameters. Each such line should start
   * with "Parameter: ", be followed by the parameter name followed by a colon, and a list of the possible types of
   * the parameter, separated by commas, vertical bars, or the word "or". Multiple parameters can be documented on
   * separate lines: the expectation is that the parameter lines are in the same order as the arguments that the
   * function takes. If a parameter line provides information contradicting a previous parameter line, an exception is
   * thrown.
   *
   * (APIFunctions only) There may optionally be a line containing the possible return types. Such a line should start
   * with "Returns: ", and be followed by a list of the return types, separated by vertical bars or the word "or". If
   * given, the return type line must follow any parameter lines. Further, when there are also parameter lines, there
   * should be nothing else (except empty lines) between the parameter lines and the return line.
   *
   * The first non-empty line that is not one of the special lines mentioned above is taken to mark the start of the
   * summary: a short paragraph suitable for providing a simple description of the function's functionality. The
   * summary is assumed to continue to the next empty line (or end of input whichever comes first). The summary will be
   * reduced to a single string, with newline characters inserted between all lines other than the last.
   *
   * After the empty line, there may optionally be detailed help: further lines that illuminate details of the
   * function's behaviour. The details are assumed to continue until the last line, unless code examples are provided.
   *
   * After the summary (and optionally details), there may optionally be code examples. This is denoted by a line
   * consisting only of "Examples:". All lines from this point on will be considered as examples.
   *
   * The line containing the name establishes the indentation level for the following lines: all lines will be expected
   * to have the same amount of whitespace; this whitespace will be stripped from each line. An error will be thrown if
   * any line is encountered that has more indentation, with two exceptions:
   *
   *  - Detailed help lines other than the first may have extra indentation for aesthetic purposes: only the
   *    indentation amount established earlier will be removed
   *
   *  - Examples may be indented further: the first non-trivial line occurring after "Examples:" establishes the
   *    minimum indentation for examples lines. That level of whitespace will be stripped from each examples line.
   *
   * Any line that is found to have less indentation will cause an error.
   *
   */


  var makeUnique = function() { return {}; };


  var APIFunction = require('./APIFunction');
  var APIObject = require('./APIObject');


  // States for the state machine
  var MODE_AWAITINGNAME = makeUnique();
  var MODE_OPTIONALS = makeUnique();
  var MODE_PARAMETERS = makeUnique();
  var MODE_POSTPARAMETERS = makeUnique();
  var MODE_SUMMARY = makeUnique();
  var MODE_DETAILS = makeUnique();
  var MODE_EXAMPLES = makeUnique();

  /*
   * Processes a line suspected to contain the name of a function. Returns the current mode if the line is empty,
   * otherwise the name property of the supplied parameters object is set to the name found, and the next mode is
   * returned.
   *
   */

  var processName = function(line, params, currentMode) {
    if (/^\s*$/.test(line)) return currentMode;

    if (line.indexOf(':') !== -1)
      throw new Error('No function name specified!');

    // Test that only one word was encountered
    var nameMatch = /^\s*((?:\w|\$)+)\s*$/.exec(line);
    if (!nameMatch)
      throw new Error('Invalid line encountered!');

    params.name = nameMatch[1];

    // Calculate the global indent
    var remainingWhitespace = /^\s+/.exec(line);
    params.globalIndent = remainingWhitespace === null ? 0 : remainingWhitespace[0].length;
    return MODE_OPTIONALS;
  };


  /*
   * Processes a line suspected to contain the category of a function. Throws if the line contains
   * more than one category, and returns the category otherwise.
   *
   */

  var processCategory = function(line) {
    // The following regex will match when there is only one category present
    var categoryMatch = /^\s*(\w+)\s*$/.exec(line);
    if (categoryMatch === null)
      throw new Error('Two categories specified');

    return categoryMatch[1];
  };


  var flatMap = function(f, arr) {
    return arr.map(f).reduce(function(soFar, current) {
      return soFar.concat(current);
    }, []);
  };


  /*
   * Processes a line whose objects are split by vertical bars, the word "or" or commas
   *
   */

  var processSplitLine = function(line) {
    var splits = flatMap(function(s) { return s.split(/\s+or\s+/); }, line.split('|'));
    splits = flatMap(function(s) { return s.split(/\s*,\s*/); }, splits);
    return splits.map(function(word) { return word.trim(); });
  };


  var processSynonyms = function(line) {
    return processSplitLine(line);
  };


  var processReturnTypes = function(line) {
    return processSplitLine(line);
  };


  /*
   * Processes a line that contains a parameter definition, and adds it to the supplied array of parameter definitions.
   * Throws if the parameter definition is malformed, or contradicts or duplicates an existing definition.
   *
   */

  var processParameter = function(line, parameters) {
    // This function must locate the parameter name, and the list of parameter types. It must then scan the existing
    // parameters for conflicting or duplicated information before adding.
    var colonIndex = line.indexOf(':');
    if (colonIndex === -1)
      throw new Error('Malformed parameter line');

    var name = line.slice(0, colonIndex).replace(/^\s+/, '').replace(/\s+$/, '');
    if (parameters.some(function(param) { return param.name === name; }))
      throw new Error('Conflicting parameter definition');

    return parameters.concat([{name: name,
                               type: processSplitLine(line.slice(colonIndex + 1))}]);
  };


  /*
   * Checks whether the line is one that starts with one of the special keywords, returning that keyword if so, and
   * returning null otherwise.
   *
   */

  var getLineKeyword = function(line) {
    line = line.toLowerCase();
    var specialLineRegexes = ['category', 'parameter', 'returns', 'synonyms', 'examples'].map(function(type) {
      return new RegExp('^\\s*(' + type + ')\\s*:\\s*');
    });

    var keyword = null;
    specialLineRegexes.some(function(regexp) {
      var matches = regexp.exec(line);
      if (matches !== null) {
        keyword = matches[1];
        return true;
      }
      return false;
    });

    return keyword;
  };


  /*
   * Checks that the line has at least the minimum amount of indentation required, throwing when it does not.
   *
   */

  var checkMinimumIndent = function(line, indentLevel) {
    if (indentLevel === 0) return;
    var indentRegExp = new RegExp('^\\s{' + indentLevel + '}');
    if (!indentRegExp.test(line))
      throw new Error('Inconsistent indentation! Line \'' + line + '\' has less indentation than surrounding docs');
  };


  /*
   * Removes the global indentation from a line, throwing if there is additional indentation remaining.
   *
   */

  var removeIndent = function(line, indentLevel) {
    checkMinimumIndent(line, indentLevel);

    var orig =  line;
    line = line.slice(indentLevel);
    if (/^\s/.test(line))
      throw new Error('Inconsistent indentation! Line \'' + orig + '\' has more indentation than surrounding docs');

    return line;
  };


  /*
   * Checks whether a line from a text field could prove problematic when generating HTML from any Markdown that
   * would be generated from this comment.
   *
   * XXX This creates an unfortunate coupling between this file and the HTML generators.
   *
   */

  var checkLineForHTMLGeneration = function(line) {
    if (line.indexOf('** Usage: **') === 0 || line.indexOf('Parameters:') === 0 || line.indexOf('* Synonyms: *') === 0 ||
        line.indexOf('See ') === 0 || /^(\*\s*|-\s*){3,}/.test(line) || /^#{1,6}\s+/.test(line))
      throw new Error('Line will prove problematic for HTML generation from Markdown ' + line);
  };


  /*
   * Processes a line suspected of containing either a keyword or the summary, and fills out the appropriate field
   * and makes the appopriate mode transition.
   *
   * This function also enforces the requirements that parameters must be contiguous, and that return types must
   * immediately follow parameter descriptions, and that code examples cannot appear before the summary.
   *
   */

  var processKeywordLine = function(line, params, options, currentMode, allowProblematic) {
    if (/^\s*$/.test(line)) return currentMode;
    line = removeIndent(line, params.globalIndent);

    // The line either contains a "special line" or is the start of the summary
    var lineKeyword = getLineKeyword(line);
    if (lineKeyword) {
      line = line.slice(line.indexOf(':') + 1);

      switch (lineKeyword) {
        case 'category':
          if (params.category !== null)
            throw new Error('Duplicate category encountered!');

          params.category = processCategory(line);
          return currentMode === MODE_PARAMETERS ? MODE_POSTPARAMETERS : currentMode;

        case 'synonyms':
          if (options.synonyms !== null)
            throw new Error('Duplicate synonyms encountered!');

          options.synonyms = processSynonyms(line);
          return currentMode === MODE_PARAMETERS ? MODE_POSTPARAMETERS : currentMode;

        case 'returns':
          if (options.returnType !== null)
            throw new Error('Duplicate return types encountered!');

          if (currentMode === MODE_POSTPARAMETERS)
            throw new Error('Cannot have fields separating parameters and return type');

          options.returnType = processReturnTypes(line);
          return currentMode === MODE_PARAMETERS ? MODE_POSTPARAMETERS : currentMode;

        case 'parameter':
          if (options.returnType !== null)
            throw new Error('Parameters found after return type');

          if (options.parameters === null)
            options.parameters = [];

          if (currentMode === MODE_POSTPARAMETERS)
            throw new Error('Parameters must be contiguous');

          options.parameters = processParameter(line, options.parameters);
          return MODE_PARAMETERS;

        case 'examples':
          throw new Error('Missing summary');

        default:
          throw new Error('Unreachable!');
      }
    }

    // Otherwise this is the start of the summary
    if (!allowProblematic)
      checkLineForHTMLGeneration(line);

    params.summary = [line];
    return MODE_SUMMARY;
  };


  /*
   * Processes a line assumed to be part of the summary. If the line is empty, this will force a transition to
   * MODE_DETAILS; a transition to MODE_EXAMPLES will be made if the examples keyword is found. Any other keyword
   * will trigger an error.
   *
   */

  var processSummaryLine = function(line, params, options, allowProblematic) {
    if (/^\s*$/.test(line))
      return MODE_DETAILS;

    line = removeIndent(line, params.globalIndent);

    // When we are processing the summary, we allow code samples, but no other keywords
    var lineKeyword = getLineKeyword(line);
    if (lineKeyword) {
      if (lineKeyword === 'examples') {
        options.examples = [];
        return MODE_EXAMPLES;
      }

      throw new Error('Unexpected documentation line in summary!' + line);
    }

    if (!allowProblematic)
      checkLineForHTMLGeneration(line);

    params.summary.push(line);
    return MODE_SUMMARY;
  };


  /*
   * Processes a line containing a string that forms part of the details, and accumulating it into the 'details' field
   * of the supplied options object, whilst watching out for a line that would trigger a transition to the examples
   * state.
   *
   */

  var processDetailsLine = function(line, params, options, allowProblematic) {
    if (!(/^\s*$/.test(line))) {
      // Note: we can only use removeIndent for the first line; we allow further indents on later lines
      if (options.details === null || options.details.length === 0) {
        // First non-trivial line
        line = removeIndent(line, params.globalIndent);
      } else {
        checkMinimumIndent(line, params.globalIndent);
        line = line.slice(params.globalIndent);
      }
    }

    var lineKeyword = getLineKeyword(line);
    if (lineKeyword) {
      if (lineKeyword === 'examples') {
        // The examples keyword must be indented correctly (but account for the fact that we've already removed the
        // global indent)
        removeIndent(line, 0);

        options.examples = [];
        return  MODE_EXAMPLES;
      }

      throw new Error('Unexpected documentation line in details!' + line);
    }

    if (options.details === null) options.details = [];

    // Skip over repeated trailing empty lines at the beginning
    if (options.details.length > 0 || !(/^\s*\n?$/.test(line))) {
      if (!allowProblematic)
        checkLineForHTMLGeneration(line);

      options.details.push(line);
    }

    return MODE_DETAILS;
  };


  /*
   * Accumulates a line containing code samples into the 'examples' property of the supplied options object,
   * throwing if an unexpected keyword is encountered.
   *
   */

  var processExamplesLine = function(line, params, options, allowProblematic) {
    var lineKeyword = getLineKeyword(line);

    if (lineKeyword)
      throw new Error('Data line cannot appear in examples');

    // We ignore empty lines after the start of the examples marker
    if (/^\s*\n?$/.test(line)) {
      if (options.examples.length > 0)
        options.examples.push('');
      return MODE_EXAMPLES;
    }

    if (options.examplesIndent === null) {
      // The indent level has not been set, so this must be the first non-empty line (if it was empty we would have
      // returned early above). First, we must check that it meets the minimum indent. Note, we cannot use removeIndent
      // as this line might be establishing an example block indent, which may well be bigger.
      if (params.globalIndent > 0)
        checkMinimumIndent(line, params.globalIndent);
      line = line.slice(params.globalIndent);

      // How much indent is left? This establishes the indent for the remainder of the examples lines.
      var remainingWhitespace = /^\s+/.exec(line);
      options.examplesIndent = remainingWhitespace === null ? 0 : remainingWhitespace[0].length;
      line = line.slice(options.examplesIndent);
    } else {
      // We cannot use removeIndent, as additional indent is permissible
      checkMinimumIndent(line, params.globalIndent + options.examplesIndent);
      line = line.slice(params.globalIndent + options.examplesIndent);
    }

    if (!allowProblematic)
      checkLineForHTMLGeneration(line);

    options.examples.push(line);
    return MODE_EXAMPLES;
  };


  /*
   * Helper utility that removes empty lines from the end of an array.
   *
   */

  var trimTrailingEmptyLines = function(arr) {
    return arr.reduceRight(function(soFar, current) {
      if (soFar.length === 0 && /^\s*\n?$/.test(current))
        return soFar;
      return [current].concat(soFar);
    }, []);
  };


  return function(lines, generationOptions) {
    generationOptions = generationOptions || {allowProblematicForHTMLGeneration: true};

    var tag = lines.tag.toLowerCase();
    if (tag !== 'apifunction' && tag != 'apiobject')
      throw new Error('Unrecognised tag');

    var mode = MODE_AWAITINGNAME;

    var mandatoryParameters = {
      name: null,
      category: null,
      summary: null,
      globalIndent: 0,
    };

    // Note, that as a slight hack to avoid passing more in/out params around, we store some indent information in
    // the options object, deleting it before we pass it to the constructor

    var options = {
      details:  null,
      synonyms:  null,
      returnType:  null,
      parameters:  null,
      examples:  null,
      examplesIndent: null
    };

    var allowProblematic = generationOptions.allowProblematicForHTMLGeneration;

    lines.forEach(function(line) {
      var lineKeyword, separator;

      switch (mode) {
        case MODE_AWAITINGNAME:
          mode = processName(line, mandatoryParameters, mode);
          break;

        case MODE_OPTIONALS:
        case MODE_PARAMETERS:
        case MODE_POSTPARAMETERS:
          mode = processKeywordLine(line, mandatoryParameters, options, mode, allowProblematic);
          break;

        case MODE_SUMMARY:
          mode = processSummaryLine(line, mandatoryParameters, options, allowProblematic);
          break;

        case MODE_DETAILS:
          mode = processDetailsLine(line, mandatoryParameters, options, allowProblematic);
          break;

        case MODE_EXAMPLES:
          mode = processExamplesLine(line, mandatoryParameters, options, allowProblematic);
          break;

        default:
          throw new Error('Unreachable!');
      }
    });

    Object.keys(options).forEach(function(key) {
      if (options[key] === null)
        delete options[key];
    });

    if (mandatoryParameters.name === null)
      throw new Error('No function name found!');

    if (mandatoryParameters.category === null)
      throw new Error('No category found!');

    if (mandatoryParameters.summary === null)
      throw new Error('No summary found!');

    // Merge multiple summary lines into one. We don't want to do a join; the line may already have the requisite
    // newlines.
    var summary = mandatoryParameters.summary.reduce(function(soFar, current) {
      var separator = /\n$/.test(soFar) ? '' : '\n';
      return soFar + separator + current;
    });

    // Remove trailing empty lines at the end of details and examples
    if (options.details !== undefined)
      options.details = trimTrailingEmptyLines(options.details);
    if (options.examples !== undefined)
      options.examples = trimTrailingEmptyLines(options.examples);

    if (options.examples !== undefined && options.examples.length === 0)
      throw new Error('Examples are degenerate');

    var constructor = APIFunction;
    if (tag === 'apiobject') {
      constructor = APIObject;
      if (options.parameters || options.returnType || options.synonyms)
        throw new TypeError('APIFunction properties found in an APIObject');
    }

    // Delete temporary values
    delete options.globalIndent;
    delete options.examplesIndent;

    return constructor(mandatoryParameters.name, lines.file, mandatoryParameters.category, summary, options);
  };
})();

},{"./APIFunction":2,"./APIObject":3}],7:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /*
   * The LineProcessor takes an array of arrays of lines, as output by '.split'.ting on the comments property returned
   * by Esprima. It then filters these to the portions tagged as API documentation, removing any comment cruft in the
   * process.
   *
   * It enforces the following requirements:
   *   - A comment block contains only one <apifunction> or <apiobject> delimiter, and it is the only item present on
   *     the line (modulo whitespace and preceding / trailing comment formatting asterisks)
   *   - A comment block contains at most one </apifunction> or <apiobject> delimiter, and it is the only item present
   *     on the line (modulo whitespace and preceding / trailing comment formatting asterisks)
   *   - The tags are consistent
   *   - The supplied comment block was tagged with the file it came from in a 'file' property (the returned filtered
   *     array will preserve this property).
   *
   * The returned array will have a property named 'tagh' denoting the type of tag found (without angle brackets).
   *
   */

  var LineProcessor = function(comments) {
    var result = [];

    comments.forEach(function(commentLines) {
      var typeFound;

      if (commentLines.some(function(line) {
        // We are relying on the early exit properties of some
        typeFound = null;

        if (line.indexOf('<apifunction>') !== -1)
          typeFound = 'apifunction';
        else if (line.indexOf('<apiobject>') !== -1)
          typeFound = 'apiobject';

        return typeFound !== null;
      })) {
        result.push(processLines(commentLines, typeFound));
      }
    });

    return result;
  };


  var regexps = {
    'apifunction' : {
      opening: /<apifunction>/, closing: /<\/apifunction>/, opposite: /<\/?apiobject>/
    },
    'apiobject' : {
      opening: /<apiobject>/, closing: /<\/apiobject>/, opposite: /<\/?apifunction>/
    }
  };


  var processLines = function(lines, tagFound) {
    // We assume the caller has checked for the presence of an opening delimiter
    var opened = false;
    var closed = false;
    var openingRegExp = regexps[tagFound].opening;
    var closingRegExp = regexps[tagFound].closing;
    var oppositeRegExp = regexps[tagFound].opposite;

    if (lines.file === undefined)
      throw new Error('Comments were not tag with their file origin');

    var result = lines.reduce(function(result, line) {
      if (openingRegExp.test(line)) {
        // Remove the opening delimiter, or throw if we have more than one, or it is not the only item on the line
        if (opened || closed || !(new RegExp('^\\s*(\\*\\s*)?<' + tagFound + '>\\s*(\\*\\s*)?$')).test(line))
          throw new Error('Duplicate API documentation opening tag!');

        opened = true;
      } else if (closingRegExp.test(line)) {
        // Remove the closing delimiter, or throw if we have more than one, we have not found encountered an opening
        // delimiter or it is not the only item on the line
        if (!opened || closed || !(new RegExp('^\\s*(\\*\\s*)?</' + tagFound + '>\\s*(\\*\\s*)?$')).test(line))
          throw new Error('Invalid API documentation closing tag!');

        closed = true;
      } else if (oppositeRegExp.test(line)) {
        throw new Error('Inconsistent tag found!');
      } else if (opened && !closed) {
        // This line lies between the opening and closing delimiters. Strip any trailing whitespace, any comment
        // formatting asterisks, and add it to the result. (It is OK if later lines are malformed: we'll throw when
        // we encounter them).
        var match = /^(\s*\*\s?)?(.+)/.exec(line);
        result.push(match !== null ? match[2].replace(/\s*(\*\s*)?$/, '') : line);
      }

      return result;
    }, []);

    result.tag = tagFound;
    result.file = lines.file;
    return result;
  };


  return LineProcessor;
})();

},{}],8:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var APIFunction = require('./APIFunction');
  var APIObject = require('./APIObject');


  /*
   * The MarkdownCreator function takes an APIFunction or APIObject object (or an object denoting a synonym) describing
   * a synonym, and produces a fragment of Markdown suitable for inclusion in Markdown documentation. The function takes
   * two parameters: the APIFunction/APIObject/synonym object being described, and an object containing options.
   *
   * The function throws if the first parameter is not an APIFunction/APIObject object, or does not have the required
   * properties for a synonym object. Likewise, it throws if the second parameter is not an object.
   *
   * A synonym object is an object with two mandatory properties: 'name' and 'synonymFor'. 'name' should be the name
   * under which the function can be invoked, and 'synonymFor' the name of the function which will really be invoked.
   *
   * The synonym object is provided for smoother developer ergonomics: the client can map over an array containing
   * APIFunctions, APIObjects and their synonyms in one fell swoop, instead of having to handle the two separately and
   * somehow merge the results.
   *
   * When presented with a synonym object, the output will contain a heading for the synonym name, and some
   * explanatory text directing the reader to the documentation for the real function. The link will be to a named
   * anchor within the same page, whose name is the same as that of the real function.
   *
   * Otherwise, the object is an APIFunction/APIObject. Again, the output will first contain a heading with the object
   * name. This might optionally be followed by the category of the object: this behaviour can be controlled by setting
   * the 'includeCategory' property of the options object to the appropriate boolean value. (This is useful if the
   * client is producing documentation which groups the values by category; there is little sense then of repeating
   * the category in the function's documentation.
   *
   * If the object is a function can be invoked with alternate names, these synonyms will be listed on the next line.
   *
   * If the object is a function, a usage line will follow, noting the names of any formal parameters to the function,
   * as found in the 'parameters' property of the supplied APIFunction.
   *
   * If the object is a function, and takes 1 or more parameters, a paragraph will follow, with each line containg the
   * name of one parameter, followed by a list of acceptable types for the parameter.
   *
   * Next, if the object is a function returning a result, a list of types returned will be output.
   *
   * Following this, the summary of the function or object's functionality will be added. If the value's 'details'
   * property contains additional explanatory notes, these will immediately follow.
   *
   * Finally, any code examples will be appended, formatted as a Markdown code block.
   *
   * The output will be a single string, with line endings denoted by the newline character. The function's output will
   * be wrapped in an HTML5 section tag.
   *
   * Lists of types, function names and parameter names will be formatted with Markdown inline code formatting.
   *
   */

  var isRealObject = function(obj) {
    return typeof(obj) === 'object' && obj !== null && !Array.isArray(obj);
  };


  var isSynonymObject = function(obj) {
    return isRealObject(obj) && !(obj instanceof APIFunction) && ('synonymFor' in obj) && ('name' in obj);
  };


  /*
   * Add a line to the 'result' array describing the category of functions that the function being described belongs to.
   *
   */

  var printCategory = function(category, result) {
    result.push('Category: ' + category);
    result.push('');
  };


  /*
   * Prints the list of synonyms for the function; each alternate name is marked up as a list entry in an unordered
   * list. Assumes the array is non-empty.
   *
   */

  var printSynonyms = function(synonyms, result) {
    result.push('*Synonyms:* ' + synonyms.map(printAType).join(''));
    result.push('');
  };


  /*
   * Prints an example of a typical invocation of the function being described, illustrating also the names of the
   * formal parameters (if any).
   *
   * For example, if a function is named foo and has formal parameters x and y, the line "result = foo(x, y);" will be
   * printed.
   *
   * The resulting line will be contained in Markdown markup for inline code. The line will be added to the end of the
   * given 'result' array.
   *
   */

  var printUsageLine = function(name, parameters, returnType, result) {
    var rtn = returnType.length > 0 ? '`var result = ' : '`';
    var params = parameters.map(function(p) { return p.name; }).join(', ');
    result.push('**Usage:** ' + rtn + name + '(' + params + ');`');
    result.push('');
  };


  /*
   * Helper function for printing types separated by pipe characters, and enclosed in Markdown markup for inline
   * code. This function is intended to be invoked by a map call; the parameters are the standard ones supplied to
   * a mapping function.
   *
   */

  var printAType = function(type, i, arr) {
    return '`' + type + '`' + (i !== arr.length - 1 ? ' | ' : '');
  };


  /*
   * Prints a paragraph detailing the formal parameters of a function.
   *
   * After an initial line denoting the start of parameter output, each line will contain the name of the parameter,
   * followed by the types accepted, with each type separated by pipe (|) characters, and enclosed in Markdown markup
   * for inline code.
   *
   * The array of parameters should be non-empty. The resulting lines are appended to the provided 'result' array.
   */

  var printParameters = function(parameters, result) {
    var printAParam = function(param, i, arr) {
      result.push(param.name + ' ' + param.type.map(printAType).join('') + (i !== arr.length - 1 ? '  ' : ''));
    };
    result.push('Parameters:  ');
    parameters.forEach(printAParam);
    result.push('');
  };


  /*
   * Prints a line describing the possible types that can be returned from a function. Each type will be separated by a
   * pipe character, and will be enclosed in Markdown markup for inline code.
   *
   * The returnType array is assumed to be non-empty. The generated line will be appended to the given 'result' array.
   */

  var printReturnType = function(returnType, result, toLink) {
    result.push('Returns: ' + returnType.map(printAType).join(''));
    result.push('');
  };


  /*
   * Prints the detailed instructions for the function usage. No formatting is applied, however any extant formatting
   * in the original comment will be retained.
   *
   * The details array is assumed to be non-empty. The lines will be appended to the provided 'result' array.
   *
   */

  var printDetails = function(details, result) {
    result.push('');
    details.forEach(function(line) { result.push(line); });
  };


  /*
   * Prints the code examples for this function, first applying the Markdown indent for code block formatting for each
   * line.
   *
   * The examples array is assumed to be non-empty. The generated lines will be added to the provided 'result' array.
   *
   *
   */

  var printExamples = function(examples, result) {
    result.push('');
    result.push('#### Examples ####');
    examples.forEach(function(line) { result.push('    ' + line); });
  };


  var markdownCreator = function(apiFunction, options) {
    if (!isRealObject(apiFunction) ||
        !((apiFunction instanceof APIFunction) || (apiFunction instanceof APIObject) || isSynonymObject(apiFunction)))
      throw new Error('Invalid object');

    if (!isRealObject(options))
      throw new Error('Invalid Markdown options');

    var result = [];

    // All function names should be <h3> anchors
    result.push('### ' + apiFunction.name + ' ###');

    // Bail early for synonyms
    if ('synonymFor' in apiFunction) {
      result.push('See `' + apiFunction.synonymFor + '`');
      result.push('***');
      return result.join('\n');
    }

    // It doesn't make sense to print the category in the "By category" listing, so check to see if the supplied
    // options prevent it being printed
    if ('includeCategory' in options && options.includeCategory)
      printCategory(apiFunction.category, result);

    if (!(apiFunction instanceof APIObject)) {
      // List any synonyms
      if (apiFunction.synonyms.length > 0)
        printSynonyms(apiFunction.synonyms, result);

      printUsageLine(apiFunction.name, apiFunction.parameters, apiFunction.returnType, result);

      // Print a table of the parameters and their allowable types, linking any types specified in the options
      if (apiFunction.parameters.length > 0)
        printParameters(apiFunction.parameters, result);

      // Print the possible return types, linking any types specified in the options
      if (apiFunction.returnType.length > 0)
        printReturnType(apiFunction.returnType, result);
    }

    result.push(apiFunction.summary);

    // Append any details
    if (apiFunction.details.length > 0)
      printDetails(apiFunction.details, result);

    // Append any code examples, applying the 4-space formatting required by Markdown to recognise code blocks
    if (apiFunction.examples.length > 0)
      printExamples(apiFunction.examples, result);

    result.push('***');
    return result.join('\n');
  };


  return markdownCreator;
})();

},{"./APIFunction":2,"./APIObject":3}],9:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var marked = require('marked');


  /*
   * Output a synonym's link to the underlying function.
   *
   */

  var renderSeeAlso = function(text) {
    var innerCode = text.slice('See <code>'.length);
    innerCode = innerCode.slice(0, innerCode.indexOf('<'));
    return '<p class="see">See <a class="synonymLink" href="#' + innerCode + '"><code class="synonymCode">' +
           innerCode + '</code></a></p>\n';
  };



  /*
   * Output a paragraph denoting a value's category. Throws if options.isCategory is undefined or false and
   * options.categoryFile is also false
   *
   */

  var renderCategory = function(text, options) {
    var catName = text.slice('Category: '.length).trim();

    if (options.isCategory)
      return '<p class="category">Category: <a class="categoryLink" href="#' + catName + '">' +
             catName + '</a></p>\n';

    if (options.categoryFile === undefined)
      throw new Error('Cannot link to category: no category file specified!');

    return '<p class="category">Category: <a class="categoryLink" href="' + options.categoryFile + '#' +
           catName + '">' + catName + '</a></p>\n';
  };


  var renderUsage = function(text) {
    text = text.slice('<strong>Usage:</strong> '.length).trim();
    return '<p class="usage"><strong>Usage:</strong> <code class="usageCode">' + text.split('<code>')[1] + '</p>\n';
  };


  var renderReturns = function(text, options) {
    var links = Array.isArray(options.toLink) ? options.toLink.map(function(s) { return s.toLowerCase(); }) : [];

    text = text.slice('Returns: <code>'.length).trim();
    var types = text.split(/<\/code>(?: \| <code>)?/).filter(function(s) { return s !== ''; });

    return '<div class="returns">Returns: <ul class="returnTypes"><li class="returnItem">' + types.map(function(t) {
      var shouldLink = links.indexOf(t.toLowerCase()) !== -1;
      return (shouldLink ? '<a class="typeLink" href="#' + t.toLowerCase() + '">' : '') +
             '<code class="returnType type">' + t + '</code>' +
             (shouldLink ? '</a>' : '');
    }).join('</li><li class="returnItem">') + '</li></ul></div>\n';
  };


  var renderSynonyms = function(text) {
    text = text.slice('<em>Synonyms:</em> <code>'.length).trim();
    var names = text.split(/<\/code>(?: \| <code>)?/).filter(function(s) { return s !== ''; });

    return '<div class="synonyms"><em>Synonyms:</em> <ul class="synonymsList">' +
      names.map(function(n) {
        return '<li class="synonym"><code class="synonymName">' + n + '</code></li>';
      }).join('') + '</ul></div>\n';
  };


  var renderParameters = function(text, options) {
    var links = Array.isArray(options.toLink) ? options.toLink.map(function(s) { return s.toLowerCase(); }) : [];

    text = text.slice('Parameters:<br>'.length).trim();
    var lines = text.split('<br>');
    return '<section class="parameters"><h4 class="parametersHeader">Parameters</h4>' +
      '<ol class="parameterList"><li class="param">' + lines.map(function(line) {
        var splitPoint = line.indexOf(' ');
        var name = line.slice(0, splitPoint);
        var remaining = line.slice(splitPoint + ' <code>'.length);
        var types = remaining.split(/<\/code>(?: \| <code>)?/).filter(function(s) { return s !== ''; });

        return name + ': <ul class="paramTypes"><li class="paramsItem">' + types.map(function(t) {
          var shouldLink = links.indexOf(t.toLowerCase()) !== -1;
          return (shouldLink ? '<a class="typeLink" href="#' + t.toLowerCase() + '">' : '') +
            '<code class="paramType type">' + t + '</code>' + (shouldLink ? '</a>' : '');
        }).join('</li><li class="paramsItem">') + '</li></ul>';
      }).join('</li><li class="param">') + '</li></ol></section>\n';
  };


  var renderParagraph = function(text, options) {
    if (/^See\s</.test(text))
      return renderSeeAlso(text);

    if (/^Category:\s/.test(text))
      return renderCategory(text, options);

    if (/<strong>Usage:</.test(text))
      return renderUsage(text);

    if (/Returns:/.test(text))
      return renderReturns(text, options);

    if (/Synonyms:/.test(text))
      return renderSynonyms(text);

    if (/Parameters:/.test(text))
      return renderParameters(text, options);

    return new marked.Renderer().paragraph(text);
  };


  var makeMarkdownRenderer = function(toLink, options) {
    options = options || {};
    var renderer = new marked.Renderer();


    var categoryOpened = false;

    renderer.heading = function(text, level, raw) {
      if (level === 2) {
        var pre = categoryOpened ? '</section>\n' : '';
        return pre + '<section class="categoryRef" id="' + text + '">\n' +
               '<h2 class="categoryName">' + text + '</h2>\n';
      } else if (level === 3) {
        return '<section class="functionRef" id="' + text + '">\n' +
               '<h3 class="functionName">' + text + '</h3>\n';
      } else if (level === 4) {
        return '<section class="examples"><h4>' + text + '</h4>\n';
      } else {
        return '<h' + level + '>' + text + '</h' + level + '>\n';
      }
    };


    renderer.paragraph = function(text) {
      return renderParagraph(text, options);
    };


    renderer.code = function(code) {
      return new marked.Renderer().code(code) + '</section>\n';
    };


    renderer.hr = function() { return '</section>\n'; };


    return renderer;
  };


  return makeMarkdownRenderer;
})();

},{"marked":35}],10:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;
  var curryWithConsistentStyle = curryModule._curryWithConsistentStyle;
  var arityOf = curryModule.arityOf;

  var base = require('./base');

  var types = require('./types');
  var strictEquals = types.strictEquals;

  var object = require('./object');
  var callPropWithArity = object.callPropWithArity;

  var internalUtilities = require('../internalUtilities');
  var checkIntegral = internalUtilities.checkIntegral;
  var checkPositiveIntegral = internalUtilities.checkPositiveIntegral;
  var checkArrayLike = internalUtilities.checkArrayLike;
  var defineValue = internalUtilities.defineValue;

  var funcUtils = require('../funcUtils');
  var checkFunction = funcUtils.checkFunction;

  var pair = require('./pair');
  var Pair = pair.Pair;
  var fst = pair.fst;
  var snd = pair.snd;

  var logical = require('./logical');
  var notPred = logical.notPred;


  /*
   * <apifunction>
   *
   *
   * length
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: number
   *
   * Takes an array, string or other arrayLike value, and returns its length. Throws a TypeError if the given value is not an arrayLike.
   *
   * Examples:
   *   funkierJS.length([1, 2, 3]); // => 3
   *
   */

  var length = curry(function(arr) {
    arr = checkArrayLike(arr, {message: 'Value must be arrayLike'});

    return arr.length;
  });


  /*
   * <apifunction>
   *
   * getIndex
   *
   * Category: array
   *
   * Parameter: index: number
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Takes an index and an array, string or other arrayLike value and returns the element at the given index. Throws a
   * TypeError if the index is outside the range for the given object.
   *
   * Examples:
   *   funkierJS.getIndex(1, "abcd"); 1
   *
   */

  var getIndex = curry(function(i, a) {
    a = checkArrayLike(a);
    i = checkPositiveIntegral(i, {errorMessage: 'Index out of bounds'});
    if (i >= a.length)
      throw new TypeError('Index out of bounds');

    return a[i];
  });


  /*
   * <apifunction>
   *
   * head
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Takes an array, string or other arrayLike value and returns the first element. Throws a TypeError when given an
   * empty arrayLike.
   *
   * Examples:
   *   funkierJS.head([1, 2, 3]); // => 1
   *
   */

  var head = getIndex(0);


  /*
   * <apifunction>
   *
   * last
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Takes an array, string or other arrayLike value, and returns the last element. Throws a TypeError when given an
   * empty arrayLike.
   *
   * Examples:
   *   funkierJS.last([1, 2, 3]); // => 3
   *
   */

  var last = curry(function(a) {
    return getIndex(a.length - 1, a);
  });


  /*
   * <apifunction>
   *
   * replicate
   *
   * Category: array
   *
   * Parameter: length: natural
   * Parameter: arr: arrayLike
   * Returns: array
   *
   * Takes a length and a value, and returns an array of the given length, where each element is the given value. Throws
   * a TypeError if the given length is negative.
   *
   * Examples:
   *   funkierJS.replicate(5, 42); // => [42, 42, 42, 42, 42]
   *
   */

  var replicate = curry(function(l, value) {
    l = checkPositiveIntegral(l, {errorMessage: 'Replicate count invalid'});

    var result = [];

    for (var i = 0; i < l; i++)
      result.push(value);

    return result;
  });


  /*
   * A number of functions are essentially wrappers around array primitives that take a function.
   * All these functions would, if written separately, have a similar blueprint:
   *
   * - Check the first argument is a function of the correct arity
   * - Check the last argument is an array or string, and split it if it was a string
   * - Call the array primitive with the last argument as execution context, with the other arguments as parameters
   * - Optionally put the string back together
   *
   * This function encapsulates this boilerplate. It takes the following parameters:
   * - arity: How many arguments the prop should be called with (this allows creation of versions
   *          that call the prop with or without optional arguments - e.g. reduce
   * - primitive: The primitive to call
   * - options: Whether the function should be a fixed arity, a minimum arity, the exception messages etc.
   *
   */

  var makeArrayPropCaller = function(arity, primitive, options) {
    options = options || {};

    return curryWithArity(arity, function() {
      var args = [].slice.call(arguments);
      var f = args[0];
      f = curryWithConsistentStyle(f, f, arityOf(f));
      var arr = last(args);
      var wasString = false;

      // Is the array really an array
      var arrCheckOptions = {};
      if ('aMessage' in options)
        arrCheckOptions.message = options.aMessage;
      arr = checkArrayLike(arr, arrCheckOptions);

      // Is the function really a suitable function?
      var fArity = 0;
      var fCheckOptions = {};
      if ('fixedArity' in options) {
        fCheckOptions.arity = options.fixedArity;
        fArity = options.fixedArity;
      } else if ('minimumArity' in options) {
        fCheckOptions.arity = options.minimumArity;
        fCheckOptions.minimum = true;
        fArity = options.minimumArity;
      }
      if ('fMessage' in options)
        fCheckOptions.message = options.fMessage;

      f = checkFunction(f, fCheckOptions);

      if (typeof(arr) === 'string') {
        wasString = true;
        arr = arr.split('');
      }

      // Ensure the function only gets called with as many parameters as were specified
      var fn = curryWithArity(fArity, function() {
        var args = [].slice.call(arguments);
        return f.apply(null, args);
      });
      args[0] = fn;

      var result = primitive.apply(arr, args.slice(0, args.length - 1));

      if ('returnSameType' in options && wasString)
        result = result.join('');

      return result;
    });
  };


  /*
   * <apifunction>
   *
   * map
   *
   * Category: array
   *
   * Parameter: f: function
   * Parameter: arr: arrayLike
   * Returns: array
   *
   * Takes a function f, and an array,string or other arrayLike. Returns an array arr2 where, for each element arr2[i],
   * we have arr2[i] === f(arr[i]). Throws a TypeError if the first argument is not a function, if the function does not
   * have an arity of at least 1, or if the last argument is not an arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `map` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied to
   * this function.
   *
   * Examples:
   *   funkierJS.map(plus(1), [2, 3, 4]); // => [3, 4, 5]
   *
   */

   var map = makeArrayPropCaller(2, Array.prototype.map,
                                 {minimumArity : 1, aMessage: 'Value to be mapped over is not an array/string',
                                                    fMessage: 'Mapping function must be a function with arity at least 1'});


  /*
   * <apifunction>
   *
   * each
   *
   * Category: array
   *
   * Parameter: f: function
   * Parameter: arr: arrayLike
   *
   * Takes a function f, and an array, string or arrayLike arr. Calls f with each member of the array in sequence, and
   * returns undefined.
   *
   * Throws a TypeError if the first argument is not a function, or if the second is not an arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `each` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.each(function(e) {console.log(e);}, [1, 2]); // => Logs 1 then 2 to the console
   *
   */

  var each = makeArrayPropCaller(2, Array.prototype.forEach,
                                 {minimumArity : 1, aMessage: 'Value to be iterated over is not an array/string',
                                  fMessage: 'forEach function must be a function with arity at least 1'});


  /*
   * <apifunction>
   *
   * filter
   *
   * Category: array
   *
   * Parameter: pred: function
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a predicate function pred, and an array, string or arrayLike arr. Returns an array or string containing
   * those members of arrin the same order as the original arrayfor which the predicate function returned true.
   *
   * Throws a TypeError if pred does not have arity 1, or if arr is not an arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `filter` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.filter(even, [2, 3, 4, 5, 6]); // => [2, 4, 6]
   *
   */

  var filter =  makeArrayPropCaller(2, Array.prototype.filter,
                                    {aMessage: 'Value to be filtered is not an array/string',
                                     fMessage: 'Predicate must be a function of arity 1',
                                     fixedArity: 1, returnSameType: true});


  /*
   * <apifunction>
   *
   * foldl
   *
   * Category: array
   *
   * Synonyms: reduce
   *
   * Parameter: f: function
   * Parameter: initial: any
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Takes three parameters: a function f of two arguments, an initial value, and an array, string or arrayLike.
   * Traverses the array or string from left to right, calling the function with two arguments: the current accumulation
   * value, and the current element. The value returned will form the next accumulation value, and `foldl` returns the
   * value returned by the final call. The first call's accumulation parameter will be the given initial value.
   *
   * Throws a TypeError if the first parameter is not a function of arity 2, or if the last parameter is not an array or
   * string.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `foldl` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.foldl(function(soFar, current) {return soFar*10 + (current - 0);}, 0, '123'); // 123
   *
   */

  var foldl = makeArrayPropCaller(3, Array.prototype.reduce,
                                 {fixedArity : 2, aMessage: 'Value to be iterated over is not an array/string',
                                  fMessage: 'Accumulator must be a function of arity 2'});


  /*
   * <apifunction>
   *
   * foldl1
   *
   * Category: array
   *
   * Synonyms: reduce1
   *
   * Parameter: f: function
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Takes two parameters: a function f of two arguments, and an array, string or arrayLike value. Traverses the array
   * from left to right from the second element, calling the function with two arguments: the current accumulation
   * value, and the current element. The value returned will form the next accumulation value, and foldl1 returns
   * returns the value returned by the final call. The first call's accumulation parameter will be the first element of
   * the array or string.
   *
   * Throws a TypeError if the first parameter is not a function of arity 2, if the last parameter is not an arrayLike,
   * or if the arrayLike is empty.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `foldl1` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.foldl1(multiply, [2, 3, 4]); // => 24
   *
   */

  var foldl1 = makeArrayPropCaller(2, Array.prototype.reduce,
                                   {fixedArity : 2, aMessage: 'Value to be iterated over is not an array/string',
                                    fMessage: 'Accumulator must be a function of arity 2'});


  /*
   * <apifunction>
   *
   * foldr
   *
   * Category: array
   *
   * Synonyms: reduceRight
   *
   * Parameter: f: function
   * Parameter: initial: any
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Takes three parameters: a function f of two arguments, an initial value, and an array, string or arrayLike value.
   * Traverses the array or string from right to left, calling the function with two arguments: the current accumulation
   * value, and the current element. The value returned will form the next accumulation value, and foldr returns the
   * value returned by the final call. The first call's accumulation parameter willbe the given initial value.
   *
   * Throws a TypeError if the first parameter is not a function of arity 2, or if the last parameter is not an
   * arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `foldr` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.foldr(subtract, 0, [2, 3, 4]); // => -9
   *
   */

  var foldr = makeArrayPropCaller(3, Array.prototype.reduceRight,
                                 {fixedArity : 2, aMessage: 'Value to be iterated over is not an array/string',
                                  fMessage: 'Accumulator must be a function of arity 2'});


  /*
   * <apifunction>
   *
   * foldr1
   *
   * Category: array
   *
   * Synonyms: reduceRight1
   *
   * Parameter: f: function
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Takes two parameters: a function f of two arguments, and an array, string or arrayLike. Traverses the array from
   * right to left from the penultimate element, calling the function with two arguments: the current accumulation
   * value, and the current element. The value returned will form the next accumulation value, and foldr1 returns
   * returns the value returned by the final call. The first call's accumulation parameter will be the last element of
   * the array or string.
   *
   * Throws a TypeError if the first parameter is not a function of arity 2, if the last parameter is not an array or
   * string, or if the array or string is empty.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `foldr1` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.foldr1(function(soFar, current) {return current + soFar;}, "banana"); // => ananab
   *
   */

  var foldr1 = makeArrayPropCaller(2, Array.prototype.reduceRight,
                                   {fixedArity : 2, aMessage: 'Value to be iterated over is not an array/string',
                                    fMessage: 'Accumulator must be a function of arity 2'});


  /*
   * <apifunction>
   *
   * every
   *
   * Category: array
   *
   * Parameter: pred: function
   * Parameter: arr: arrayLike
   * Returns: boolean
   *
   * Synonyms: all
   *
   * Takes two parameters: a predicate function p that takes one argument, and an array, string or arrayLike. Calls the
   * predicate with every element of the array or string, until either the predicate function returns false, or the end
   * of the array or string is reached.
   *
   * Returns the last value returned by the predicate function.
   *
   * Throws a TypeError if p is not a function of arity 1, or if the second argument is not an arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `every` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.every(even, [2, 4, 6]); // => true
   *
   */

  var every = makeArrayPropCaller(2, Array.prototype.every,
                                  {fixedArity : 1, aMessage: 'Value to be iterated over is not an array/string',
                                   fMessage: 'Predicate must be a function of arity 1'});


  /*
   * <apifunction>
   *
   * some
   *
   * Category: array
   *
   * Parameter: pred: function
   * Parameter: arr: arrayLike
   * Returns: boolean
   *
   * Synonyms: any
   *
   * Takes two parameters: a predicate function p that takes one argument, and an array, string or arrayLike. Calls the
   * predicate with every element of the array or string, until either the predicate function returns true, or the end
   * of the array or string is reached.
   *
   * Returns the last value returned by the predicate function.
   *
   * Throws a TypeError if p is not a function of arity 1, or if the second argument is not an array or string.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `some` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   funkierJS.some(odd, [2, 4, 5, 6]; // => true
   *
   */

  var some = makeArrayPropCaller(2, Array.prototype.some,
                                 {fixedArity : 1, aMessage: 'Value to be iterated over is not an array/string',
                                  fMessage: 'Predicate must be a function of arity 1'});


  /*
   * <apifunction>
   *
   * maximum
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Returns the largest element of the given array, string or arrayLike.
   *
   * Throws a TypeError if the value is not an arrayLike, or it is empty.
   *
   * Note: this function is intended to be used with arrays containing numeric or character data. You are of course free
   * to abuse it, but it will likely not do what you expect.
   *
   * Examples:
   *   funkierJS.maximum([20, 10]); // => 20
   *
   */

  var maxFn = function(soFar, current) {
    if (current > soFar)
      return current;
    return soFar;
  };

  var maximum = foldl1(maxFn);


  /*
   * <apifunction>
   *
   * minimum
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: any
   *
   * Returns the smallest element of the given array, string or arrayLike. Throws a TypeError if the value is not an
   * arrayLike, or it is empty.
   *
   * Note: this function is intended to be used with arrays containing numeric or character data. You are of course
   * free to abuse it, but it will likely not do what you expect.
   *
   * Examples:
   *   funkierJS.minimum([20, 10]); // => 10
   *
   */

  var minFn = function(soFar, current) {
    if (current < soFar)
      return current;
    return soFar;
  };

  var minimum = foldl1(minFn);


  /*
   * <apifunction>
   *
   * sum
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: number
   *
   * Returns the sum of the elements of the given array, or arrayLike. Throws a TypeError if the value is not an
   * arrayLike, or it is empty.
   *
   * Note: this function is intended to be used with arrays containing numeric data. You are of course free to abuse it,
   * but it will likely not do what you expect.
   *
   * Examples:
   *   funkierJS.sum([20, 10]); // => 30
   *
   */

  var sumFn = function(soFar, current) {
    // Hack to prevent execution with strings
    if (typeof(current) === 'string')
      throw new TypeError('sum called on non-array value');

    return soFar + current;
  };

  var sum = foldl(sumFn, 0);


  /*
   * <apifunction>
   *
   * product
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: number
   *
   * Returns the product of the elements of the given array, or arrayLike. Throws a TypeError if the value is not an
   * arrayLike, or it is empty.
   *
   * Note: this function is intended to be used with arrays containing numeric data. You are of course free to abuse it,
   * but it will likely not do what you expect.
   *
   * Examples:
   *   funkierJS.product([20, 10]); // => 200
   *
   */

  var productFn = function(soFar, current) {
    // Hack to prevent execution with strings
    if (typeof(current) === 'string')
      throw new TypeError('sum called on non-array value');

    return soFar * current;
  };

  var product = foldl(productFn, 1);


  /*
   * <apifunction>
   *
   * element
   *
   * Category: array
   *
   * Parameter: val: any
   * Parameter: arr: arrayLike
   * Returns: boolean
   *
   * Takes a value and an array, string or arrayLike. Returns true if the value is in the arrayLike (checked for strict
   * identity) and false otherwise.
   *
   * Throws a TypeError if the second argument is not an arrayLike.
   *
   * Examples:
   *   funkierJS.element('a', 'cable'); // => true
   *
   */

  var element = curry(function(val, arr) {
    return some(strictEquals(val), arr);
  });


  /*
   *
   * <apifunction>
   *
   * elementWith
   *
   * Category: array
   *
   * Parameter: pred: function
   * Parameter: arr: arrayLike
   * Returns: boolean
   *
   * A generalised version of element. Takes a predicate function p of one argument, and an array, string or arrayLike.
   * Returns true if there is an element in the arrayLike for which p returns true, and returns false otherwise.
   *
   * Throws a TypeError if the first argument is not a function of arity 1, or the second argument is not an arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `element` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   var p = function(e) {return e.foo = 42;};
   *   funkierJS.elementWith(p, [{foo: 1}, {foo: 42}]); // => true
   *
   */

  var elementWith = curry(function(p, arr) {
    return some(p, arr);
  });


  /*
   * <apifunction>
   *
   * range
   *
   * Category: array
   *
   * Parameter: a: number
   * Parameter: b: number
   * Returns: array
   *
   * Takes two numbers, a and b. Returns an array containing the arithmetic sequence of elements from a up to but not
   * including b, each element increasing by 1.
   *
   * Throws a TypeError if b < a.
   *
   * Examples:
   *   funkierJS.range(2, 7); // => [2, 3, 4, 5, 6]
   *
   */

  var range = curry(function(a, b) {
    if (b < a)
      throw new TypeError('Incorrect bounds for range');

    var result = [];
    for (var i = a; i < b; i++)
      result.push(i);

    return result;
  });


  /*
   * <apifunction>
   *
   * rangeStride
   *
   * Category: array
   *
   * Synonyms: rangeStep
   *
   * Parameter: a: number
   * Parameter: stride: number
   * Parameter: b: number
   * Returns: array
   *
   * Takes three numbers, a stride and b. Returns an array containing the arithmetic sequence of elements from a up to
   * but not including b, each element increasing by stride.
   *
   * Throws a TypeError if the sequence will not terminate.
   *
   * Examples:
   *   funkierJS.rangeStep(2, 2, 7); // => [2, 4, 6]
   *
   */

  var rangeStride = curry(function(a, stride, b) {
    if ((stride > 0 && b < a) || (stride < 0 && b > a) || (stride === 0 && b !== a))
      throw new TypeError('Incorrect bounds for range');

    if (!isFinite(stride))
      throw new TypeError('stride must be finite');

    var result = [];
    for (var i = a; a < b ? i < b : i > b; i += stride)
      result.push(i);

    return result;
  });


  /*
   * <apifunction>
   *
   * take
   *
   * Category: array
   *
   * Parameter: count: number
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a count, and an array, string or arrayLike. Returns an array or string containing the first count elements
   * of the given arrayLike.
   *
   * Throws a TypeError if the count is not integral, or if the last argument is not an arrayLike.
   *
   * Examples:
   *   funkierJS.take(3, 'banana'); // => 'ban'
   *
   */

  var take = curry(function(count, arr) {
    count = checkIntegral(count, 'Invalid count for take');
    if (count < 0)
      count = 0;

    arr = checkArrayLike(arr);

    var wasString = typeof(arr) === 'string';
    if (wasString)
      arr = arr.split('');

    var result = arr.slice(0, count);
    if (wasString)
      result = result.join('');

    return result;
  });


  /*
   * <apifunction>
   *
   * drop
   *
   * Category: array
   *
   * Parameter: count: number
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a count, and an array, string or arrayLike. Returns an array or string containing the first count elements
   * removed from the given arrayLike.
   *
   * Throws a TypeError if the count is not integral, or if the last argument is not an array or string.
   *
   * Examples:
   *   funkierJS.drop(3, 'banana'); // => 'anana'
   *
   */

  var drop = curry(function(count, arr) {
    count = checkIntegral(count, 'Invalid count for drop');
    if (count < 0)
      count = 0;

    arr = checkArrayLike(arr);

    var wasString = typeof(arr) === 'string';
    if (wasString)
    arr = arr.split('');

    var result = arr.slice(count);
    if (wasString)
      result = result.join('');

    return result;
  });


  /*
   * <apifunction>
   *
   * init
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes an array, string or arrayLike. Returns an array or string containing every element except the last.
   *
   * Throws a TypeError if the arrayLike is empty, or if the given value is not an arrayLike.
   *
   * Examples:
   *   funkierJS.init([2, 3, 4, 5]); // => [2, 3, 4]
   *
   */

  var init = curry(function(arr) {
    if (arr.length === 0)
      throw new TypeError('Cannot take init of empty array/string');

    return take(length(arr) - 1, arr);
  });


  /*
   * <apifunction>
   *
   * tail
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes an array, string or arrayLike. Returns an array or string containing every element except the first.
   *
   * Throws a TypeError if the arrayLike is empty, or if the given value is not an arrayLike.
   *
   * Examples:
   *   funkierJS.tail('banana'); // => 'anana'
   *
   */

  var tail = curry(function(arr) {
    if (arr.length === 0)
      throw new TypeError('Cannot take tail of empty array/string');

    return drop(1, arr);
  });


  /*
   * <apifunction>
   *
   * inits
   *
   * Category: array
   *
   * Synonyms: prefixes
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes an array, string or arrayLike. Returns all the prefixes of the given arrayLike.
   *
   * Throws a TypeError if the given value is not an arrayLike.
   *
   * Examples:
   *   funkierJS.inits([2, 3]); // => [[], [2], [2, 3]]
   *
   */

  var inits = curry(function(arr) {
    arr = checkArrayLike(arr);
    var r = range(0, length(arr) + 1);

    return map(function(v) {return take(v, arr);}, r);
  });


  /*
   * <apifunction>
   *
   * tails
   *
   * Category: array
   *
   * Synonyms: suffixes
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes an array, string or arrayLike. Returns all the suffixes of the given arrayLike.
   *
   * Throws a TypeError if the given value is not an arrayLike.
   *
   * Examples:
   *   funkierJS.tails([2, 3]); // => [[2, 3], [3], []]
   *
   */

  var tails = curry(function(arr) {
    arr = checkArrayLike(arr);
    var r = range(0, length(arr) + 1);

    return map(function(v) {return drop(v, arr);}, r);
  });


  /*
   * <apifunction>
   *
   * copy
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes an arrayLike, and returns a new array which is a shallow copy.
   *
   * Throws a TypeError if the given value is not an arrayLike.
   *
   * Examples:
   *   var a = [1, 2, 3];]
   *   var b = funkierJS.copy(a); // => [1, 2, 3]
   *   b === a; // => false
   *
   */

  var copy = curry(function(arr) {
    arr = checkArrayLike(arr);

    return arr.slice();
  });


  /*
   * <apifunction>
   *
   * slice
   *
   * Category: array
   *
   * Parameter: from: number
   * Parameter: to: number
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes two numbers, from and to, and an array, string or arrayLike. Returns the subarray or string containing the
   * elements between these two points (inclusive at from, exclusive at to). If to is greater than the length of the
   * object, then all values from 'from' will be returned.
   *
   * Throws a TypeError if from or to are not positive integers, or if the last argument is not an arrayLike.
   *
   * Examples:
   *   funkierJS.slice(1, 3, [1, 2, 3, 4, 5]; // => [2, 3]
   *
   */

  var slice = curry(function(from, to, arr) {
    from = checkPositiveIntegral(from, {errorMessage: 'Invalid from position for slice'});
    to = checkPositiveIntegral(to, {errorMessage: 'Invalid to position for slice'});

    return take(to - from, drop(from, arr));
  });


  /*
   * <apifunction>
   *
   * takeWhile
   *
   * Category: array
   *
   * Parameter: pred: function
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a predicate function pred, and source, which should be an array, string or arrayLike. Returns a new array or
   * string containing the initial members of the given arrayLike for which the predicate returned true.
   *
   * Throws a TypeError if pred is not a function of arity 1, or if the source value is not an arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `takeWhile` is `null`, so it cannot supply a useful execution context to any object-curried functions
   * supplied to this function.
   *
   * Examples:
   *   funkierJS.takeWhile(even, [2, 4, 3, 5, 7]; // => [2, 4]
   *
   */

  var takeWhile = curry(function(p, source) {
    p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});

    source = checkArrayLike(source, {message: 'takeWhile: source is not an array/string'});

    var result = [];
    var wasString = typeof(source) === 'string';
    var l = source.length;
    var done = false;

    for (var i = 0; !done && i < l; i++) {
      if (p(source[i]))
        result.push(source[i]);
      else
        done = true;
    }

    if (wasString)
      result = result.join('');
    return result;
  });


  /*
   * <apifunction>
   *
   * dropWhile
   *
   * Category: array
   *
   * Parameter: pred: function
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a predicate function p, and source, an array, string or arrayLike. Returns a new array or string containing
   * the remaining members our source upon removing the initial elements for which the predicate function returned true.
   *
   * Throws a TypeError if p is not a function of arity 1, or if the given value is not an arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `dropWhile` is `null`, so it cannot supply a useful execution context to any object-curried functions
   * supplied to this function.
   *
   * Examples:
   *   funkierJS.dropWhile(even, [2, 4, 3, 5, 7]; // => [3, 5, 7
   *
   */

  var dropWhile = curry(function(p, source) {
    p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});

    source = checkArrayLike(source, {message: 'dropWhile: source is not an array/string'});

    var l = source.length;
    var done = false;

    var i = 0;
    while (i < source.length && p(source[i]))
      i += 1;

    return source.slice(i);
  });


  /*
   * <apifunction>
   *
   * prepend
   *
   * Category: array
   *
   * Parameter: value: any
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a value, and an array, string or arrayLike, and returns a new array or string with the given value prepended.
   *
   * Throws a TypeError if the second argument is not an arrayLike.
   *
   * Note: if the second argument is a string and the first is not, the value will be coerced to a string; you may not
   * get the result you expect.
   *
   * Examples:
   *   var a = [1, 2, 3];
   *   funkierJS.prepend(4, a); // => [4, 1, 2, 3]
   *   a; // => [1, 2, 3] (a is not changed)
   *
   */

  var prepend = curry(function(v, arr) {
    arr = checkArrayLike(arr);

    if (Array.isArray(arr))
      return [v].concat(arr);

    return '' + v + arr;
  });


  /*
   * <apifunction>
   *
   * append
   *
   * Category: array
   *
   * Parameter: value: any
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a value, and an array, string or arrayLike, and returns a new array or string with the given value appended.
   *
   * Throws a TypeError if the second argument is not an arrayLike.
   *
   * Note: if the second argument is a string and the first is not, the value will be coerced to a string; you may not
   * get the result you expect.
   *
   * Examples:
   *   var a = [1, 2, 3];
   *   funkierJS.append(4, a); // => [1, 2, 3, 4]
   *   a; // => [1, 2, 3] (a is not changed)
   *
   */

  var append = curry(function(v, arr) {
    arr = checkArrayLike(arr);

    if (Array.isArray(arr))
      return arr.concat([v]);

    return '' + arr + v;
  });


  /*
   * <apifunction>
   *
   * concat
   *
   * Category: array
   *
   * Parameter: arr1: arrayLike
   * Parameter: arr2: arrayLike
   * Returns: arrayLike
   *
   * Takes two arrays, arrayLikes or strings, and returns their concatenation.
   *
   * Throws a TypeError if either argument is not an arrayLike.
   *
   * If both arguments are the same type and are either arrays or strings, then the result will be the same type,
   * otherwise it will be an array.
   *
   * Examples:
   *   funkierJS.concat([1, 2], [3, 4, 5]); // => [1, 2, 3, 4, 5]
   *   funkierJS.concat('abc', 'def'); // => 'abcdef'
   *   funkierJS.concat('abc', [1, 2, 3]); // => ['a', 'b', 'c', 1, 2, 3]
   *
   */

  var concat = curry(function(left, right) {
    left = checkArrayLike(left, {message: 'concat: First value is not arrayLike'});
    right = checkArrayLike(right, {message: 'concat: Second value is not arrayLike'});

    if (typeof(left) !== typeof(right)) {
      if (Array.isArray(left))
        right = right.split('');
      else
        left = left.split('');
    }

    return left.concat(right);
  });


  /*
   * <apifunction>
   *
   * isEmpty
   *
   * Category: array
   *
   * Parameter: arr: arraLike
   * Returns: boolean
   *
   * Returns true if the given array, arrayLike or string is empty, and false if not.
   *
   * Throws a TypeError if the argument is not arrayLike.
   *
   * Examples:
   *   funkierJS.isEmpty([]); // => true
   *
   */

  var isEmpty = curry(function(val) {
    val = checkArrayLike(val);

    return val.length === 0;
  });


  /*
   *
   * <apifunction>
   *
   * intersperse
   *
   * Category: array
   *
   * Parameter: val: any
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a value, and an array, string or arrayLike, and returns a new array or string with the value in between each
   * pair of elements of the original.
   *
   * Note: if the second parameter is a string, the first parameter will be coerced to a string.
   *
   * Throws a TypeError if the second argument is not arrayLike.
   *
   * Examples:
   *   funkierJS.intersperse(1, [2, 3, 4]); // => [2, 1, 3, 1, 4]
   *
   */

  var intersperse = curry(function(val, arr) {
    arr = checkArrayLike(arr, {message: 'intersperse: Cannot operate on non-arrayLike value'});

    var wasString = false;
    if (typeof(arr) === 'string') {
      wasString = true;
      val = '' + val;
    }

    var result = wasString ? '' : [];
    if (arr.length > 0)
      result = result.concat(wasString ? arr[0] : [arr[0]]);
    for (var i = 1, l = arr.length; i < l; i++)
      result = result.concat(wasString ? val + arr[i] : [val, arr[i]]);

    return result;
  });


  /*
   *
   * <apifunction>
   *
   * reverse
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes an array, string or arrayLike, and returns a new array or string that is the reverse of the original.
   *
   * Throws a TypeError if the argument is not arrayLike.
   *
   * Examples:
   *   funkierJS.reverse('banana'); 'ananab'
   *
   */

  var reverseFn = function(soFar, current) {
    return soFar.concat(Array.isArray(soFar) ? [current] : current);
  };

  var reverse = curry(function(arr) {
    arr = checkArrayLike(arr);

    return foldr(reverseFn, Array.isArray(arr) ? [] : '', arr);
  });


  /*
   * The search and replace functions are not yet ready, and are under API review.

  var find = defineValue(
   *
   * find
   *
   * Category: array
   *
   * Parameter: val: any
   * Parameter: arr: arrayLike
   * Returns: number
   *
   * Takes a value, and an array, string or arrayLike. Searches for the valuetested for strict equalityand returns the
   * index of the first match, or -1 if the value is not present.
   *
   * Throws a TypeError if the second parameter is not arrayLike.
   *
   * Examples:
   *   funkierJS.find(2, [1, 2, 3]); // => 1
   *
  var find = callPropWithArity('indexOf', 1);


  //var findFrom = defineValue(
   *
   * findFrom
   *
   * Category: array
    *
   * signature: value: any, index: number, arr: arrayLike
   * classification: array
   *
   * Takes a value, an index, and an array, string or arrayLike. Searches for the
   * valuetested for strict equalitystarting the search at the given index, and
   * returns the index of the first match, or -1 if the value is not present.
   *
   * Throws a TypeError if the last parameter is not arrayLike.
   *
   * Examples:
   *
   * funkierJS.findFrom(2, 2, [1, 2, 3]); -1
   *
    curry(function(val, from, arr) {
      arr = checkArrayLike(arr);
      from = checkPositiveIntegral(from, {message: 'Index must be a positive integer'});

      return arr.indexOf(val, from);
    })
  );


  var findWith = defineValue(
   *
   * findWith
   *
   * Category: array
    *
   * signature: pred: function, haystack: arrayLike
   * classification: array
   *
   * Takes a predicate function pred of arity 1, and haystack, an array, arrayLike
   * or string. Searches for the valuetested by the given functionand returns the
   * index of the first match, or -1 if the value is not present.
   *
   * Throws a TypeError if the first parameter is not a predicate function of arity 1,
   * or if the haystack parameter is not arrayLike.
   *
   * Examples:
   *
   * var pred = function(e) {return e.foo === 42;};
   * var arr = [{foo: 1}, {foo: 2}, {foo: 42}, {foo: 3}];
   * funkierJS.findWith(pred, arr); // 2
   *
    curry(function(p, haystack) {
      haystack = checkArrayLike(haystack, {message: 'Haystack must be an array/string'});
      p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});

      var found = false;
      for (var i = 0, l = haystack.length; !found && i < l; i++)
        found = p(haystack[i]);

      return found ? i - 1 : -1;
    })
  );


  var findFromWith = defineValue(
   *
   * findFromWith
   *
   * Category: array
    *
   * signature: pred: function, index: number, haystack: arrayLike
   * classification: array
   *
   *
   * Examples:
   *
   * Takes a predicate function pred of arity 1, and haystack, an array, arrayLike
   * or string. Searches for the valuetested by the given functionfrom the given
   * index, and returns the index of the first match, or -1 if the value is not
   * present.
   *
   * Throws a TypeError if the first parameter is not a predicate function of arity
   * 1, or the haystack parameter is not arrayLike.
   *
   * Examples:
   *
   * var pred = function(e) {return e.foo === 42;};
   * var arr = [{foo: 1}, {foo: 2}, {foo: 42}, {foo: 3}];
   * funkierJS.findFromWith(pred, 3, arr); // -1
   *
    curry(function(p, index, haystack) {
      haystack = checkArrayLike(haystack, {message: 'Haystack must be an array/string'});
      index = checkPositiveIntegral(index, {message: 'Index must be a non-negative integer'});
      p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});

      var found = false;
      for (var i = index, l = haystack.length; !found && i < l; i++)
        found = p(haystack[i]);

      return found ? i - 1 : -1;
    })
  );
*/


  /*
   * <apifunction>
   *
   * occurrences
   *
   * Category: array
   *
   * Parameter: needle: any,
   * Parameter: haystack: arrayLike
   * Returns: array
   *
   * Takes a valueneedleand haystack, an array, arrayLike or string. Searches for all occurrences of the valuetested
   * for strict equalityand returns an array containing all the indices into haystack where the values may be found.
   *
   * Throws a TypeError if the haystack parameter is not arrayLike.
   *
   * Examples:
   *   funkierJS.occurrences(2, [1, 2, 2, 3, 2, 4]; // => [1, 2, 4]
   *
   */

  var occurrences = curry(function(val, haystack) {
    haystack = checkArrayLike(haystack, {message: 'occurrences: haystack must be an array/string'});

    var result = [];
    for (var i = 0, l = haystack.length; i < l; i++)
      if (haystack[i] === val)
        result.push(i);

    return result;
  });


  /*
   * <apifunction>
   *
   * occurrencesWith
   *
   * Category: array
   *
   * Parameter: needle: any,
   * Parameter: haystack: arrayLike
   * Returns: array
   *
   * Takes a predicate function pred, and haystack, an array, arrayLike or string. Searches for all occurrences of the
   * valuetested by the given predicateand returns an array containing all the indices into haystack where the
   * predicate holds.
   *
   * Throws a TypeError if pred is not a predicate function of arity 1, or if the haystack parameter is not arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `occurrences` is `null`, so it cannot supply a useful execution context to any object-curried functions
   * supplied to this function.
   *
   * Examples:
   *   var pred = function(e) {return e.foo === 42;};
   *   var arr = [{foo: 1}, {foo: 42}, {foo: 42}, {foo: 3}];
   *   funkierJS.occurrencesWith(pred, arr); // => [1, 2]
   *
   */

  var occurrencesWith = curry(function(p, haystack) {
    haystack = checkArrayLike(haystack, {message: 'occurrencesWith: haystack must be an array/string'});
    p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});

    var result = [];
    for (var i = 0, l = haystack.length; i < l; i++)
      if (p(haystack[i]))
        result.push(i);

    return result;
  });


  /*
   * <apifunction>
   *
   * zipWith
   *
   * Category: array
   *
   * Parameter: f: function
   * Parameter: a: arrayLike
   * Parameter: b: arrayLike
   * Returns array
   *
   * Takes a function of arity 2, and a two arrays/arrayLikes/strings, a and b, and returns a new array. The new array
   * has the same length as the smaller of the two arguments. Each element is the result of calling the supplied
   * function with the elements at the corresponding position in the original arrayLikes.
   *
   * Throws a TypeError if the first argument is not an argument of arity at least 2, or if neither of the last two
   * arguments is arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `zipWith` is `null`, so it cannot supply a useful execution context to any object-curried functions
   * supplied to this function.
   *
   * Examples:
   *   var f = function(a, b) {return a + b;};
   *   funkierJS.zipWith(f, 'apple', 'banana'); // => ['ab', 'pa', 'pn', 'la', 'en']
   *
   */

  var zipWith = curry(function(f, a, b) {
    a = checkArrayLike(a, {message: 'First source value is not an array/string'});
    b = checkArrayLike(b, {message: 'Second source value is not an array/string'});

    f = checkFunction(f, {arity: 2, minimum: true, message: 'Constructor must be a function with arity at least 2'});

    var len = Math.min(a.length, b.length);

    var result = [];
    for (var i = 0; i < len; i++)
      result.push(f(a[i], b[i]));

    return result;
  });


  /*
   * <apifunction>
   *
   * zip
   *
   * Category: array
   *
   * Parameter: a: arrayLike
   * Parameter: b: arrayLike
   * Returns: array
   *
   * Takes two arrayLikes, a and b, and returns a new array. The new array has the same length as the smaller of the two
   * arguments. Each element is a [`Pair`](#Pair) p, such that `fst(p) === a[i]` and `snd(p) === b[i]` for each position
   * i in the result.
   *
   * Throws a TypeError if neither argument is arrayLike.
   *
   * Examples:
   *   funkierJS.zip([1, 2], [3, 4]); // => [Pair(1, 3), Pair(2, 4)]
   *
   */

  var zip = zipWith(Pair);


  /*
   *
   * <apifunction>
   *
   * unzip
   *
   * Category: array
   *
   * Parameter: source: array
   * Returns: Pair
   *
   * Takes an array of Pairs, and returns a [`Pair`](#Pair). The first element is an array containing the first element from each
   * pair, and likewise the second element is an array containing the second elements.
   *
   * Throws a TypeError if the given argument is not an array, or if any element is not a Pair.
   *
   * Examples:
   *   funkierJS.unzip([Pair(1, 2), Pair(3, 4)]); // =>  Pair([1, 3], [2, 4])
   *
   */

  var unzip = curry(function(source) {
    source = checkArrayLike(source, {noStrings: true, message: 'Source value is not an array'});

    return Pair(map(fst, source), map(snd, source));
  });


  /*
   * <apifunction>
   *
   * nub
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Synonyms: uniq
   *
   * Takes an array, string or arrayLike. Returns a new array/string, with all duplicate elementstested for strict
   * equalityremoved. The order of elements is preserved.
   *
   * Throws a TypeError if the given argument is not arrayLike.
   *
   * Examples:
   *   funkierJS.nub('banana'); // 'ban'
   *
   */

  var nubFn = function(soFar, current) {
    return soFar.indexOf(current) !== -1 ? soFar :
           soFar.concat(Array.isArray(soFar) ? [current] : current);
  };

  var nub = curry(function(arr) {
    arr = checkArrayLike(arr);

    return foldl(nubFn, Array.isArray(arr) ? [] : '', arr);
  });


  /*
   * <apifunction>
   *
   * nubWith
   *
   * Category: array
   *
   * Synonyms: uniqWith
   *
   * Parameter: pred: function
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a predicate function of arity 2, and an array, string or arrayLike. Returns a new array/string, with all
   * duplicate elements removed. A duplicate is defined as a value for which the predicate function returned true when
   * called with a previously encountered element and the element under consideration. The order of elements is
   * preserved.
   *
   * Throws a TypeError if the first argument is not a function, or has an arity other than 2, or if the last argument
   * is not arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `nubWith` is `null`, so it cannot supply a useful execution context to any object-curried functions supplied
   * to this function.
   *
   * Examples:
   *   var pred = function(x, y) { return x.foo === y.foo; };
   *   funkierJS.nubWith(pred, [{foo: 12}, {foo: 42}, {foo: 42}, {foo: 12}]);
   *   // => [{foo: 12}, {foo: 42}]
   *
   */

  var nubWithFn = curry(function(p, soFar, current) {
    var isDuplicate = some(base.flip(p)(current), soFar);

    return isDuplicate ? soFar :
           soFar.concat(Array.isArray(soFar) ? [current] : current);
  });

  var nubWith = curry(function(p, arr) {
    arr = checkArrayLike(arr);
    p = checkFunction(p, {arity: 2, message: 'Predicate must be a function of arity 2'});

    var fn = nubWithFn(p);
    return foldl(fn, Array.isArray(arr) ? [] : '', arr);
  });


  /*
   * <apifunction>
   *
   * sort
   *
   * Category: array
   *
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes an array, string or arrayLike, and returns a new array, sorted in lexicographical order.
   *
   * Throws a TypeError if the given argument is not arrayLike.
   *
   * Examples:
   *   funkierJS.sort([10, 1, 21, 2]); // => [1, 10, 2, 21]
   *
   */

  var sort = curry(function(arr) {
    arr = checkArrayLike(arr);
    arr = arr.slice();

    var wasString = false;
    if (typeof(arr) === 'string') {
      wasString = true;
      arr = arr.split('');
    }

    arr.sort();
    if (wasString)
      arr = arr.join('');

    return arr;
  });


  /*
   * <apifunction>
   *
   * sortWith
   *
   * Category: array
   *
   * Parameter: f: function
   * Parameter: arr: arrayLike
   * Returns: arrayLike
   *
   * Takes a function of two arguments, and an array, string or arrayLike. Returns a new array/string, sorted per the
   * given function. The function should return a negative number if the first argument is "less than" the second, 0 if
   * the two arguments are "equal", and a positive number if the first argument is greater than the second.
   *
   * Throws a TypeError if the first argument is not a function of arity 2, or if the second is not arrayLike.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `sortWith` is `null`, so it cannot supply a useful execution context to any object-curried functions
   * supplied to this function.
   *
   * Examples:
   *   var sortFn = function(x, y) {return x - y;};
   *   funkierJS.sortWith(sortFn, [10, 1, 21, 2]); // => [1, 2, 10, 21]
   *
   */

  var sortWith = makeArrayPropCaller(2, Array.prototype.sort, {fixedArity: 2, returnSameType: true});


  /*
   * The modification functions are not yet ready, and are under API review.
   *
   *
  // XXX Argument order consistency with other funcs that take val and index?
  //var insert = defineValue(
   *
   *
   * insert
   *
   * Category: array
    *
   * signature: index: number, value: any, arr: arrayLike
   * classification: array
   *
   * Takes an index, a value, and an array, string or arrayLike. Returns a new
   * array/string with the value inserted at the given index, and later elements
   * shuffled one place to the right. The index argument should be a number between
   * 0 and the length of the given array/string; a value equal to the length will
   * insert the new value at the end of the array/string. If passed a string, the
   * value will be coerced to a string if necessary.
   *
   * Throws a TypeError if the index is out of bounds, or otherwise invalid, or if
   * the last argument is not arrayLike.
   *
   * Examples:
   *
   * var a = [1, 2, 3];
   * funkierJS.insert(1, 10, a); // Returns [1, 10, 2, 3]; a is unchanged
   *
    curry(function(index, val, arr) {
      arr = checkArrayLike(arr, {message: 'insert: Recipient is not arrayLike'});
      index = checkPositiveIntegral(index, 'Index out of bounds');
      if (index > arr.length)
        throw new TypeError('Index out of bounds');

      if (Array.isArray(arr))
        return arr.slice(0, index).concat([val]).concat(arr.slice(index));

      return arr.slice(0, index) + val + arr.slice(index);
    })
  );


  // XXX Argument order consistency with other funcs that take val and index?
  var remove = defineValue(
   *
   * remove
   *
   * Category: array
    *
   * signature: index: number, value: any, arr: arrayLike
   * classification: array
   *
   * Takes an index, and an array, string or arrayLike. Returns a new array/string
   * with the value at the given index removed, and later elements shuffled one place
   * to the left. The index argument should be a number between 0 and one less than
   * the length of the given array/string.
   *
   * Throws a TypeError if the index is out of bounds, or otherwise invalid, or if
   * the last argument is not arrayLike.
   *
   * Examples:
   *
   * var a = [1, 10, 2];
   * funkierJS.remove(1, a); // Returns [1, 2]; a is unchanged
   *
    curry(function(index, arr) {
      arr = checkArrayLike(arr, {message: 'remove: Value to be modified is not arrayLike'});
      index = checkPositiveIntegral(index, 'Index out of bounds');
      if (index >= arr.length)
        throw new TypeError('Index out of bounds');


      return arr.slice(0, index).concat(arr.slice(index + 1));
    })
  );


  // XXX Argument order consistency with other funcs that take val and index?
  // XXX Also, need to look over this wrt strings
  var replace = defineValue(
   *
   * replace
   *
   * Category: array
    *
   * signature: index: number, value: any, arr: arrayLike
   * classification: array
   *
   * Takes an index, a value, and an array, string or arrayLike. Returns a new
   * array/string with the value replacing the value at the given index. The index
   * argument should be a number between 0 and one less than the length of the given
   *  array/string. If passed a string, the value will be coerced to a string if
   * necessary.
   *
   * Throws a TypeError if the index is out of bounds, or otherwise invalid, or if
   * the last argument is not arrayLike.
   *
   * Examples:
   *
   * var a = [1, 10, 3];
   * funkierJS.replace(1, 2, a); // Returns [1, 2, 3]; a is unchanged
   *
    curry(function(index, val, arr) {
      arr = checkArrayLike(arr, {message: 'replace: Value to be modified is not arrayLike'});
      index = checkPositiveIntegral(index, 'Index out of bounds');
      if (index >= arr.length)
        throw new TypeError('Index out of bounds');

      arr = arr.slice();

      if (Array.isArray(arr)) {
        arr[index] = val;
        return arr;
      }

      val = val.toString();
      return arr.slice(0, index) + val + arr.slice(index + 1);
    })
  );


  // XXX Also, need to look over this wrt strings
  var removeOneWith = defineValue(
   *
   * removeOneWith
   *
   * Category: array
    *
   * signature: pred: function, arr: arrayLike
   * classification: array
   *
   * Takes a predicate function of arity 1, and an array. Returns a new array with the
   * first value for which the function returns true removed from the array.
   *
   * Throws a TypeError if the given predicate is not a function, or does not have
   * arity 1, or if the last parameter is not an array.
   *
   * Examples:
   *
   * var pred = function(x) {return x.foo === 42;};
   * funkierJS.removeOne(pred, [{foo: 1}, {foo: 42}, {foo: 3}]); // Returns [{foo: 1}, {foo: 3}]
   *
    curry(function(p, arr) {
      p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});
      arr = checkArrayLike(arr, {message:   * Value to be modified is not an array noStrings: true});

      var found = false;
      var i = 0;
      while (!found && i < arr.length) {
        if (p(arr[i])) {
          found = true;
        } else {
          i++;
        }
      }

      if (!found)
        return arr.slice();

      return arr.slice(0, i).concat(arr.slice(i + 1));
    })
  );


  var removeOne = defineValue(
   *
   * removeOne
   *
   * Category: array
    *
   * signature: value: any, arr: arrayLike
   * classification: array
   *
   * Takes a value, and an array. Returns a new array with the first occurrence of the
   *  valuechecked for strict equality removed from the array.
   *
   * Throws a TypeError if the last argument is not an array.
   *
   * Examples:
   *
   * funkierJS.removeOne(2, [1, 2, 2, 3]); // Returns [1, 2, 3]
   *
    compose(removeOneWith, strictEquals)
  );


  var removeAll = defineValue(
   *
   * removeAll
   *
   * Category: array
    *
   * signature: value: any, arr: arrayLike
   * classification: array
   *
   * Takes a value, and an array. Returns a new array with all occurrences of the
   * given valuechecked for strict equalityremoved from the array.
   *
   * Throws a TypeError if the last argument is not an array.
   *
   * Examples:
   *
   * funkierJS.removeAll(2, [1, 2, 2, 3]); // Returns [1, 3]
   *
    curry(function(val, arr) {
      arr = checkArrayLike(arr, {noStrings: true});

      var pred = notPred(strictEquals(val));
      return filter(pred, arr);
    })
  );


  var removeAllWith = defineValue(
   *
   * removeAllWith
   *
   * Category: array
    *
   * signature: pred: function, arr: arrayLike
   * classification: array
   *
   * Takes a predicate function of arity 1, and an array. Returns a new array with
   * values for which the function returns true removed from the array.
   *
   * Throws a TypeError if the first argument is not a predicate function of arity 1,
   * or if the last parameter is not an array.
   *
   * Examples:
   *
   * var pred = function(x) {return x.foo === 42;};
   * funkierJS.removeAllWith(pred [{foo: 42}, {foo: 12}, {foo: 1}, {foo: 42}]);
   * // returns [{foo: 12}, {foo: 1}]
   *
    curry(function(pred, arr) {
      arr = checkArrayLike(arr, {noStrings: true});

      pred = notPred(pred);
      return filter(pred, arr);
    })
  );


  var replaceOneWith = defineValue(
   *
   * replaceOneWith
   *
   * Category: array
    *
   * signature: pred: function, value: any, arr: array
   * classification: array
   *
   * Takes a predicate function of arity 1, a replacement value, and an array.
   * Returns a new array where the first value for which the given predicate returned
   * true has been replaced with the given replacement.
   *
   * Throws a TypeError if the first argument is not a function, if the function does
   * not have arity 1, or if the last parameter is not an array.
   *
   * Examples:
   *
   * var pred = function(x) {return x.foo === 42;};
   * funkierJS.replaceOneWith(pred {bar: 10}, [{foo: 42}, {foo: 12}, {foo: 1}, {foo: 42}]);
   * // returns [{bar: 10}, {foo: 12}, {foo: 1}, {foo: 42}]
   *
    curry(function(p, replacement, arr) {
      p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});
      arr = checkArrayLike(arr, {message:   * Value to be modified is not arrayLike noStrings: true});
      replacement = [replacement];

      var found = false;
      var i = 0;
      while (!found && i < arr.length) {
        if (p(arr[i]))
          found = true;
        else
        i++;
      }

      if (!found)
        return arr.slice();

      return arr.slice(0, i).concat(replacement).concat(arr.slice(i + 1));
    })
  );


  var replaceOne = defineValue(
   *
   * replaceOne
   *
   * Category: array
    *
   * signature: value: any, newValue: any, arr: arrayLike
   * classification: array
   *
   * Takes a value, a replacement value, and an array. Returns a new array where the
   * first occurrence of the given valuechecked for strict equalityis replaced with
   * the given replacement.
   *
   * Throws a TypeError if the last parameter is not an array.
   *
   * Examples:
   *
   * funkierJS.replaceOne(2, 42, [1, 2, 3]); // [1, 42, 3]
   *
    curry(function(val, replacement, arr) {
      return replaceOneWith(base.strictEquals(val), replacement, arr);
    })
  );


  var replaceAllWith = defineValue(
   *
   * replaceAllWith
   *
   * Category: array
    *
   * signature: pred: function, newValue: any, arr: array
   * classification: array
   *
   * Takes a predicate function of arity 1, a replacement value, and an array.
   * Returns a new array/string where all values for which the predicate returned true
   * have been replaced with the given replacement.
   * Throws a TypeError if the first parameter is not a function of arity 1, or if the
   * last parameter is not an array.
   *
   * Examples:
   *
   * var pred = function(x) {return x.foo === 42;};
   * funkierJS.replaceAllWith(pred {bar: 10}, [{foo: 42}, {foo: 12}, {foo: 1}, {foo: 42}]);
   * // returns [{bar: 10}, {foo: 12}, {foo: 1}, {bar: 10}]
   *
    curry(function(p, replacement, arr) {
      p = checkFunction(p, {arity: 1, message: 'Predicate must be a function of arity 1'});
      arr = checkArrayLike(arr, {message:   * Value to be modified is not an array noStrings: true});
      replacement = [replacement];

      var result = arr.slice();
      var i = 0;

      while (i < arr.length) {
        if (!p(result[i])) {
          i += 1;
          continue;
        }

        result = result.slice(0, i).concat(replacement).concat(result.slice(i + 1));
        i += 1;
      }

      return result;
    })
  );


  var replaceAll = defineValue(
   *
   * replaceAll
   *
   * Category: array
    *
   * signature: value: any, newValue: any, arr: array
   * classification: array
   *
   * Takes a value, a replacement value, and an array. Returns a new array where all
   * occurrences of the given valuechecked for strict equalityhave been replaced
   * with the given replacement.
   *
   * Throws a TypeError if the last parameter is not an array.
   *
   * Examples:
   *
   *
    curry(function(val, replacement, arr) {
      return replaceAllWith(strictEquals(val), replacement, arr);
    })
  );
*/


  /*
   * <apifunction>
   *
   * join
   *
   * Category: array
   *
   * Parameter: separator: any
   * Parameter: arr: array
   * Returns: string
   *
   * Takes a separator value that can be coerced to a string, and an array. Returns a string, containing the toString
   * of each element in the array, separated by the toString of the given separator.
   *
   * Throws a TypeError if the last element is not an array.
   *
   * Examples:
   *   funkierJS.join('-', [1, 2, 3]); // => '1-2-3'
   *
   */

  var join = curry(function(sep, arr) {
    arr = checkArrayLike(arr, {noStrings: true, message: 'join: Value to be joined is not an array'});

    return arr.join(sep);
  });


  /*
   * <apifunction>
   *
   * flatten
   *
   * Category: array
   *
   * Parameter: arr: array
   * Returns: array
   *
   * Takes an array containing arrays or strings. Returns an array containing the concatenation of those arrays/strings.
   * Note that flatten only strips off one layer.
   *
   * Throws a TypeError if the supplied value is not arrayLike, or if any of the values within it are not arrayLike.
   *
   * Examples:
   *   funkierJS.flatten([[1, 2], [3, 4]]); // => [1, 2, 3, 4]
   *
   */

  var flattenFn = function(soFar, current) {
    current = checkArrayLike(current);

    return concat(soFar, current);
  };

  var flatten = curry(function(arr) {
    arr = checkArrayLike(arr, {noStrings: true, message: 'Value to be flattened is not an array'});

    return foldl(flattenFn, [], arr);
  });


  /*
   * <apifunction>
   *
   * flattenMap
   *
   * Category: array
   *
   * Parameter: f: function
   * Parameter: arr: arrayLike
   * Returns: array
   *
   * Takes a function of arity 1, and an array, string or arrayLike. Maps the function over the array/string and
   * flattens the result. The supplied function must be of arity 1, as it is expected to return an array or string; a
   * TypeError is thrown if this is not the case.
   *
   * A TypeError will also be thrown if the last argument is not arrayLike, or if the first argument is not a function.
   *
   * Note that, if required, the function must already have its execution context set. Internally, the execution context
   * within `flattenWith` is `null`, so it cannot supply a useful execution context to any object-curried functions
   * supplied to this function.
   *
   * Examples:
   *   var fn = function(n) {return [n, n * n];};
   *   funkierJS.flattenMap(fn, [1, 2, 3]); // => Returns [1, 1, 2, 4, 3, 9]
   *
   */

  var flattenMap = curry(function(f, arr) {
    return flatten(map(f, arr));
  });


  return {
    all: every,
    any: some,
    append: append,
    concat: concat,
    copy: copy,
    drop: drop,
    dropWhile: dropWhile,
    each: each,
    element: element,
    elementWith: elementWith,
    every: every,
    filter: filter,
/*
    find: find,
    findFrom: findFrom,
    findFromWith: findFromWith,
    findWith: findWith,
*/
    flatten: flatten,
    flattenMap: flattenMap,
    foldl: foldl,
    foldl1: foldl1,
    foldr: foldr,
    foldr1: foldr1,
    getIndex: getIndex,
    head: head,
    init: init,
    inits: inits,
 //   insert: insert,
    intersperse: intersperse,
    isEmpty: isEmpty,
    join: join,
    last: last,
    length: length,
    map: map,
    maximum: maximum,
    minimum: minimum,
    nub: nub,
    nubWith: nubWith,
    occurrences: occurrences,
    occurrencesWith: occurrencesWith,
    prefixes: inits,
    prepend: prepend,
    product: product,
    range: range,
    rangeStep: rangeStride,
    rangeStride: rangeStride,
    reduce: foldl,
    reduce1: foldl1,
    reduceRight: foldr,
    reduceRight1: foldr1,
/*
    remove: remove,
    removeAll: removeAll,
    removeAllWith: removeAllWith,
    removeOne: removeOne,
    removeOneWith: removeOneWith,
    replace: replace,
    replaceAll: replaceAll,
    replaceAllWith: replaceAllWith,
    replaceOne: replaceOne,
    replaceOneWith: replaceOneWith,
*/
    replicate: replicate,
    reverse: reverse,
    slice: slice,
    some: some,
    sort: sort,
    sortWith: sortWith,
    suffixes: tails,
    sum: sum,
    tail: tail,
    tails: tails,
    take: take,
    takeWhile: takeWhile,
    uniq: nub,
    uniqWith: nubWith,
    unzip: unzip,
    zip: zip,
    zipWith: zipWith
  };
})();

},{"../funcUtils":24,"../internalUtilities":27,"./base":11,"./curry":13,"./logical":16,"./object":19,"./pair":20,"./types":23}],11:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;
  var arityOf = curryModule.arityOf;
  var chooseCurryStyle = curryModule._chooseCurryStyle;
  var curryWithConsistentStyle = curryModule._curryWithConsistentStyle;

  var funcUtils = require('../funcUtils');
  var checkFunction = funcUtils.checkFunction;

  var internalUtilities = require('../internalUtilities');
  var checkPositiveIntegral = internalUtilities.checkPositiveIntegral;
  var isArrayLike = internalUtilities.isArrayLike;


  /*
   * <apifunction>
   *
   * compose
   *
   * Category: function
   *
   * Parameter: f: function
   * Parameter: g: function
   * Returns: function
   *
   * Composes the two functions, returning a new function that consumes one argument, which is passed to `g`. The result
   * of that call is then passed to `f`. That result is then returned. Throws if either parameter is not a function, or
   * has arity 0.
   *
   * The functions will be curried (using the standard [`curry`](#curry) if required. The resulting function will have
   * real arity of `arityOf(f)`. Note in particular, that if `g` has arity 1, it will be partially applied with 1
   * argument: `f` will recieve a partially applied `g`, and any remaining arguments.
   *
   * If `g` was curried by one of the [`objectCurry`] variants, then the returned function will be too, and it will
   * supply `g` with the context the first time it is invoked. If `g` was curried by [`bind`], then the returned
   * function will also be considered as having been curried that way, with the correct bound context.
   *
   * Examples:
   *
   * var f1 = function(a) {return a + 1;};
   * var f2 = function(b) {return b * 2;};
   * var f = funkierJS.compose(f1, f2); // => f(x) = 2(x + 1)',
   *
   */

  var compose = curry(function(f, g) {
    var gLen = arityOf(g);
    var fLen = arityOf(f);

    f = checkFunction(f, {arity: 1, minimum: true, message: 'function f must have arity  1'});
    g = checkFunction(g, {arity: 1, minimum: true, message: 'function g must have arity  1'});
    f = arityOf._isCurried(f) ? f : curry(f);
    g = arityOf._isCurried(g) ? g : curry(g);

    var curryTo = fLen;

    return chooseCurryStyle(f, g, function(x) {
      var args = [].slice.call(arguments);

      var gArgs = [args[0]];
      var fArgs = args.slice(1);
      return f.apply(this, [g.apply(this, [args[0]])].concat(fArgs));
    }, curryTo);
  });


  /*
   * <apifunction>
   *
   * composeOn
   *
   * Category: function
   *
   * Parameter: argCount: positive
   * Parameter: f: function
   * Parameter: g: function
   * Returns: function
   *
   * Composes the two functions, returning a new function that consumes the specified number of arguments, which are
   * then passed to `g`. The result of that call is then passed to `f`. That result is then returned. Throws if the
   * first parameter is not an integer greater than zero, if either parameter is not a function, or if either parameter
   * has arity 0.
   *
   * The functions will be curried (using the standard [`curry`](#curry) if required. The resulting function will have
   * real arity of `arityOf(f)`. Note in particular, that if `g` has arity 1, it will be partially applied with 1
   * argument: `f` will recieve a partially applied `g`, and any remaining arguments.
   *
   * If `g` was curried by one of the [`objectCurry`] variants, then the returned function will be too, and it will
   * supply `g` with the context the first time it is invoked. If `g` was curried by [`bind`], then the returned
   * function will also be considered as having been curried that way, with the correct bound context.
   *
   * This function is intended to afford an approximation of writing functions in a point-free style.
   *
   * Examples:
   *   var f1 = function(a) {return a(2);};
   *   var f2 = function(c, d, e) {return c * d * e;};
   *   var f = funkierJS.composeOn(f1, f2); // => f(x, y) = 2(x * y);
   *
   */

  var composeOn = curry(function(argCount, f, g) {
    argCount = checkPositiveIntegral(argCount, {errorMessage: 'argCount must be non-negative'});
    f = checkFunction(f, {arity: 1, minimum: true, message: 'function f must have arity  1'});
    g = checkFunction(g, {arity: argCount, minimum: true, message: 'function g must have arity  ' + argCount});
    f = arityOf._isCurried(f) ? f : curry(f);
    g = arityOf._isCurried(g) ? g : curry(g);

    var fLen = arityOf(f);

    var curryArity = fLen - 1 + argCount;

    return chooseCurryStyle(f, g, function() {
      var args = [].slice.call(arguments);

      var gArgs = args.slice(0, argCount);
      var fArgs = args.slice(argCount);
      return f.apply(this, [g.apply(this, gArgs)].concat(fArgs));
    }, curryArity);
  });


  /*
   * <apifunction>
   *
   * id
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: any
   *
   * Returns the supplied value. Superfluous values are ignored.
   *
   * Examples:
   *   funkierJS.id([1, 2]); // => [1, 2]
   *
   */

  var id = curry(function(x) {
    return x;
  });


  /*
   * <apifunction>
   *
   * constant
   *
   * Category: function
   *
   * Parameter: a: any
   * Parameter: b: any
   * Returns: any
   *
   * Intended to be partially applied, first taking a value, returning a function that takes another parameter
   * and which always returns the first value.
   *
   * Examples:
   *   var f = funkierJS.constant(42);
   *   f(10); // => 42
   *
   */

  var constant = curry(function(x, y) {
    return x;
  });


  /*
   * <apifunction>
   *
   * constant0
   *
   * Category: function
   *
   * Parameter: a: any
   * Returns: function
   *
   * Returns a function of arity zero that when called always returns the supplied value.
   *
   * Examples:
   *   var f = funkierJS.constant0(42);
   *   f(); // => 42
   *
   */

  var constant0 = compose(curryWithArity(0), constant);


  /*
   * <apifunction>
   *
   * flip
   *
   * Category: function
   *
   * Parameter: f: function
   * Returns: function
   *
   * Takes a binary function f, and returns a curried function that takes the arguments in the opposite order.
   *
   * Note that the returned function will be curried in the extant style, or using [`curry`](#curry) if the function
   * is not curried. Thus, if you wish to flip a object-curried function on the object prototype, you must object-curry
   * before flipping; in the other order, the function will be curried in the standard manner, preventing later object
   * currying.
   *
   * Examples:
   *   var backwards = funkierJS.flip(funkierJS.subtract);
   *   backwards(2, 3); // => 1
   *
   */

  var flip = curry(function(f) {
    f = checkFunction(f, {arity: 2, maximum: true, message: 'Value to be flipped must be a function of arity 2'});
    f = arityOf._isCurried(f) ? f : curry(f);

    if (arityOf(f) < 2)
      return f;

    return curryWithConsistentStyle(f, function(a, b) {
      return f(b, a);
    });
  });


  /*
   * <apifunction>
   *
   * composeMany
   *
   * Category: types
   *
   * Parameter: fns: array
   * Returns: function
   *
   * Repeatedly composes the given array of functions, from right to left. All functions are curried where necessary.
   * Functions are curried from right to left. Throws an Error if any array member is not a function, if it has arity
   * zero, or if the value supplied is not an array.
   *
   * The result of calling composeMany([f1, f2, f3](x) is equal to f1(f2(f3(x))).
   *
   * Examples:
   * var square = function(x) {return x * x;};
   * var double = function(x) {return 2 * x;};
   * var plusOne = funkierJS.plus(1);
   * var f = funkierJS.composeMany([square, double, plusOne]);
   * f(2); // => 36
   *
   */

  var composeMany = curry(function(fnArray) {
    if (!isArrayLike(fnArray, true))
      throw new TypeError('composeMany requires an array or array-like object of functions');

    if (fnArray.length === 0)
      throw new TypeError('composeMany called with empty array');

    // We need to explicitly check the arity for the last function, as reduceRight won't trigger compose if the
    // array has length 1
    if (arityOf(fnArray[fnArray.length - 1]) === 0)
      throw new TypeError('Cannot compose functions of arity 0');

    if (fnArray.length === 1)
      return curry(fnArray[0]);

    // We don't use our foldr to avoid creating a circular dependency
    return fnArray.reduceRight(flip(compose));
  });


  /*
   * <apifunction>
   *
   * sectionLeft
   *
   * Category: function
   *
   * Parameter: f: function
   * Parameter: x: any
   * Returns: function
   *
   * Partially applies the binary function f with the given argument x, with x being supplied as the first argument
   * to f. The given function f will be curried if necessary. Throws if f is not a binary function.
   *
   * Note that object-curried functions should first be given a context before passing them into this function:
   * internally `this` is bound to null within `sectionLeft`, so it cannot supply a useful execution context to
   * the supplied function.
   *
   * Examples:
   * var f = function(x, y) {return x * y;};',
   * var g = funkierJS.sectionLeft(f, 2);
   * g(3); // => 6 (i.e. 2 * 3)',
   *
   */

  var sectionLeft = curry(function(f, x) {
    f = checkFunction(f, {arity: 2, message: 'Value to be sectioned must be a function of arity 2'});
    if (arityOf._isCurried(f)) return f.call(this, x);

    f = curry(f);
    return f(x);
  });


  /*
   * <apifunction>
   *
   * sectionRight
   *
   * Category: function
   *
   * Parameter: f: function
   * Parameter: x: any
   * Returns: function
   *
   * Partially applies the binary function f with the given argument x, with x being supplied as the second argument
   * to f. The given function f will be curried if necessary. Throws if f is not a binary function.
   *
   * Note that object-curried functions should first be given a context before passing them into this function:
   * internally `this` is bound to null within `sectionRight`, so it cannot supply a useful execution context to
   * the supplied function.
   *
   * Examples:
   *   var fn = funkierJS.sectionRight(funkierJS.subtract, 3);
   *   fn(2); // => -1
   *
   */

  var sectionRight = curry(function(f, x) {
    f = checkFunction(f, {arity: 2, message: 'Value to be sectioned must be a function of arity 2'});

    return sectionLeft(flip(f), x);
  });


  return {
    compose: compose,
    composeMany: composeMany,
    composeOn: composeOn,
    constant: constant,
    constant0: constant0,
    flip: flip,
    id: id,
    sectionLeft: sectionLeft,
    sectionRight: sectionRight
  };
})();

},{"../funcUtils":24,"../internalUtilities":27,"./curry":13}],12:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var arityOf = curryModule.arityOf;
  var curryWithConsistentStyle = curryModule._curryWithConsistentStyle;

  var array = require('./array');
  var map = array.map;

  var maybe = require('./maybe');
  var isJust = maybe.isJust;
  var isNothing = maybe.isNothing;
  var Just = maybe.Just;
  var Nothing = maybe.Nothing;
  var getJustValue = maybe.getJustValue;

  var result = require('./result');
  var isOk = result.isOk;
  var isErr = result.isErr;
  var Ok = result.Ok;
  var Err = result.Err;
  var getOkValue = result.getOkValue;

  var internalUtilities = require('../internalUtilities');
  var isArrayLike = internalUtilities.isArrayLike;


  /*
   * <apifunction>
   *
   * fmap
   *
   * Category: function
   *
   * Synonyms: fMap
   *
   * Parameter: f: function
   * Parameter: g: any
   * Returns: any
   *
   * Takes a known Functor, and maps the given function over it. Known functors are currently arrays, strings,
   * [`Maybes`](#Maybe) and [`Results](#Result), although this may change in future versions. Throws if the
   * first value is not a function of arity 1, or the second is not a known functor.
   *
   * The actions taken are as follows:
   *   - arrays/strings: the function is mapped over the array
   *   - Maybe: [`Just`](#Just) values yield a new Just value containing the result of applying the function to the
   *            contents of the Just. [`Nothing`](#Nothing) values yield Nothing.
   *   - Result: [`Ok`](#Ok) values yiels a new Ok value containing the result of applying the function to the contents
   *             of the Ok. [`Err`](#Err) values yield the Err value unchanged.
   *
   * Examples:
   *  fmap(function(x) { return x + 1; }, Just(10)); => Just 11
   *
   */

  var fmap = curry(function(f, val) {
    f = curryWithConsistentStyle(f, f, arityOf(f));

    if (isArrayLike(val))
      return map(f, val);

    if (isJust(val))
      return Just(f(getJustValue(val)));

    if (isNothing(val))
      return val;

    if (isOk(val))
      return Ok(f(getOkValue(val)));

    if (isErr(val))
      return val;

    throw new Error('Unrecognised functor');
  });


  return {
    fMap: fmap,
    fmap: fmap
  };
})();

},{"../internalUtilities":27,"./array":10,"./curry":13,"./maybe":18,"./result":21}],13:[function(require,module,exports){
module.exports = (function () {
  "use strict";

  var checkPositiveIntegral = require('../internalUtilities').checkPositiveIntegral;

  // Property that will be installed on all curried functions reflecting 'real' arity.
  var arityProp = '_trueArity';

  // Property that will be installed on curried functions that have not been partially applied
  var uncurriedProp = '_getOriginal';

  // Property that records the context with which the function was curried
  var contextProp = '_context';

  // Indicator that a function has been object curried but not yet acquired a context
  var objectCurryContext = {};


  /*
   * Ostensibly an internal helper function to detect whether or not a function is curried. It does however, have to
   * be installed as a property of arityOf, as some of the auto-generated tests require it.
   *
   */

  var isCurried = function(f) { return f.hasOwnProperty(arityProp); };


  var decorate = function(f, arity, original, context) {
    var define = function(p, v) { Object.defineProperty(f, p, {value: v}); };

    define(arityProp, arity);
    define(uncurriedProp, original);
    define(contextProp, context);

    return f;
  };


  var curryInternal = function(initialContext, length, fn) {
    length = checkPositiveIntegral(length, {strict: true});

    // We can't use checkFunction from the funcUtils module here: it depends on the base module, which in turn depends
    // on this module
    if (typeof(fn) !== 'function')
      throw new TypeError('Value to be curried is not a function');

    // Check function hasn't already been curried using a different mechanism
    var context = fn.hasOwnProperty(contextProp) ? fn[contextProp] : initialContext;
    if (context !== initialContext)
      throw new Error('Cannot bind a curried function to a different execution context');

    if (fn.hasOwnProperty(arityProp) && fn[arityProp] === length)
      return fn;

    fn = fn.hasOwnProperty(uncurriedProp) ? fn[uncurriedProp] : fn;

    // Handle the special case of length 0
    if (length === 0) {
      return decorate(function() {
        // We need to use a fresh variable for the context rather than reusing context, or later object curried
        // functions will have the wrong context due to lexical scoping
        var callContext = context;

        // Acquire context if objectCurried
        if (callContext === objectCurryContext) {
          if (this === undefined)
            throw new Error('Object curried function called without a context');

          callContext = this;
        }

        // Don't simply return fn: need to discard any arguments
        return fn.apply(callContext);
      }, 0, fn, initialContext);
    }

    // Note: 'a' is a dummy parameter to force the length property to be 1
    return decorate(function(a) {
      var args = [].slice.call(arguments);
      var callContext = context;

      // Throw if we expected arguments and didn't receive any, unless the function was objectCurried, in which case
      // we allow such a call to establish the execution context
      if (args.length === 0) {
        if (callContext === objectCurryContext) {
          if (this === undefined)
            throw new Error('Object curried function called without a context');
          return curryInternal(this, length, fn);
        }

        var errText = length === 1 ? '1 argument' : ('1 - ' + length + ' arguments');
        throw new Error('This function requires ' + errText);
      }

      // Acquire context if object-curried
      if (callContext === objectCurryContext) {
        if (this === undefined)
          throw new Error('Object curried function called without a context');

        callContext = this;
      }

      // If we have more arguments than we need, drop the extra ones on the floor
      // (the function will be called when we fall through to the next conditional)
      if (args.length > length)
        args = args.slice(0, length);

      // If we have enough arguments, call the underlying function
      if (args.length === length)
        return fn.apply(callContext, args);

      // We don't have enough arguments. Bind those that we already have
      var newFn = fn.bind.apply(fn, [callContext].concat(args));
      var argsNeeded = length - args.length;

      // Continue currying if we can't yet return a function of length 1
      if (argsNeeded > 1)
        return curryInternal({context: callContext}, argsNeeded, newFn);

      return decorate(function(b) {
        return newFn(b);
      }, 1, newFn, callContext);
    }, length, fn, context);
  };


  /*
   * <apifunction>
   *
   * curryWithArity
   *
   * Category: function
   *
   * Parameter: n: strictNatural
   * Parameter: f: function
   * Returns: function
   *
   * Curries the given function f to the supplied arity, which need not equal the function's length. The function will
   * be called when that number of arguments have been supplied. Superfluous arguments are discarded. The original
   * function will be called with a null execution context. It is possible to partially apply the resulting function,
   * and indeed the further resulting function(s). The resulting function and its partial applications will throw if
   * they require at least one argument, but are invoked without any. `curryWithArity` throws if the arity is not a
   * natural number, or if the second parameter is not a function. It will also throw if the given function is known
   * to be bound to a specific execution context.
   *
   * The returned function will have a length of 1, unless an arity of 0 was requested, in which case this will be the
   * length. The [arityOf](#arityOf) function can be used to determine how many arguments are required before the
   * wrapped function will be invoked.
   *
   * As noted above, you are permitted to curry a function to a smaller arity than its length. Whether the resulting
   * function behaves in a useful manner will of course depend on the function. One use case of `curryWithArity` is
   * to create unique functions from functions that accept optional arguments. For example, one common error involves
   * mapping over an array with `parseInt`, which has an optional *radix* parameter. `Array.prototype.map` invokes
   * the mapping function with additional metadata such as the position of the current element; when these factors
   * collide, one ends up trying to convert to numbers whose radix equals the array index. Instead, one could use
   * `curryWithArity` with an arity of 1 to create a new function that guarantees `parseInt` will be called with only
   * one argument. (Note: funkierJS provides a [`parseInt`](#parseInt) function for this purpose).
   *
   * It is possible to recurry functions that have been previously curried with [`curry`](#curry) or `curryWithArity`,
   * however generally it only makes sense to recurry a function that has not been partially applied: this will be
   * equivalent to currying the original function. Recurrying a partially applied function will likely not work as you
   * expect: the new function will be one that requires the given number of arguments before calling the original
   * function with the partially applied arguments and some of the ones supplied to the recurried function.
   *
   * You cannot however pass in functions that have been bound to a specific execution context using [`bind`](#bind),
   * or [`bindWithContextAndArity`](#bindWithContextAndArity): `curryWithArity` promises to invoke functions with a null
   * execution context, but those functions have a fixed execution context that cannot be overridden. For similar
   * reasons, functions curried with [`objectCurry`](#objectCurry) or [`objectCurryWithArity`](#objectCurryWithArity)
   * cannot be curried. An error is thrown if the function has been bound to an execution context in this way.
   *
   * Note however that funkierJS has no visibility into the execution contexts of functions bound using the native
   * function `bind` method. Attempting to curry these might lead to surprising results, and should be avoided.
   *
   * Examples:
   *   var f = function(x, y) { console.log(x, y); }
   *
   *   var g = funkierJS.curryWithArity(1, f);
   *
   *   g(7);  // => 1, undefined logged
   *
   *   var h = funkierJS.curryWithArity(3, f);
   *
   *   var j = h(2, 'a');
   *
   *   j(9);  // => 2, 'a' logged
   *
   *   h('fizz')('buzz', 'foo') // => 'fizz', 'buzz' logged
   *
   */

   // TODO: More realistic examples required
   // TODO: The paragraph about not recurrying partially applied functions is not particularly clear


  var curryWithArity = curryInternal.bind(null, null);


  /*
   * <apifunction>
   *
   * curry
   *
   * Category: function
   *
   * Parameter: f: function
   * Returns: function
   *
   * Curries the given function f, returning a function which accepts the same number of arguments as the original
   * function's length property, but which may be partially applied. The function can be partially applied by passing
   * arguments one at a time, or by passing several arguments at once. The function can also be called with more
   * arguments than the given function's length, but the superfluous arguments will be ignored, and will not be
   * passed to the original function. If the curried function or any subsequent partial applications require at least
   * one argument, then calling the function with no arguments will throw. `curry` throws if its argument is not a
   * function. It will also throw if the function is known to be bound to a specific execution context.
   *
   * Currying a function that has already been curried will return the exact same function, unless the function was
   * curried with a different mechanism - see below.
   *
   * The returned function will have a length of 1, unless the original function will have length 0, in which case
   * the result also has length 0. Note that when currying functions of length 0 and 1 that the results will be
   * different functions from those passed in.
   *
   * If you need a function which accepts an argument count that differs from the function's length property,
   * use `curryWithArity`.
   *
   * Note that you cannot pass in functions that have been bound to a specific execution context using [`bind`](#bind),
   * or [`bindWithContextAndArity`](#bindWithContextAndArity): allowing those would break the invariant that functions
   * curried with `curry` are invoked with a null execution context. Similarly, functions curried with
   * [`objectCurry`](#objectCurry) and [`objectCurryWithArity`](#objectCurryWithArity) cannot be recurried through
   * `curryWithArity`. Thus an error is thrown in such cases. (However, funkierJS cannot tell if a function has been
   * bound with the native `bind` method. Currying such functions might lead to unexpected results).
   *
   * Examples:
   *   var f = function(x, y, z) { console.log(x, y, z); }
   *
   *   var g = funkierJS.curry(f);
   *
   *   g(4);  // => a function awaiting two arguments
   *
   *   g(4)(2); // => a function awaiting one argument
   *
   *   g(4)(2)('z'); // => 4, 2, 'z' logged
   *
   *   g('a', 'b')('c'); // => 'a', 'b' 'c' logged
   *
   *   g('x')('y', 'z'); // => 'x', 'y' 'z' logged
   *
   *   g('d', 'e', 'f'); // => 'd', 'e' 'f' logged
   *
   *   funkierJS.curry(g) === g;  // => true
   *
   */

  // TODO: More realistic examples required
  var curry = function(fn) {
    var desiredLength = fn.hasOwnProperty(arityProp) ? fn[arityProp] : fn.length;
    return curryWithArity(desiredLength, fn);
  };

  // Now that curry is defined, we can use it to curry itself
  curry = curry(curry);
  // curryWithArity should also be curried
  curryWithArity = curry(curryWithArity);


  /*
   * <apifunction>
   *
   * arityOf
   *
   * Category: function
   *
   * Synonyms: arity
   * Parameter: f: function
   * Returns: number
   *
   * Reports the real arity of a function. If the function has not been curried by funkier.js, this simply returns the
   * function's length property. For a function that has been curried, the arity of the original function will be
   * reported (the function's length property will always be 0 or 1 in this case). For a partially applied function,
   * the amount of arguments not yet supplied will be returned.
   *
   * Examples:
   *   funkierJS.arityOf(function(x) {}); // => 1;
   *
   */

  var arityOf = curry(function(f) {
    if (typeof(f) !== 'function')
      throw new TypeError('Cannot compute arity of non-function');

    return f.hasOwnProperty(arityProp) ? f[arityProp] : f.length;
  });
  arityOf._isCurried = isCurried;


  /*
   * <apifunction>
   *
   * bind
   *
   * Category: function
   *
   * Synonyms: bindWithContext
   *
   * Parameter: ctx: objectlike
   * Parameter: f: function
   * Returns: function
   *
   * Given an object and function, returns a curried function with the same arity as the original, and whose execution
   * context is permanently bound to the supplied object. The function will be called when sufficient arguments have
   * been supplied. Superfluous arguments are discarded. It is possible to partially apply the resulting function, and
   * indeed the further resulting function(s). The resulting function and its partial applications will throw if they
   * require at least one argument, but are invoked without any. `bind` throws if the first parameter is not an
   * an acceptable type for an execution context, or if the last parameter is not a function.
   *
   * The returned function will have a length of 1, unless an arity of 0 was requested, in which case this will be the
   * length. The [`arityOf`](#arityOf) function can be used to determine how many arguments are required before the
   * wrapped function will be invoked.
   *
   * `bind` will accept functions that have been previously been curried to the same execution context, as that being
   * provided, but will effectively be an identity function in such cases. However, attempting to curry a function
   * known to be bound to a different execution context is an error. In particular, functions curried
   * with [`curry`](#curry) or [`curryWithArity`](#curryWithArity) cannot be curried with an execution context: they
   * have already been bound with an implicit `null` execution context. Equally, functions curried with
   * [`objectCurry`](#objectCurry) and [`objectCurryWithArity`](#objectCurryWithArity) cannot be passed to `bind`, due
   * to the different way in which they acquire an execution context. `bind` will throw in such cases.
   *
   * Note also that many of the function manipulating functions, such as [`flip`](#flip), [`compose`](#compose) etc.
   * will curry the result in the same manner as the supplied functions, or otherwise will curry them using
   * [`curry`](#curry). As noted above, functions curried by `curry` cannot then be recurried by this function. Thus
   * when performing such manipulations, one must curry them in the desired manner first, before manipulating them.
   * This limitation may be removed in future versions of the library.
   *
   * Unfortunately, funkierJS has no visibility into functions bound with the native `bind` method; attempting to
   * curry such functions won't throw, but they will not work as expected.
   *
   * Examples:
   *   var obj = {foo: 42};
   *
   *   var f = function(x, y) { return this.foo + x; };
   *
   *   var g = funkierJS.bind(obj, f);
   *
   *   g(3)(2); // returns 45
   *
   *   g(5, 2); // returns 47
   *
   *   var obj2 = {foo: 10};
   *   var h = funkierJS.bindWithContextAndArity(3, obj2, f);
   *   var j = funkierJS.bind(obj2, h); // OK, same context object
   *
   *   var err = funkierJS.bind({foo: 1}, g); // throws: execution contexts don't match
   *
   */

  var bind = curry(function(context, fn) {
    var desiredLength = fn.hasOwnProperty(arityProp) ? fn[arityProp] : fn.length;
    return bindWithContextAndArity(desiredLength, context, fn);
  });


  /*
   * <apifunction>
   *
   * bindWithContextAndArity
   *
   * Category: function
   *
   * Parameter: n: strictNatural
   * Parameter: ctx: objectlike
   * Parameter: f: function
   * Returns: function
   *
   * Given an arity, object and function, returns a curried function whose execution context is permanently bound to
   * the supplied object, and whose arity equals the arity given. The supplied arity need not equal the function's
   * length. The function will be only called when the specified number of arguments have been supplied. Superfluous
   * arguments are discarded. It is possible to partially apply the resulting function, and indeed the further
   * resulting function(s). The resulting function and its partial applications will throw if they require at least
   * one argument, but are invoked without any. `bindWithContextAndArity` throws if the arity is not a natural
   * number, if the second parameter is not an acceptable type for an execution context, or if the last parameter is
   * not a function.
   *
   * The returned function will have a length of 1, unless an arity of 0 was requested, in which case this will be the
   * length. The [`arityOf`](#arityOf) function can be used to determine how many arguments are required before the
   * wrapped function will be invoked.
   *
   * As noted above, you are permitted to curry a function to a smaller arity than its length. Whether the resulting
   * function behaves in a useful manner will of course depend on the function.
   *
   * In some limited circumstances, it is possible to recurry previously curried functions, however generally it only
   * makes sense to recurry a function that has not been partially applied: this will be equivalent to currying the
   * original function. To be able to recurry a curried function to a different arity, the execution context given
   * must be the exact object that was previously used to create the function being recurried. It is an error to
   * try and recurry a curried function bound to one execution context to another. In particular, functions curried
   * with [`curry`](#curry) or [`curryWithArity`](#curryWithArity) cannot be curried with an execution context: they
   * have already been bound with an implicit `null` execution context. Likewise, functions that have been curried
   * using either [`objectCurry`](#objectCurry) or [`objectCurryWithArity`](#objectCurryWithArity) cannot be curried
   * using `bindWithContextAndArity`, due to the different mechanism they use to acquire an execution context.
   * `bindWithContextAndArity` will throw in that such cases.
   *
   * Note also that many of the function manipulating functions, such as [`flip`](#flip), [`compose`](#compose) etc.
   * will curry the result in the same manner as the supplied functions, or otherwise will curry them using
   * [`curry`](#curry). As noted above, functions curried by `curry` cannot then be recurried by this function. Thus
   * when performing such manipulations, one must curry them in the desired manner first, before manipulating them.
   * This limitation may be removed in future versions of the library.
   *
   * Unfortunately, funkierJS has no visibility into functions bound with the native `bind` method; attempting to
   * curry such functions won't throw, but they will not work as expected.
   *
   * Examples:
   *   var obj = {foo: 42};
   *
   *   var f = function(x, y) { return this.foo + x; };
   *
   *   var g = funkierJS.bindWithContextAndArity(1, obj, f);
   *
   *   g(3); // returns 45
   *
   *   var h = funkierJS.bindWithContextAndArity(3, obj, g); // OK, same context object
   *   h(2)(3, 4); // returns 44
   *
   *   var err = funkierJS.bindWithContextAndArity(2, {foo: 1}, g); // throws: execution contexts don't match
   *
   *   var ok = funkierJS.bindWithContextAndArity(2, {foo: 1}, f); // still ok to bind the original function though
   *
   */

  var bindWithContextAndArity = curry(function(arity, context, fn) {
    return curryInternal(context, arity, fn);
  });


  /*
   * <apifunction>
   *
   * objectCurry
   *
   * Category: function
   *
   * Parameter: f: function
   * Returns: function
   *
   * Given a function, returns a curried function which calls the underlying with the execution context active when the
   * first arguments are supplied. This means that when partially applying the function, the resulting functions will
   * have their execution context permanently bound. This method of binding is designed for currying functions that
   * exist on an object's prototype. The function will be only called when sufficient arguments have been supplied.
   * Superfluous arguments are discarded. The resulting function may be called without any arguments even when it has
   * non-zero arity, for the purposes of establishing an execution context (usually when passing the function to some
   * other function-manipulating function); however the partial applications of the result will throw if they
   * require at least one argument, but are invoked without any. `objectCurry` throws if its parameter is not a
   * function. The resulting function will throw if invoked with an undefined execution context.
   *
   * The returned function will have a length of 1, unless a function of arity of 0 was supplied, in which case this
   * will be the length. The [`arityOf`](#arityOf) function can be used to determine how many arguments are required
   * before the wrapped function will be invoked.
   *
   * One can pass in a function created by `objectCurry` or [`objectCurryWithArity`](#objectCurryWithArity) providing
   * it has not been partially applied. This will effectively be an identity operation. However, passing in a partially
   * applied function derived from an earlier currying call is an error, as the execution context has now been bound.
   * Similarly, functions returned from [`curry`](#curry), [`curryWithArity`](#curryWithArity), [`bind`](#bind) and
   * [`bindWithContextAndArity`](#bindWithContextAndArity) cannot be curried with this function, and will throw an
   * error, just as those functions curry functions and their partial applications returned from `objectCurry`.
   * `objectCurry` will throw when provided with an invalid function.
   *
   * Note also that many of the function manipulating functions, such as [`flip`](#flip), [`compose`](#compose) etc.
   * will curry the result in the same manner as the supplied functions, or otherwise will curry them using
   * [`curry`](#curry). As noted above, functions curried by `curry` cannot then be recurried by this function. Thus
   * when performing such manipulations, one must curry them in the desired manner first, before manipulating them.
   * This limitation may be removed in future versions of the library.
   *
   * Unfortunately, funkierJS has no visibility into functions bound with the native `bind` method; attempting to
   * curry such functions won't throw, but they will not work as expected.
   *
   * Examples:
   *
   *   var proto = {foo: function(x, y) { return x + y + this.bar; }};
   *   proto.foo = funkierJS.objectCurry(proto.foo);
   *
   *   var obj1 = Object.create(proto);
   *   obj1.bar = 10;
   *
   *   var g = obj1.foo(10);
   *   g(22); // => 42
   *
   *   var obj2 = Object.create(proto);
   *   obj2.bar = 100;
   *   obj2.foo(10)(10); // => 120
   *   g(1); // => 21, the application using obj2 didn't affect the execution context of g
   *
   *   var err = obj1.foo;
   *   err(1, 2);  // => throws
   *
   */

  // TODO: Need better examples
  // TODO: Revisit examples in this file once object functions implemented (use funkierJS equivalents
  //       rather than Object.create, [].slice, etc...)
  var objectCurry = curry(function(fn) {
    return objectCurryWithArity(arityOf(fn), fn);
  });


  /*
   * <apifunction>
   *
   * objectCurryWithArity
   *
   * Category: function
   *
   * Parameter: n: strictNatural
   * Parameter: f: function
   * Returns: function
   *
   * Given an arity and function, returns a curried function which calls the underlying with the execution context
   * active when the first arguments are supplied. This means that when partially applying the function, the
   * resulting functions will have their execution context permanently bound. This method of binding is designed for
   * currying functions that exist on an object's prototype. The function will be only called when the specified number
   * of arguments have been supplied. Superfluous arguments are discarded. If the resulting function has non-zero
   * length, it may be called without any arguments for the purpose of establishing an execution context; however
   * its partial applications throw if they require at least one argument, but are invoked without any.
   * `objectCurryWithArity` throws if the arity is not a natural number or if the second parameter is not a function.
   * The resulting function will throw if invoked with an undefined execution context.
   *
   * The returned function will have a length of 1, unless an arity of 0 was requested, in which case this will be the
   * length. The [`arityOf`](#arityOf) function can be used to determine how many arguments are required before the
   * wrapped function will be invoked.
   *
   * As noted above, you are permitted to curry a function to a smaller arity than its length. Whether the resulting
   * function behaves in a useful manner will of course depend on the function.
   *
   * If one has a function that has been returned from [`objectCurry`](#objectCurry) or `objectCurryWithArity`, one can
   * recurry it to a different arity if required. However, one cannot recurry any partial applications derived from it,
   * as the execution context has now been bound. `objectCurryWithArity` also cannot curry functions returned from
   * [`curry`](#curry), [`curryWithArity`](#curryWithArity), [`bind`](#bind) or
   * [`bindWithContextAndArity`](#bindWithContextAndArity), and nor can those functions curry functions returned from
   * `objectCurryWithArity`, or their subsequent partial applications. `objectCurryWithArity` will throw when provided
   * with such a function.
   *
   * Note also that many of the function manipulating functions, such as [`flip`](#flip), [`compose`](#compose) etc.
   * will curry the result in the same manner as the supplied functions, or otherwise will curry them using
   * [`curry`](#curry). As noted above, functions curried by `curry` cannot then be recurried by this function. Thus
   * when performing such manipulations, one must curry them in the desired manner first, before manipulating them.
   * This limitation may be removed in future versions of the library.
   *
   * Unfortunately, funkierJS has no visibility into functions bound with the native `bind` method; attempting to
   * curry such functions won't throw, but they will not work as expected.
   *
   * Examples:
   *
   *   var proto = {foo: function(x, y, z) { return x + y + this.bar; }};
   *   proto.foo = funkierJS.objectCurryWithArity(2, proto.foo);
   *
   *   var obj1 = Object.create(proto);
   *   obj1.bar = 10;
   *
   *   var g = obj1.foo(10);
   *   g(22); // => 42
   *
   *   var obj2 = Object.create(proto);
   *   obj2.bar = 100;
   *   obj2.foo(10)(10); // => 120
   *   g(1); // => 21, the application using obj2 didn't affect the execution context of g
   *
   *   var err = obj1.foo;
   *   err(1, 2);  // => throws
   *
   */

  // TODO: Need better examples
  // TODO: Revisit examples in this file once object functions implemented (use funkierJS equivalents
  //       rather than Object.create, [].slice, etc...)
  var objectCurryWithArity = curry(curryInternal.bind(null, objectCurryContext));


  /*
   * Where appropriate, funkierJS aims to preserve the currying style in functions that manipulate other functions
   * This function takes an existing curried function and a new function, and curries the new function in a compatible
   * way with the existing function. Thus, if the function was object curried, then so too is the new function. If it
   * is bound to a specific object then so too is the new function. Otherwise, the standard currying is applied.
   *
   * Of course, with the exception of object currying, the currying of the wrapper will not affect the operation
   * of the original functionwhich is presumably called within the wrapper functionas its context is already
   * bound. This function simply aims to enable manipulation of arities in a manner consistent with the original
   * functions.
   *
   */

  var curryWithConsistentStyle = function(existing, newFn, arity) {
    arity = arity === undefined ? arityOf(newFn) : arity;
    return curryInternal(existing.hasOwnProperty(contextProp) ? existing[contextProp] : null, arity, newFn);
  };


  /*
   * Where appropriate, funkierJS aims to preserve the currying style in functions that manipulate other functions
   * Whilst a simple question in the case of one function, this becomes more problematic when dealing with two or
   * more functions. This function takes two functionsthe functions being wrappedand the wrapping function, and
   * currys the wrapping function to the most appropriate choice for those functions. The wrapping function is assumed
   * to have the correct arity (so the plain currying function will be called, not a *WithArity function.
   *
   * So, what is the most appropriate style? If either function is object curried, then one would want another object
   * curried function for the purposes of passing the execution context to the wrapped functions. If both functions
   * are bound to the same context, then it makes sense to bind the result to the same context. If both functions
   * are curried to a null context, then again it is consistent to curry the wrapping function in the same manner.
   *
   * Things are more complicated when the functions have different currying styles, and neither of them is object
   * curried. Thus, either they are both bound to different contexts, or one is bound and one is null curried. For
   * maximum flexibility, I think the result should be null curried.
   *
   * Of course, with the exception of object currying, the currying of the wrapper will not affect the operation
   * of the original functionswhich are presumably called within the wrapper functionas their contexts are already
   * bound. This function simply aims to enable manipulation of arities in a manner consistent with the original
   * functions.
   *
   */

  var chooseCurryStyle = function(pred1, pred2, wrapper, arity) {
    arity = arity !== undefined ? arity : arityOf(wrapper);

    var contexts = [pred1, pred2].map(function(p) { return isCurried(p) ? p[contextProp] : null; });

    var contextToApply;
    if (contexts.indexOf(objectCurryContext) !== -1) {
      contextToApply = objectCurryContext;
    } else if (contexts[0] === contexts[1]) {
      contextToApply = contexts[0];
    } else {
      contextToApply = null;
    }

    return curryInternal(contextToApply, arity, wrapper);
  };


  return {
    arity: arityOf,
    arityOf: arityOf,
    bind: bind,
    bindWithContext: bind,
    bindWithContextAndArity: bindWithContextAndArity,
    _chooseCurryStyle: chooseCurryStyle,
    curry: curry,
    curryWithArity: curryWithArity,
    _curryWithConsistentStyle: curryWithConsistentStyle,
    objectCurry: objectCurry,
    objectCurryWithArity: objectCurryWithArity,
  };
})();

},{"../internalUtilities":27}],14:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;

  var object = require('./object');
  var callProp = object.callProp;

  // TODO Consistency of the safe operations e.g. changing month to a 30 day month...
  // TODO Could use some synonyms for these functions

  /*
   * <apifunction>
   *
   * getDayOfMonth
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getDate`. Takes a `Date` object, and returns an integer representing the day of
   * the month (1-31) of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getDayOfMonth(a); // => 15
   *
   */

  var getDayOfMonth = callProp('getDate');


  /*
   * <apifunction>
   *
   * getDayOfWeek
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getDay`. Takes a `Date` object, and returns an integer representing the day of the
   * month (0-6) of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getDayOfWeek(a); // => 2
   *
   */

  var getDayOfWeek = callProp('getDay');


  /*
   * <apifunction>
   *
   * getFullYear
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getFullYear`. Takes a `Date` object, and returns a 4-digit integer representing
   * the year of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getFullYear(a); // => 2000
   *
   */

  var getFullYear = callProp('getFullYear');


  /*
   * <apifunction>
   *
   * getHours
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getHours`. Takes a `Date` object, and returns a integer representing the hour
   * field (0-23) of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getHours(a); // => 10
   *
   */

  var getHours = callProp('getHours');


  /*
   * <apifunction>
   *
   * getMilliseconds
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getMilliseconds`. Takes a `Date` object, and returns a integer representing the
   * milliseconds field (0-999) of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getMilliseconds(a); // => 13
   *
   */

  var getMilliseconds = callProp('getMilliseconds');


  /*
   * <apifunction>
   *
   * getMinutes
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getMinutes`. Takes a `Date` object, and returns a integer representing the minutes
   * field (0-59) of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getMinutes(a); // => 11
   *
   */

  var getMinutes = callProp('getMinutes');


  /*
   * <apifunction>
   *
   * getMonth
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getMonths`. Takes a `Date` object, and returns a integer representing the month
   * field (0-11) of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getMonth(a); // => 1
   *
   */

  var getMonth = callProp('getMonth');


  /*
   * <apifunction>
   *
   * getSeconds
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getSeconds`. Takes a `Date` object, and returns a integer representing the seconds
   * field (0-59) of the given date.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.getSeconds(a); // => 12
   *
   */

  var getSeconds = callProp('getSeconds');


  /*
   * <apifunction>
   *
   * toEpochMilliseconds
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getTime`. Takes a `Date` object, and returns the number of milliseconds elapsed
   * since midnight, January 1 1970.
   *
   */

  var toEpochMilliseconds = callProp('getTime');


  /*
   * <apifunction>
   *
   * getTimezoneOffset
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getTimezoneOffset`. Takes a `Date` object, and returns the delta in minutes
   * between the Javascript environment and UTC.
   *
   */

  var getTimezoneOffset = callProp('getTimezoneOffset');


  /*
   * <apifunction>
   *
   * getUTCDayOfMonth
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCDate`. Takes a `Date` object, and returns an integer representing the day of
   * the month (1-31) of the given date, adjusted for UTC.
   *
   */

  var getUTCDayOfMonth = callProp('getUTCDate');

  /*
   * <apifunction>
   *
   * getUTCDayOfWeek
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCDay`. Takes a `Date` object, and returns an integer representing the day of
   * the week (0-6) of the given date, adjusted for UTC.
   *
   */


  var getUTCDayOfWeek = callProp('getUTCDay');


  /*
   * <apifunction>
   *
   * getUTCFullYear
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCFullYear`. Takes a `Date` object, and returns a 4-digit integer representing
   * the year of the given date, adjusted for UTC.
   *
   */

  var getUTCFullYear = callProp('getUTCFullYear');


  /*
   * <apifunction>
   *
   * getUTCHours
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCHours`. Takes a `Date` object, and returns an integer representing the hours
   * field of the given date (0-23), adjusted for UTC.
   *
   */

  var getUTCHours = callProp('getUTCHours');


  /*
   * <apifunction>
   *
   * getUTCMilliseconds
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCMilliseconds`. Takes a `Date` object, and returns an integer representing
   * the milliseconds field of the given date (0-999), adjusted for UTC.
   *
   */

  var getUTCMilliseconds = callProp('getUTCMilliseconds');


  /*
   * <apifunction>
   *
   * getUTCMinutes
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCMinutes`. Takes a `Date` object, and returns an integer representing the
   * minutes field of the given date (0-59), adjusted for UTC.
   *
   */

  var getUTCMinutes = callProp('getUTCMinutes');


  /*
   * <apifunction>
   *
   * getUTCMonth
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCMonth`. Takes a `Date` object, and returns an integer representing the month
   * field of the given date (0-11), adjusted for UTC.
   *
   */

  var getUTCMonth = callProp('getUTCMonth');


  /*
   * <apifunction>
   *
   * getUTCSeconds
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: number
   *
   * A wrapper around `Date.prototype.getUTCSeconds`. Takes a `Date` object, and returns an integer representing the
   * seconds field of the given date (0-59), adjusted for UTC.
   *
   */

  var getUTCSeconds = callProp('getUTCSeconds');


  /*
   * <apifunction>
   *
   * toLocaleDateString
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: string
   *
   * A wrapper around `Date.prototype.toLocaleDateString`. Takes a `Date` object, and  a string representing the date
   * portion of the object, formatted according to locale conventions.
   *
   */

  var toLocaleDateString = callProp('toLocaleDateString');


  /*
   * <apifunction>
   *
   * toDateString
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: string
   *
   * A wrapper around `Date.prototype.toDateString`. Takes a `Date` object, and returns a string representing the date
   * portion of the object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.toDateString(a); // => "Tue Feb 15 2000" or similar
   *
   */

  var toDateString = callProp('toDateString');


  /*
   * <apifunction>
   *
   * toTimeString
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: string
   *
   * A wrapper around `Date.prototype.toTimeString`. Takes a `Date` object, and returns a string representing the time
   * portion of the object.
   *
   */

  var toTimeString = callProp('toTimeString');


  /*
   * <apifunction>
   *
   * toISOString
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: string
   *
   * A wrapper around `Date.prototype.toISOString`. Takes a `Date` object, and returns a string representation of the
   * date in ISO format.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.toISOString(a); // "2000-02-15T10:11:12.013Z" or similar',
   *
   */

  var toISOString = callProp('toISOString');


  /*
   * <apifunction>
   *
   * toUTCString
   *
   * Category: Date
   *
   * Parameter: d: Date
   * Returns: string
   *
   * A wrapper around `Date.prototype.toUTCString`. Takes a `Date` object, and returns a string representation of the
   * equivalent date in UTC.
   *
   */

  var toUTCString = callProp('toUTCString');


  // We cannot use callProp for the setters due to the need to return the given date
  // TODO: This comment is likely out of date

  /*
   * <apifunction>
   *
   * setDayOfMonth
   *
   * Category: Date
   *
   * Parameter: day: number
   * Parameter: d: Date
   * Returns: Date
   *
   * A wrapper around `Date.prototype.setDate`. Takes a value between 1 and 31, and a `Date` object, and sets the day of
   * the month to the given value. Invalid values will cause a change in other fields: for example, changing the day to
   * 31 in a month with 30 days will increment the month, which may in turn increment the year. Returns the given 'Date`
   * object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setDayOfMonth(1, a); // => a now refers to Feb 1 2000
   *
   */

  var setDayOfMonth = curry(function(val, d) {
    d.setDate(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setFullYear
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: d: Date
   * Returns: Date
   *
   * A wrapper around `Date.prototype.setFullYear`. Takes a value and a `Date` object, and sets the year to the given
   * value. This may cause a change in other fields: for example, setting the year when the month and day represent
   * February 29 respectively may cause those values to change to March 1 if the new year is not a leap year.
   * Returns the given `Date` object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setFullYear(2001, a); // => a now refers to Feb 15 2001
   *
   */

  var setFullYear = curry(function(val, d) {
    d.setFullYear(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setHours
   *
   * Category: Date
   *
   * Parameter: hours: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setHours`. Takes a value between 0 and 23 representing the hour of the day, and
   * a `Date` object, and sets the hour to the given value. Invalid values will cause a change in other fields: if the
   * value > 23, then the day will be incremented by hours div 24. This may in turn cause a cascade of increments
   * to other fields. Returns the given `Date` object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setHours(11, a); // => a now refers to 11:11:12:013
   *
   */

  var setHours = curry(function(val, d) {
    d.setHours(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setMilliseconds
   *
   * Category: Date
   *
   * Parameter: milliseconds: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setMilliseconds`. Takes a value between 0 and 999 representing the milliseconds,
   * and a `Date` object, and sets the milliseconds to the given value. Invalid values will cause a change in other
   * fields: if the value > 999, then the seconds will be incremented by milliseconds div 1000. This may in turn cause
   * a cascade of increments to other fields. Returns the given `Date` object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setMilliseconds(20, a); // => a now refers to 10:11:12:020
   *
   */

  var setMilliseconds = curry(function(val, d) {
    d.setMilliseconds(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setMinutes
   *
   * Category: Date
   *
   * Parameter: minutes: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setMinutes`. Takes a value between 0 and 59 representing the minutes, and a
   * `Date` object, and sets the minutes to the given value. Invalid values will cause a change in other fields: if the
   * value > 59, then the hours will be incremented by minutes div 60. This may in turn cause a cascade of increments
   * to other fields. Returns the given `Date` object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setMinutes(59, a); // => a now refers to 10:59:12:013
   *
   */

  var setMinutes = curry(function(val, d) {
    d.setMinutes(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setMonth
   *
   * Category: Date
   *
   * Parameter: month: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setMonth`. Takes a value between 0 and 11 representing the month, and a `Date`
   * object, and sets the month to the given value. Invalid values will cause a change in other fields: if the
   * value > 11, then the year will be incremented by month div 12. Returns the given `Date` object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setMonth(2, a); // => a now refers to 15 March 2001
   *
   */

  var setMonth = curry(function(val, d) {
    d.setMonth(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setSeconds
   *
   * Category: Date
   *
   * Parameter: seconds: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setSeconds`. Takes a value between 0 and 59 representing the seconds, and a
   * `Date` object, and sets the seconds to the given value. Invalid values will cause a change in other fields: if the
   * value > 59, then the minutes will be incremented by seconds div 60. This may in turn cause a cascade of increments
   * to other fields. Returns the given `Date` object.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setSeconds(50, a); // => a now refers to 10:11:50:013
   *
   */

  var setSeconds = curry(function(val, d) {
    d.setSeconds(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setTimeSinceEpoch
   *
   * Category: Date
   *
   * Parameter: milliseconds: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setTime`. Takes a value representing the number of seconds since midnight,
   * January 1, 1970 and a date. Simultaneously sets all of the fields of the given date to represent the date and
   * time that is that many seconds since the epoch. Returns the given `Date`.
   *
   * Examples:
   *   var a = new Date(2000, 1, 15, 10, 11, 12, 13);
   *   funkierJS.setTimeSinceEpoch(1340122101412, a); // => a now refers to 19th July 2012, 16:08:21:041
   *
   */

  var setTimeSinceEpoch = curry(function(val, d) {
    d.setTime(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setUTCDayOfMonth
   *
   * Category: Date
   *
   * Parameter: day: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setUTCDate`. Takes a value between 1 and 31, and a `Date` object, and sets the day
   * of the month to the local equivalent of the given value. Invalid values will cause a change in other fields: for
   * example, changing the day to 31 in a month with 30 days will increment the month, which may in turn increment the
   * year. Returns the given `Date` object.
   *
   */

  var setUTCDayOfMonth = curry(function(val, d) {
    d.setUTCDate(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setUTCFullYear
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setUTCFullYear`. Takes a value and a `Date` object, and sets the year to the local
   * equivalent of the given value. This may cause a change in other fields: for example, setting the year when the
   * month and day represent February 29 respectively may cause those values to change to March 1 if the new year is not
   * a leap year. Returns the given `Date` object.
   *
   */

  var setUTCFullYear = curry(function(val, d) {
    d.setUTCFullYear(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setUTCHours
   *
   * Category: Date
   *
   * Parameter: hours: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setUTCHours`. Takes a value between 0 and 23 representing the hour of the day, and
   * a `Date` object, and sets the hour to the local equivalent of the given value. Invalid values will cause a change
   * in other fields: if the value > 23, then the day will be incremented by hours div 24. This may in turn cause a
   * cascade of increments to other fields. Returns the given `Date` object.
   *
   */

  var setUTCHours = curry(function(val, d) {
    d.setUTCHours(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setUTCMilliseconds
   *
   * Category: Date
   *
   * Parameter: milliseconds: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setUTCMilliseconds`. Takes a value between 0 and 999 representing the
   * milliseconds, and a `Date` object, and sets the milliseconds to the local equivalent of the given value. Invalid
   * values will cause a change in other fields: if the value > 999, then the seconds will be incremented by
   * milliseconds div 1000. This may in turn cause a cascade of increments to other fields. Returns the given `Date`
   * object.
   *
   */

  var setUTCMilliseconds = curry(function(val, d) {
    d.setUTCMilliseconds(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setUTCMinutes
   *
   * Category: Date
   *
   * Parameter: minutes: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setUTCMinutes`. Takes a value between 0 and 59 representing the minutes, and a
   * `Date` object, and sets the minutes to the local equivalent of the given value. Invalid values will cause a change
   * in other fields: if the value > 59, then the hours will be incremented by minutes div 60. This may in turn cause a
   * cascade of increments to other fields. Returns the given `Date` object.
   *
   */

  var setUTCMinutes = curry(function(val, d) {
    d.setUTCMinutes(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setUTCMonth
   *
   * Category: Date
   *
   * Parameter: month: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setUTCMonth`. Takes a value between 0 and 11 representing the month, and a
   * `Date` object, and sets the month to the local equivalent of the given value. Invalid values will cause a change
   * in other fields: if the value > 11, then the year will be incremented by month div 12. Returns the given `Date`
   * object.
   *
   */

  var setUTCMonth = curry(function(val, d) {
    d.setUTCMonth(val);
    return d;
  });


  /*
   * <apifunction>
   *
   * setUTCSeconds
   *
   * Category: Date
   *
   * Parameter: seconds: number
   * Parameter: d: Date
   * Returns: date
   *
   * A wrapper around `Date.prototype.setUTCSeconds`. Takes a value between 0 and 59 representing the seconds, and a
   * `Date` object, and sets the seconds to the local equivalent of the given value. Invalid values will cause a change
   * in other fields: if the value > 59, then the minutes will be incremented by seconds div 60. This may in turn cause
   * a cascade of increments to other fields. Returns the local equivalent of the given `Date` object.
   *
   */

  var setUTCSeconds = curry(function(val, d) {
    d.setUTCSeconds(val);
    return d;
  });


/* TODO
  var safeSetDayOfMonth = defineValue(
    'name: safeSetDayOfMonth',
    'signature: day: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setDate`. Takes a value between 1 and 31, and',
    'a `Date` object, and sets the day of the month to the given value. Throws if the',
    'value is outside this range, or if the month contains fewer days than the given',
    'value.',
    '',
    'Returns the given date.',
    '--',
    'var a = new Date(2000, 1, 15, 10, 11, 12, 13);',
    'safeSetDayOfMonth(30, a); // Throws',
    curry(function(val, d) {
      if (val < 0 || val > 31)
        throw new TypeError('Attempt to set day with invalid value: '+ val);

      var month = getMonth(d);
      if (val === 31 && [1, 3, 5, 8, 10].indexOf(month) !== -1)
        throw new TypeError('Attempt to set day with invalid value: '+ val);

      if (month === 2) {
        if (val === 30)
          throw new TypeError('Attempt to set day with invalid value: '+ val);

        if (val === 29) {
          var year = getFullYear(d);
          var notLeapYear = (year % 4 !== 0) || (year % 100 === 0 && year % 400 !== 0);

          if (notLeapYear)
            throw new TypeError('Attempt to set day with invalid value: '+ val);
        }
      }

      d.setDate(val);
      return d;
    })
  );


  var safeSetHours = defineValue(
    'name: safeSetHours',
    'signature: hours: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setHours`. Takes a value between 0-23',
    'representing the hour of the day, and sets the hour to the given value.',
    '',
    'Throws a TypeError for values outwith the range 0-23.',
    '',
    'Returns the given date.',
    '--',
    'var a = new Date(2000, 1, 15, 10, 11, 12, 13);',
    'safeSetHours(33, a); // Throws',
    curry(function(val, d) {
      if (val < 0 || val > 23)
        throw new TypeError('Attempt to set hour with invalid value: '+ val);

      d.setHours(val);
      return d;
    })
  );


  var safeSetMilliseconds = defineValue(
    'name: safeSetMilliseconds',
    'signature: milliseconds: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setMilliseconds`. Takes a value between 0-999',
    'representing the milliseconds, and sets the milliseconds to the given value.',
    '',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    '--',
    'var a = new Date(2000, 1, 15, 10, 11, 12, 13);',
    'safeSetMilliseconds(1002, a); // Throws',
    curry(function(val, d) {
      if (val < 0 || val > 999)
        throw new TypeError('Attempt to set milliseconds with invalid value: '+ val);

      d.setMilliseconds(val);
      return d;
    })
  );


  var safeSetMinutes = defineValue(
    'name: safeSetMinutes',
    'signature: minutes: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setMinutes`. Takes a value between 0-59',
    'representing the minutes, and sets the given date\'s minutes to that value.',
    '',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    '--',
    'var a = new Date(2000, 1, 15, 10, 11, 12, 13);',
    'safeSetMinutes(61, a); // Throws',
    curry(function(val, d) {
      if (val < 0 || val > 59)
        throw new TypeError('Attempt to set minutes with invalid value: '+ val);

      d.setMinutes(val);
      return d;
    })
  );


  var safeSetMonth = defineValue(
    'name: safeSetMonth',
    'signature: m: month, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setMonth`. Takes a value between 0-11',
    'representing the month, and sets the given date\'s month to that value.',
    '  ',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    '--',
    'var a = new Date(2000, 1, 15, 10, 11, 12, 13);',
    'safeSetMinutes(13, a); // Throws',
    curry(function(val, d) {
      if (val < 0 || val > 11)
        throw new TypeError('Attempt to set month with invalid value: '+ val);

      d.setMonth(val);
      return d;
    })
  );


  var safeSetSeconds = defineValue(
    'name: safeSetSeconds',
    'signature: seconds: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setSeconds`. Takes a value between 0-59',
    'representing the seconds, and sets the given date\'s seconds to that value.',
    '',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    '--',
    'var a = new Date(2000, 1, 15, 10, 11, 12, 13);',
    'safeSetMinutes(61, a); // Throws',
    curry(function(val, d) {
      if (val < 0 || val > 59)
        throw new TypeError('Attempt to set seconds with invalid value: '+ val);

      d.setSeconds(val);
      return d;
    })
  );


  var safeSetUTCDayOfMonth = defineValue(
    'name: safeSetUTCDayOfMonth',
    'signature: day: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setDate`. Takes a value between 1 and 31, and a',
    '`Date` object and sets the day of the month to the local equivalent of the given',
    'value.',
    '',
    'Throws a TypeError if the value is outside this range, or if the month contains',
    'fewer days than the given value.',
    '',
    'Returns the given date.',
    curry(function(val, d) {
      if (val < 0 || val > 31)
        throw new TypeError('Attempt to set day with invalid value: '+ val);

      var month = getUTCMonth(d);
      if (val === 31 && [1, 3, 5, 8, 10].indexOf(month) !== -1)
        throw new TypeError('Attempt to set day with invalid value: '+ val);

      if (month === 2) {
        if (val === 30)
          throw new TypeError('Attempt to set day with invalid value: '+ val);

        if (val === 29) {
          var year = getUTCFullYear(d);
          var notLeapYear = (year % 4 !== 0) || (year % 100 === 0 && year % 400 !== 0);

          if (notLeapYear)
            throw new TypeError('Attempt to set day with invalid value: '+ val);
        }
      }

      d.setUTCDate(val);
      return d;
    })
  );


  var safeSetUTCHours = defineValue(
    'name: safeSetUTCHours',
    'signature: hours: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setUTCHours`. Takes a value between 0-23',
    'representing the hour of the day, and sets the hour to the local equivalent of',
    'the given value.',
    '',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    curry(function(val, d) {
      if (val < 0 || val > 23)
        throw new TypeError('Attempt to set hour with invalid value: '+ val);

      d.setUTCHours(val);
      return d;
    })
  );


  var safeSetUTCMilliseconds = defineValue(
    'name: safeSetUTCMilliseconds',
    'signature: milliseconds: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setUTCMilliseconds`. Takes a value between 0-999',
    'representing the milliseconds, and sets the milliseconds to the local equivalent',
    'of the given value.',
    '',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    curry(function(val, d) {
      if (val < 0 || val > 999)
        throw new TypeError('Attempt to set milliseconds with invalid value: '+ val);

      d.setUTCMilliseconds(val);
      return d;
    })
  );


  var safeSetUTCMinutes = defineValue(
    'name: safeSetUTCMinutes',
    'signature: minutes: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setUTCMinutes`. Takes a value between 0-59',
    'representing the minutes, and sets the given date\'s minutes to the local',
    'equivalent of that value.',
    '',
    'Throws a TypeError values outside this range.',
    '',
    'Returns the given date.',
    curry(function(val, d) {
      if (val < 0 || val > 59)
        throw new TypeError('Attempt to set minutes with invalid value: '+ val);

      d.setUTCMinutes(val);
      return d;
    })
  );


  var safeSetUTCMonth = defineValue(
    'name: safeSetUTCMonth',
    'signature: month: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setUTCMonth`. Takes a value between 0-11',
    'representing the month, and sets the given date\'s month to the local equivalent',
    'of that value.',
    '',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    curry(function(val, d) {
      if (val < 0 || val > 11)
        throw new TypeError('Attempt to set month with invalid value: '+ val);

      d.setUTCMonth(val);
      return d;
    })
  );


  var safeSetUTCSeconds = defineValue(
    'name: safeSetUTCSeconds',
    'signature: seconds: number, d: date',
    'classification: date',
    '',
    'A wrapper around `Date.prototype.setUTCSeconds`. Takes a value between 0-59',
    'representing the seconds, and sets the given date\'s seconds to the local',
    'equivalent of that value.',
    '',
    'Throws a TypeError for values outside this range.',
    '',
    'Returns the given date.',
    curry(function(val, d) {
      if (val < 0 || val > 59)
        throw new TypeError('Attempt to set seconds with invalid value: '+ val);

      d.setUTCSeconds(val);
      return d;
    })
  );
*/


  // Now we delve into the madness that is the Date constructor...
  // TODO Need better synonyms for these


  /*
   * <apifunction>
   *
   * getCurrentTimeString
   *
   * Category: Date
   *
   * Returns: string
   *
   * A wrapper around calling the Date constructor without the `new` operator. Returns a string representing the
   * current date and time.
   *
   */

  var getCurrentTimeString = curry(function() {
    return Date();
  });


  /*
   * <apifunction>
   *
   * makeDateFromString
   *
   * Category: Date
   *
   * Parameter: dateString: string
   * Returns: Date
   *
   * A wrapper around calling the `Date` constructor with a single string argument. Throws a TypeError when called with
   * a non-string argument, or a string that cannot be parsed as a date. Returns a new `Date` object whose value
   * represents that given in the string.
   *
   * Examples:
   *   var d = funkierJS.makeDateFromString('2000-01-01T10:00:01:000Z');
   *
   */

  var makeDateFromString = curry(function(s) {
    if (typeof(s) !== 'string')
      throw new TypeError('Attempt to make Date from string with incorrect type');

    var d = new Date(s);

    // If the string is not parsable, Date will still create a date!
    if (isNaN(d.getHours()))
      throw new TypeError('Attempt to make Date from unparsable string');

    return d;
  });


  /*
   * <apifunction>
   *
   * makeDateFromMilliseconds
   *
   * Category: Date
   *
   * Parameter: milliseconds: number
   * Returns: Date
   *
   * A wrapper around calling the Date constructor with a single numeric argument. Throws a TypeError when called with a
   * non-numeric argument. Returns a new `Date` object whose value represents the date which is that many elapsed
   * milliseconds since the epoch.
   *
   * Examples:
   *   var d = funkierJS.makeDateFromMilliseconds(1400161244101);
   *
   */

  var makeDateFromMilliseconds = curry(function(n) {
    if (typeof(n) !== 'number')
      throw new TypeError('Attempt to make Date from milliseconds with incorrect type');

    var d = new Date(n);

    // If the number isn't valid, a date will still be created!
    if (isNaN(d.getHours()))
      throw new TypeError('Attempt to make Date from invalid value');

    return d;
  });


  /*
   * <apifunction>
   *
   * makeMonthDate
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: month: number
   * Returns: Date
   *
   * A curried wrapper around calling the `Date` constructor with two arguments: the year and the month. No validation
   * or type-checking occurs on the parameters. Excess arguments are ignored. All other fields in the `Date` are
   * initialized to zero, with the exception of the day, which is initialized to 1. Returns the new `Date`.
   *
   * Examples:
   *   var d = funkierJS.makeMonthDate(2000, 0); // => A date representing January 1 2000
   *
   */

  var makeMonthDate = curry(function(y, m) {
    return new Date(y, m);
  });


  /*
   * <apifunction>
   *
   * makeDayDate
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: month: number
   * Parameter: day: number
   * Returns: Date
   *
   * A curried wrapper around calling the Date constructor with three arguments: the year, the month and the day. No
   * validation or type-checking occurs on the parameters. Excess arguments are ignored. All other fields in the `Date`
   * are initialized to zero. Returns the new `Date`.
   *
   * Examples:
   *   var d = funkierJS.makeDayDate(2000, 0, 2); // => A date representing January 2 2000
   *
   */

  var makeDayDate = curry(function(y, m, d) {
    return new Date(y, m, d);
  });


  /*
   * <apifunction>
   *
   * makeHourDate
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: month: number
   * Parameter: day: number
   * Parameter: hour: number
   * Returns: Date
   *
   * A curried wrapper around calling the `Date` constructor with four arguments: the year, the month, the day and the
   * hour. No validation or type-checking occurs on the parameters. Excess arguments are ignored. All other fields in
   * the `Date` are initialized to zero. Returns the new `Date`.
   *
   * Examples:
   *   var d = funkierJS.makeHourDate(2000, 0, 2, 10); // => A date representing 10am, January 2 2000
   *
   */

  var makeHourDate = curry(function(y, m, d, h) {
    return new Date(y, m, d, h);
  });


  /*
   * <apifunction>
   *
   * makeMinuteDate
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: month: number
   * Parameter: day: number
   * Parameter: hour: number
   * Parameter: minute: number
   * Returns: Date
   *
   * A curried wrapper around calling the `Date` constructor with five arguments: the year, the month, the day, the hour
   * and the minute. No validation or type-checking occurs on the parameters. Excess arguments are ignored. All other
   * fields in the `Date` are initialized to zero. Returns the new `Date`.
   *
   * Examples:
   *   var d = funkierJS.makeMinuteDate(2000, 0, 2, 10, 15); // => A date representing 10:15:00, January 2 2000
   *
   */

  var makeMinuteDate = curry(function(y, m, d, h, min) {
    return new Date(y, m, d, h, min);
  });


  /*
   * <apifunction>
   *
   * makeSecondDate
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: month: number
   * Parameter: day: number
   * Parameter: hour: number
   * Parameter: minute: number
   * Parameter: second: number
   * Returns: Date
   *
   * A curried wrapper around calling the `Date` constructor with six arguments: the year, the month, the day, the hour,
   * the minute, and the seconds. No validation or type-checking occurs on the parameters. Excess arguments are ignored.
   * All other fields in the `Date` are initialized to zero. Returns the new `Date`.
   *
   * Examples:
   *   var d = funkierJS.makeSecondDate(2000, 0, 2, 10, 15, 30); // => A date representing 10:15:30, January 2 2000
   *
   */

  var makeSecondDate = curry(function(y, m, d, h, min, s) {
    return new Date(y, m, d, h, min, s);
  });


  /*
   * <apifunction>
   *
   * makeMillisecondDate
   *
   * Category: Date
   *
   * Parameter: year: number
   * Parameter: month: number
   * Parameter: day: number
   * Parameter: hour: number
   * Parameter: minute: number
   * Parameter: second: number
   * Parameter: millisecond: number
   * Returns: Date
   *
   * A curried wrapper around calling the `Date` constructor with seven arguments: the year, the month, the day, the
   * hour, the minute, the seconds, and the milliseconds. No validation or type-checking occurs on the parameters.
   * Returns the new `Date`.
   *
   * Examples:
   *   var d = funkierJS.makeMillisecondDate(2000, 0, 2, 10, 15, 30, 12); // => A date representing 10:15:30:012,
   *                                                                      //    January 2 2000
   *
   */

  var makeMillisecondDate = curry(function(y, m, d, h, min, s, ms) {
    return new Date(y, m, d, h, min, s, ms);
  });


  return {
    getCurrentTimeString: getCurrentTimeString,
    getDayOfMonth: getDayOfMonth,
    getDayOfWeek: getDayOfWeek,
    getFullYear: getFullYear,
    getHours: getHours,
    getMilliseconds: getMilliseconds,
    getMinutes: getMinutes,
    getMonth: getMonth,
    getSeconds: getSeconds,
    getTimezoneOffset: getTimezoneOffset,
    getUTCDayOfMonth: getUTCDayOfMonth,
    getUTCDayOfWeek: getUTCDayOfWeek,
    getUTCFullYear: getUTCFullYear,
    getUTCHours: getUTCHours,
    getUTCMilliseconds: getUTCMilliseconds,
    getUTCMinutes: getUTCMinutes,
    getUTCMonth: getUTCMonth,
    getUTCSeconds: getUTCSeconds,
    makeDateFromMilliseconds: makeDateFromMilliseconds,
    makeDateFromString: makeDateFromString,
    makeDayDate: makeDayDate,
    makeHourDate: makeHourDate,
    makeMinuteDate: makeMinuteDate,
    makeMillisecondDate: makeMillisecondDate,
    makeMonthDate: makeMonthDate,
    makeSecondDate: makeSecondDate,
/* TBC
    safeSetDayOfMonth: safeSetDayOfMonth,
    safeSetHours: safeSetHours,
    safeSetMilliseconds: safeSetMilliseconds,
    safeSetMinutes: safeSetMinutes,
    safeSetMonth: safeSetMonth,
    safeSetSeconds: safeSetSeconds,
    safeSetUTCDayOfMonth: safeSetUTCDayOfMonth,
    safeSetUTCHours: safeSetUTCHours,
    safeSetUTCMilliseconds: safeSetUTCMilliseconds,
    safeSetUTCMinutes: safeSetUTCMinutes,
    safeSetUTCMonth: safeSetUTCMonth,
    safeSetUTCSeconds: safeSetUTCSeconds,
*/
    setDayOfMonth: setDayOfMonth,
    setFullYear: setFullYear,
    setHours: setHours,
    setMilliseconds: setMilliseconds,
    setMinutes: setMinutes,
    setMonth: setMonth,
    setSeconds: setSeconds,
    setTimeSinceEpoch: setTimeSinceEpoch,
    setUTCDayOfMonth: setUTCDayOfMonth,
    setUTCFullYear: setUTCFullYear,
    setUTCHours: setUTCHours,
    setUTCMilliseconds: setUTCMilliseconds,
    setUTCMinutes: setUTCMinutes,
    setUTCMonth: setUTCMonth,
    setUTCSeconds: setUTCSeconds,
    toDateString: toDateString,
    toEpochMilliseconds: toEpochMilliseconds,
    toISOString: toISOString,
    toLocaleDateString: toLocaleDateString,
    toTimeString: toTimeString,
    toUTCString: toUTCString
  };
})();

},{"./curry":13,"./object":19}],15:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;
  var arityOf = curryModule.arityOf;
  var curryWithConsistentStyle = curryModule._curryWithConsistentStyle;

  var internalUtilities = require('../internalUtilities');
  var checkArrayLike = internalUtilities.checkArrayLike;
  var checkPositiveIntegral = internalUtilities.checkPositiveIntegral;
  var checkObjectLike = internalUtilities.checkObjectLike;

  var funcUtils = require('../funcUtils');
  var checkFunction = funcUtils.checkFunction;


  /*
   * <apifunction>
   *
   * apply
   *
   * Category: function
   *
   * Parameter: args: array
   * Parameter: f: function
   * Returns: any
   *
   * Applies the given function f with the arguments given in the array args. If the function is not curried, it will be
   * curried (using [`curry`](#curry)) and partially applied if necessary. If the function is object curried, and has
   * not yet acquired an execution context, then it will be invoked with a null execution context (as `apply` is itself
   * curried, and so will have no visibility into the execution context it was invoked with). The result of applying the
   * given arguments to the function is returned.  Throws a TypeError if args is not an array, or if f is not a
   * function.
   *
   * Examples:
   *   funkierJS.apply([1], id); // 1
   */

  var apply = curry(function(args, f) {
    f = checkFunction(f);
    args = checkArrayLike(args, {noStrings: true, message: 'Function arguments not an array'});
    f = curryWithConsistentStyle(f, f, arityOf(f));

    return f.apply(null, args);
  });


  /*
   * <apifunction>
   *
   * permuteLeft
   *
   * Category: function
   *
   * Synonyms: rotateLeft
   *
   * Parameter: f: function
   * Returns: function
   *
   * Takes a function, returns a curried function of the same arity which takes the same parameters, except in a
   * different position. The first parameter of the original function will be the last parameter of the new function,
   * the second parameter of the original will be the first parameter of the new function and so on. This function is
   * essentially a no-op for curried functions of arity 0 and 1, equivalent to [`curry`](#curry) for uncurried
   * functions of arities 0 and 1, and equivalent to flip for functions of arity 2.
   *
   * If f is already curried, the currying style of f will be preserved.
   *
   * Throws a TypeError if f is not a function.
   *
   * Examples:
   *   f = function(x, y, z) {return x + y + z;};
   *   g = permuteLeft(f);
   *   g('a', 'b', 'c'); // => 'bca'
   *
   */

  var permuteLeft = curry(function(f) {
    var fLen = arityOf(f);
    f = curryWithConsistentStyle(f, f, fLen);

    if (fLen < 2)
      return f;

    return curryWithConsistentStyle(f, function() {
      var args = [].slice.call(arguments);
      var newArgs = [args[fLen - 1]].concat(args.slice(0, fLen - 1));
      return f.apply(this, newArgs);
    }, fLen);
  });


  /*
   * <apifunction>
   *
   * permuteRight
   *
   * Category: function
   *
   * Synonyms: rotateRight
   *
   * Parameter: f: function
   * Returns: function
   *
   * Takes a function, returns a curried function of the same arity which takes the same parameters, except in a
   * different position. The first parameter of the original function will be the second parameter of the new function,
   * the second parameter of the original will be the third parameter of the new function and so on. This function is
   * essentially a no-op for curried functions of arity 0 and 1, equivalent to [`curry`](#curry) for uncurried
   * functions of arities 0 and 1, and equivalent to flip for functions of arity 2.
   *
   * If f is already curried, the currying style of f will be preserved.
   *
   * Throws a TypeError if f is not a function.
   *
   * Examples:
   *   f = function(x, y, z) {return x + y + z;};
   *   g = permuteLeft(f);
   *   g('a', 'b', 'c'); // => 'cab'
   *
   */

  var permuteRight = curry(function(f) {
    var fLen = arityOf(f);
    f = curryWithConsistentStyle(f, f, fLen);

    if (fLen < 2)
      return f;

    return curryWithConsistentStyle(f, function() {
      var args = [].slice.call(arguments);
      var newArgs = args.slice(1).concat([args[0]]);
      return f.apply(this, newArgs);
    }, fLen);
  });


  /*
   * <apifunction>
   *
   * pre
   *
   * Category: function
   *
   * Parameter: wrappingFunction: function
   * Parameter: f: function
   * Returns: function
   *
   * Takes two functions wrappingFunction, and f, and returns a new function with the same arity as the function f,
   * and curried in the same manner (or curried with [`curry`](#curry) if f was not curried). When this new function
   * is called, it will first call wrappingFunction, with the same execution context, and a single argument: an array
   * containing all the arguments the function was called with. When wrappingFunction returns, its return value
   * will be discarded, and f will be called with the same execution context and invoked with the same arguments as the
   * new function was invoked with. The return value from f will be returned.
   *
   * Throws a TypeError if neither of the given values are functions.
   *
   * Examples:
   *   var logger = function(args) {console.log('plus called with ', args.join(', '));};
   *   var loggedPlus = pre(logger, plus);
   *   loggedPlus(2, 2); // => outputs 'plus called with 2, 2' to console
   *
   */

  var pre = curry(function(wrappingFunction, f) {
    wrappingFunction = checkFunction(wrappingFunction, {message: 'Pre value must be a function'});
    f = checkFunction(f, {message: 'Value to be wrapped must be a function'});

    return curryWithConsistentStyle(f, function() {
      var args = [].slice.call(arguments);
      wrappingFunction.call(this, args);
      return f.apply(this, args);
    }, arityOf(f));
  });


  /*
   * <apifunction>
   *
   * post
   *
   * Category: function
   *
   * Parameter: wrappingFunction: function
   * Parameter: f: function
   * Returns: function
   *
   * Takes two functions wrappingFunction, and f, and returns a new function with the same arity as the function f,
   * and curried in the same manner (or curried with [`curry`](#curry) if f was not curried). When this new function
   * is called, it will first call f with the same execution context and arguments that the new function was called
   * with. Its return value will be saved. Next, wrappingFunction will be called, again with the same execution
   * context, and two arguments: an array containing the arguments to f, and f's return value. Anything returned from
   * wrappingFunction will be discarded, and f's return value will be returned.
   *
   * Throws a TypeError if either of the given values are not functions.
   *
   * Examples:
   *   var postLogger = function(args, result) {console.log('plus called with ', args.join(', '), 'returned', result);};
   *   var loggedPlus = post(postLogger, plus);
   *   loggedPlus(2, 2); // => outputs 'plus called with 2, 2 returned 4' to console
   *
   */

  var post = curry(function(wrappingFunction, f) {
    wrappingFunction = checkFunction(wrappingFunction, {message: 'Post value must be a function'});
    f = checkFunction(f, {message: 'Value to be wrapped must be a function'});

    return curryWithConsistentStyle(f, function() {
      var args = [].slice.call(arguments);
      var result = f.apply(this, args);
      wrappingFunction.call(this, args, result);
      return result;
    }, arityOf(f));
  });


  /*
   * <apifunction>
   *
   * wrap
   *
   * Category: function
   *
   * Parameter: before: function
   * Parameter: after: function
   * Parameter: f: function
   *
   * Returns: function
   *
   * Takes 3 functions, before, after and f. Returns a new function with the same arity as f, and curried in the same
   * manner (or curried using [`curry`](#curry) if f was not curried. The functions before, f, and after will be called
   * when the returned function is invoked.
   *
   * Specifically, when the returned function is called, the following will happen in sequence:
   *   -  before will be called with the execution context of the new function and one argument: an array containing
   *      the arguments the new function was invoked with
   *
   *   -  f will be called with the execution context that the new function was called with, and the same arguments
   *
   *   -  after will be called with the original execution context and two arguments: an array containing the arguments
   *      the new function was called with, and f's result
   *
   *   -  f's result will be returned
   *
   * Throws a TypeError if any argument is not a function.
   *
   * This function is equivalent to calling [`post`](#post) and [`pre`](#pre) on some function.
   *
   * Examples:
   *   var logger = function(args) {console.log('plus called with ', args.join(', '));};
   *   var postLogger = function(args, result) {console.log('plus returned', result);};
   *   var loggedPlus = wrap(logger, postLogger, plus);
   *   loggedPlus(2, 2); // => outputs 'plus called with 2, 2' and 'plus returned 4' to console
   *
   */

  var wrap = curry(function(before, after, f) {
    return post(after, pre(before, f));
  });


  return {
    apply: apply,
    permuteLeft: permuteLeft,
    permuteRight: permuteRight,
    pre: pre,
    post: post,
    rotateLeft: permuteLeft,
    rotateRight: permuteRight,
    wrap: wrap
  };
})();

},{"../funcUtils":24,"../internalUtilities":27,"./curry":13}],16:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var chooseCurryStyle = curryModule._chooseCurryStyle;
  var curryWithConsistentStyle = curryModule._curryWithConsistentStyle;

  var funcUtils = require('../funcUtils');
  var checkFunction = funcUtils.checkFunction;


  /*
   * <apifunction>
   *
   * not
   *
   * Category: Logical
   *
   * Parameter: b: boolean
   * Returns: boolean
   *
   * A wrapper around the logical not (!) operator. Returns the logical negation of the given argument.
   *
   * Examples:
   *
   *   funkierJS.not(true); // => false
   *
   */

  var not = curry(function(b) {
    return !b;
  });


  /*
   * <apifunction>
   *
   * and
   *
   * Category: Logical
   *
   * Parameter: x: boolean
   * Parameter: y: boolean
   * Returns: boolean
   *
   * A wrapper around the logical and (&&) operator. Returns the logical and of the given arguments
   *
   * Examples:
   *
   *   funkierJS.and(true, true); // => true
   *
   */

  var and = curry(function(x, y) {
    return x && y;
  });


  /*
   * <apifunction>
   *
   * or
   *
   * Category: Logical
   *
   * Parameter: x: boolean
   * Parameter: y: boolean
   * Returns: boolean
   *
   * A wrapper around the logical or (||) operator. Returns the logical or of the given arguments
   *
   * Examples:
   *
   *   funkierJS.or(true, false); // => true
   *
   */

  var or = curry(function(x, y) {
    return x || y;
  });


  /*
   * <apifunction>
   *
   * xor
   *
   * Category: Logical
   *
   * Parameter: x: boolean
   * Parameter: y: boolean
   * Returns: boolean
   *
   * A wrapper around the logical xor operator. Returns the logical xor of the given arguments
   *
   * Examples:
   *
   *   funkierJS.xor(true, true); // => false
   *
   */

  var xor = curry(function(x, y) {
    return x ? x !== y : y;
  });


  /*
   * <apifunction>
   *
   * notPred
   *
   * Category: Logical
   *
   * Parameter: f: function
   * Returns: function
   *
   * Takes a unary predicate function, and returns a new unary function that, when called, will call the original
   * function with the given argument, and return the negated result. Throws if f is not a function, or has an
   * arity other than 1.
   *
   * If the supplied predicate has been previously curried, then the resulting function will replicate the currying
   * style. In particular, if the original function was curried with one of the [`objectCurry'](#objectCurry) variants,
   * then the resulting function will be too, and where necessary will supply the execution context to the wrapped
   * function.
   *
   * Examples:
   *  var c = funkierJS.constant(true);',
   *  var f = funkierJS.notPred(c);',
   *  f("foo"); // => false',
   *
   */

  var notPred = curry(function(pred) {
    pred = checkFunction(pred, {arity: 1, message: 'Predicate must be a function of arity 1'});

    return curryWithConsistentStyle(pred, function(x) {
      return !pred.call(this, x);
    });
  });


  /*
   * <apifunction>
   *
   * andPred
   *
   * Category: Logical
   *
   * Parameter: f1: function
   * Parameter: f2: function
   * Returns: function
   *
   * Takes two unary predicate functions, and returns a new unary function that, when called, will call the original
   * functions with the given argument, and logically and their results, returning that value. Throws if either
   * argument is not a function of arity 1.
   *
   * Where possible, funkierJS will aim to replicate the currying style of the function. If either function was
   * produced by one of the [`objectCurry'](#objectCurry) variants, then the resulting function will also be object
   * curried, and supply the correct execution context to the supplied functions. If neither was curried in that
   * manner, but one or more was curried with one of the [`bind`](#bind) variants, then the resulting function will
   * also be bound to the same context. Otherwise, the function will be curried with [`curry`]. (This is only provided
   * in case you need to give the resulting function to one of the `withArity` functions to change the arity).
   *
   * Examples:
   *  var c = funkierJS.constant(true);',
   *  var d = funkierJS.constant(false);',
   *  var f = funkierJS.andPred(c, d);',
   *  f("foo"); // => false',
   *
   */

  var andPred = curry(function(pred1, pred2) {
    pred1 = checkFunction(pred1, {arity: 1, message: 'First predicate must be a function of arity 1'});
    pred2 = checkFunction(pred2, {arity: 1, message: 'Second predicate must be a function of arity 1'});

    return chooseCurryStyle(pred1, pred2, function(x) {
      return pred1.call(this, x) && pred2.call(this, x);
    });
  });


  /*
   * <apifunction>
   *
   * orPred
   *
   * Category: Logical
   *
   * Parameter: f1: function
   * Parameter: f2: function
   * Returns: function
   *
   * Takes two unary predicate functions, and returns a new unary function that, when called, will call the original
   * functions with the given argument, and logically or their results, returning that value. Throws if either
   * argument is not a function of arity 1.
   *
   * Where possible, funkierJS will aim to replicate the currying style of the function. If either function was
   * produced by one of the [`objectCurry'](#objectCurry) variants, then the resulting function will also be object
   * curried, and supply the correct execution context to the supplied functions. If neither was curried in that
   * manner, but one or more was curried with one of the [`bind`](#bind) variants, then the resulting function will
   * also be bound to the same context. Otherwise, the function will be curried with [`curry`]. (This is only provided
   * in case you need to give the resulting function to one of the `withArity` functions to change the arity).
   *
   * Examples:
   *  var c = funkierJS.constant(true);',
   *  var d = funkierJS.constant(false);',
   *  var f = funkierJS.andPred(c, d);',
   *  f("foo"); // => true',
   *
   */

  var orPred = curry(function(pred1, pred2) {
    pred1 = checkFunction(pred1, {arity: 1, message: 'First predicate must be a function of arity 1'});
    pred2 = checkFunction(pred2, {arity: 1, message: 'Second predicate must be a function of arity 1'});

    return chooseCurryStyle(pred1, pred2, function(x) {
      return pred1.call(this, x) || pred2.call(this, x);
    });
  });


  /*
   * <apifunction>
   *
   * xorPred
   *
   * Category: Logical
   *
   * Parameter: f1: function
   * Parameter: f2: function
   * Returns: function
   *
   * Takes two unary predicate functions, and returns a new unary function that, when called, will call the original
   * functions with the given argument, and logically xor their results, returning that value. Throws if either
   * argument is not a function of arity 1.
   *
   * Where possible, funkierJS will aim to replicate the currying style of the function. If either function was
   * produced by one of the [`objectCurry'](#objectCurry) variants, then the resulting function will also be object
   * curried, and supply the correct execution context to the supplied functions. If neither was curried in that
   * manner, but one or more was curried with one of the [`bind`](#bind) variants, then the resulting function will
   * also be bound to the same context. Otherwise, the function will be curried with [`curry`]. (This is only provided
   * in case you need to give the resulting function to one of the `withArity` functions to change the arity).
   *
   * Examples:
   *  var c = funkierJS.constant(true);',
   *  var d = funkierJS.constant(true);',
   *  var f = funkierJS.xorPred(c, d);',
   *  f("foo"); // false',
   *
   */

  var xorPred = curry(function(pred1, pred2) {
    pred1 = checkFunction(pred1, {arity: 1, message: 'First predicate must be a function of arity 1'});
    pred2 = checkFunction(pred2, {arity: 1, message: 'Second predicate must be a function of arity 1'});

    return chooseCurryStyle(pred1, pred2, function(x) {
      return xor(pred1.call(this, x), pred2.call(this, x));
    });
  });


  return {
    and: and,
    andPred: andPred,
    not: not,
    notPred: notPred,
    or: or,
    orPred: orPred,
    xor: xor,
    xorPred: xorPred
  };
})();

},{"../funcUtils":24,"./curry":13}],17:[function(require,module,exports){
module.exports = (function() {
"use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;

  var base = require('./base');
  var flip = base.flip;

  var object = require('./object');
  var callProp = object.callProp;
  var callPropWithArity = object.callPropWithArity;


  /*
   * <apifunction>
   *
   * add
   *
   * Category: maths
   *
   * Synonyms: plus
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the addition operator.
   *
   * Examples:
   *   funkierJS.add(1, 1); // => 2
   *
   */

  var add = curry(function(x, y) {
    return x + y;
  });


  /*
   * <apifunction>
   *
   * subtract
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the subtraction operator.
   *
   * Examples:
   *   funkierJS.subtract(3, 1); // => 2;
   *
   */

  var subtract = curry(function(x, y) {
    return x - y;
  });


  /*
   * <apifunction>
   *
   * multiply
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the multiplication operator.
   *
   * Examples:
   *   funkierJS.multiply(2, 2); // => 4;
   *
   */

  var multiply = curry(function(x, y) {
    return x * y;
  });


  /*
   * <apifunction>
   *
   * divide
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the division operator.
   *
   * Examples:
   *   funkierJS.arityOf(4, 2); // => 2;
   *
   */

  var divide = curry(function(x, y) {
    return x / y;
  });


  /*
   * <apifunction>
   *
   * exp
   *
   * Category: maths
   *
   * Synonyms: pow
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A curried wrapper around Math.pow.
   *
   * Examples:
   *   funkierJS.exp(2, 3); // => 8
   *
   */

  var exp = curry(function(x, y) {
    return Math.pow(x, y);
  });


  /*
   * <apifunction>
   *
   * log
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * Returns the logarithm of y in the given base x. Note that this function uses the change of base formula, so may
   * be subject to rounding errors.
   *
   * Examples:
   *   funkierJS.log(2, 8); // => 3;
   *
   */

  var log = curry(function(x, y) {
    return Math.log(y) / Math.log(x);
  });



  /*
   * <apifunction>
   *
   * div
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * Returns the quotient on dividing x by y.
   *
   * Examples:
   *   funkierJS.div(5, 2); // => 2
   *
   */

  var div = curry(function(x, y) {
    return Math.floor(x / y);
  });


  /*
   * <apifunction>
   *
   * rem
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the remainder (%) operator.
   *
   * Examples:
   *   funkierJS.rem(5, 2); // => 1;
   *
   */

  var rem = curry(function(x, y) {
    return x % y;
  });



  /*
   * <apifunction>
   *
   * lessThan
   *
   * Category: maths
   *
   * Synonyms: lt
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: boolean
   *
   * A wrapper around the less than (<) operator.
   *
   * Examples:
   *   funkierJS.lessThan(5, 2); // => false;
   *
   */

  var lessThan = curry(function(x, y) {
    return x < y;
  });


  /*
   * <apifunction>
   *
   * lessThanEqual
   *
   * Category: maths
   *
   * Synonyms: lte
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: boolean
   *
   * A wrapper around the less than or equal (<=) operator.
   *
   * Examples:
   *   funkierJS.lessThanEqual(2, 2); // => true;
   *
   */

  var lessThanEqual = curry(function(x, y) {
    return x <= y;
  });


  /*
   * <apifunction>
   *
   * greaterThan
   *
   * Category: maths
   *
   * Synonyms: gt
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: boolean
   *
   * A wrapper around the less than or equal (<=) operator.
   *
   * Examples:
   *   funkierJS.greaterThan(5, 2); // => true;
   *
   */

  var greaterThan = curry(function(x, y) {
    return x > y;
  });


  /*
   * <apifunction>
   *
   * greaterThanEqual
   *
   * Category: maths
   *
   * Synonyms: gte
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: boolean
   *
   * A wrapper around the greater than or equal (=>) operator.
   *
   * Examples:
   *   funkierJS.greaterThanEqual(2, 2); // => true;
   *
   */

  var greaterThanEqual = curry(function(x, y) {
    return x >= y;
  });


  /*
   * <apifunction>
   *
   * leftShift
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the left shift (<<) operator.
   *
   * Examples:
   *   funkierJS.leftShift(1, 2); // => 4;
   *
   */

  var leftShift = curry(function(x, y) {
    return x << y;
  });


  /*
   * <apifunction>
   *
   * rightShift
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the right shift (>>) operator.
   *
   * Examples:
   *   funkierJS.rightShift(-4, 2); // => -1;
   *
   */

  var rightShift = curry(function(x, y) {
    return x >> y;
  });


  /*
   * <apifunction>
   *
   * rightShiftZero
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the left shift (>>>) operator.
   *
   * Examples:
   *   funkierJS.rightShiftZero(-4, 2); // => 1073741823;
   *
   */

  var rightShiftZero = curry(function(x, y) {
    return x >>> y;
  });


  /*
   * <apifunction>
   *
   * bitwiseAnd
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the bitwise and (&) operator.
   *
   * Examples:
   *   funkierJS.bitwiseAnd(7, 21); // => 5;
   *
   */

  var bitwiseAnd = curry(function(x, y) {
    return x & y;
  });


  /*
   * <apifunction>
   *
   * bitwiseOr
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the bitwise or (&) operator.
   *
   * Examples:
   *   funkierJS.bitwiseOr(7, 8); // => 15;
   *
   */

  var bitwiseOr = curry(function(x, y) {
    return x | y;
  });


  /*
   * <apifunction>
   *
   * bitwiseXor
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A wrapper around the bitwise xor (^) operator.
   *
   * Examples:
   *   funkierJS.bitwiseAnd(7, 3); // => 4;
   *
   */


  var bitwiseXor = curry(function(x, y) {
    return x ^ y;
  });


  /*
   * <apifunction>
   *
   * bitwiseNot
   *
   * Category: maths
   *
   * Parameter: x: number
   * Returns: number
   *
   * A wrapper around the bitwise not (~) operator.
   *
   * Examples:
   *   funkierJS.bitwiseNot(5); // => -6;
   *
   */

  var bitwiseNot = curry(function(x) {
    return ~x;
  });


  /*
   * <apifunction>
   *
   * min
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A curried wrapper around `Math.min`. Takes exactly two arguments.
   *
   * Examples:
   *   funkierJS.min(5, 2); // => 2;
   *
   */

  // min has a spec mandated length of 2, so we calling curry will do the right thing
  var min = curry(Math.min);


  /*
   * <apifunction>
   *
   * max
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: number
   *
   * A curried wrapper around `Math.max`. Takes exactly two arguments.
   *
   * Examples:
   *   funkierJS.min(5, 2); // => 5;
   *
   */

  // max has a spec mandated length of 2, so we can simply curry
  var max = curry(Math.max);


  /*
   * <apifunction>
   *
   * toFixed
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: string
   *
   * A curried wrapper around `Number.prototype.toFixed`. Takes the number of digits after the decimal point (which
   * should be between 0 and 20), and a number. Returns a string representing the number but with the specified number
   * of places after the decimal point.
   *
   * Examples:
   *   funkierJS.toFixed(2, 1); // => "1.00"
   *
   */

  var toFixed = callPropWithArity('toFixed', 1);


  /*
   * <apifunction>
   *
   * toExponential
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: string
   *
   * A curried wrapper around `Number.prototype.toExponential`. Takes the number of digits after the decimal point
   * (which should be between 0 and 20), and a number. Returns a string representing the number in exponential notation,
   * with the specified number of places after the decimal point.
   *
   * Examples:
   *   funkierJS.toExponential(3, 1); // => "1.000e+0"
   *
   */

  var toExponential = callPropWithArity('toExponential', 1);


  /*
   * <apifunction>
   *
   * toPrecision
   *
   * Category: maths
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: string
   *
   * A curried wrapper around `Number.prototype.toPrecision`. Takes the number of digits significant digits (which
   * should be between 1 and 21), and a number. Returns a string representing the number with the specified number
   * of significant digits.
   *
   * Examples:
   *   funkierJS.toPrecision(3, 1); // => "1.000"
   *
   */

  var toPrecision = callPropWithArity('toPrecision', 1);


  /*
   * <apifunction>
   *
   * toBaseAndString
   *
   * Category: maths
   *
   * Synonyms: toBaseAndRadix
   *
   * Parameter: x: number
   * Parameter: y: number
   * Returns: string
   *
   * A curried wrapper around `Number.prototype.toString`. Takes a base between 2 and 36, and a number. Returns a string
   * representing the given number in the given base.
   *
   * Examples:
   *   funkierJS.toBaseAndString(2, 5); // => "101"
   *
   */

  var toBaseAndString = callPropWithArity('toString', 1);


  /*
   * <apifunction>
   *
   * parseInt
   *
   * Category: maths
   *
   * Parameter: s: string
   * Returns: number
   *
   * A curried wrapper around parseInt when called with one argument. Takes a string and attempts to convert it
   * assuming it represents a number in base 10. Returns `NaN` if the string does not represent a valid number in base
   * 10.
   *
   * Examples:
   *   funkierJS.parseInt(101); // => 101
   *
   */

  var stringToInt = flip(parseInt);


  /*
   * <apifunction>
   *
   * stringToInt
   *
   * Category: maths
   *
   * Synonyms: parseIntInBase
   *
   * Parameter: base: number
   * Parameter: s: string
   * Returns: number
   *
   * A curried wrapper around parseInt when called with two arguments. Takes a base between 2 and 36, and a string, and
   * attempts to convert the string assuming it represents a number in the given base. Returns NaN if the string does
   * not represent a valid number in the given base.
   *
   * Examples:
   *   funkierJS.stringToInt(16, "80"); // => 128
   *
   */

  // Deliberate name-mangling to avoid shadowing the global
  var parseint = curryWithArity(1, parseInt);


  /*
   * <apifunction>
   *
   * even
   *
   * Category: maths
   *
   * Parameter: x: number
   * Returns: boolean
   *
   * Given a number, returns true if it is divisible by 2, and false otherwise.
   *
   * Examples:
   *   funkierJS.even(2); // => true
   *   funkierJS.even(3); // => false
   *
   */


  var even = curry(function(n) {
    return n % 2 === 0;
  });


  /*
   * <apifunction>
   *
   * odd
   *
   * Category: maths
   *
   * Parameter: x: number
   * Returns: boolean
   *
   * Given a number, returns true if it is not divisible by 2, and false otherwise.
   *
   * Examples:
   *   funkierJS.odd(2); // => false
   *   funkierJS.odd(3); // => true
   *
   */

  var odd = curry(function(n) {
    return n % 2 !== 0;
  });


  return {
    add: add,
    bitwiseAnd: bitwiseAnd,
    bitwiseNot: bitwiseNot,
    bitwiseOr: bitwiseOr,
    bitwiseXor: bitwiseXor,
    div: div,
    divide: divide,
    even: even,
    exp: exp,
    greaterThan: greaterThan,
    greaterThanEqual: greaterThanEqual,
    gt: greaterThan,
    gte: greaterThanEqual,
    leftShift: leftShift,
    lessThan: lessThan,
    lessThanEqual: lessThanEqual,
    lt: lessThan,
    lte: lessThanEqual,
    log: log,
    min: min,
    max: max,
    multiply: multiply,
    odd: odd,
    parseInt: parseint,
    parseIntInBase: stringToInt,
    plus: add,
    pow: exp,
    rem: rem,
    rightShift: rightShift,
    rightShiftZero: rightShiftZero,
    stringToInt: stringToInt,
    subtract: subtract,
    toBaseAndRadix: toBaseAndString,
    toBaseAndString: toBaseAndString,
    toExponential: toExponential,
    toFixed: toFixed,
    toPrecision: toPrecision
  };
})();

},{"./base":11,"./curry":13,"./object":19}],18:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var curryWithConsistentStyle = curryModule._curryWithConsistentStyle;
  var arityOf = curryModule.arityOf;

  var internalUtilities = require('../internalUtilities');
  var valueStringifier = internalUtilities.valueStringifier;

  var funcUtils = require('../funcUtils');
  var checkFunction = funcUtils.checkFunction;


  /*
   * Maybe encapsulates the idea of sentinel values returned by functions to represent an error or unusual condition.
   * Authors can return an instance of the Just constructor when a function runs successfully, and the Nothing object
   * when an error occurs or the computation is otherwise unsuccessful.
   */


  /*
   * <apifunction>
   *
   * Maybe
   *
   * Category: DataTypes
   *
   * The Maybe type encapsulates the idea of sentinel values returned by functions to represent an error or unusual
   * conditions. Authors can return an instance of the Just constructor when a function executes successfully, and the
   * Nothing object when an error occurs, or the computation is otherwise unsuccessful.
   *
   * Maybe is the 'base class' of [`Just`](#Just) and [`Nothing`](#Nothing). It is provided only for the instanceof
   * operator.
   *
   * It is an error to call Maybe.
   *
   */

  var Maybe = curry(function() {
    throw new Error('Maybe cannot be instantiated directly');
  });


  Maybe.prototype = {toString: function() {return 'Maybe';}, constructor: Maybe};

  var nothingPrototype = Object.create(Maybe.prototype);
  nothingPrototype.toString = function() {return 'Maybe {Nothing}';};


  /*
   * <apiobject>
   *
   * Nothing
   *
   * Category: DataTypes
   *
   * A Nothing is a type of [`Maybe`](#Maybe) representing an unsuccessful computation.
   *
   */

  var Nothing = Object.create(nothingPrototype);
  Object.freeze(Nothing);


  /*
   * <apifunction>
   *
   * Just
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: Just
   *
   * A Just is a type of [`Maybe`](#Maybe) representing a successful computation. The constructor is new-agnostic.
   * Throws when called with no arguments.
   *
   * Examples:
   *   var result = funkierJS.Just(42);
   *
   */

  var Just = function(val) {
    if (arguments.length !== 1)
      throw new TypeError('Just called with incorrect number of arguments');

    if (!(this instanceof Just))
      return new Just(val);

    Object.defineProperty(this, 'value', {value: val});
  };


  Just.prototype = Object.create(Maybe.prototype);
  Just.prototype.toString = function() {
    return 'Maybe {Just ' + valueStringifier(this.value) + '}';
  };


  /*
   * <apifunction>
   *
   * isMaybe
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true when the given value is a [`Maybe`](#Maybe) object, and false otherwise.
   *
   * Examples:
   *   funkierJS.isMaybe(funkierJS.Nothing) && funkierJS.isMaybe(funkierJS.Just(42)); // => true
   *
   */

  var isMaybe = curry(function(val) {
    return val === Maybe || val instanceof Maybe;
  });


  /*
   * <apifunction>
   *
   * isNothing
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if the given value is the [`Nothing`](#Nothing) object, and false otherwise.
   *
   * Examples:
   *   funkierJS.isNothing(funkierJS.Nothing); // => true
   *
   */

  var isNothing = curry(function(val) {
    return val === Nothing;
  });


  /*
   * <apifunction>
   *
   * isJust
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if the given value is a [`Just`](#Just) object, and false otherwise.
   *
   * Examples:
   *   funkierJS.isJust(funkierJS.Just(42)); // => true
   *
   */

  var isJust = curry(function(val) {
    return val instanceof Just;
  });


  /*
   * <apifunction>
   *
   * getJustValue
   *
   * Category: DataTypes
   *
   * Parameter: j: Just
   * Returns: any
   *
   * Returns the value wrapped by the given [`Just`](#Just) instance j. Throws a TypeError if called with anything other
   * than a [`Just`](#Just).
   *
   * Examples:
   *   funkierJS.getJustValue(funkierJS.Just(3)); // => 3',
   *
   */

  var getJustValue = curry(function(j) {
    if (!isJust(j))
      throw new TypeError('Value is not a Just');

    return j.value;
  });


  /*
   * <apifunction>
   *
   * makeMaybeReturner
   *
   * Category: DataTypes
   *
   * Parameter: f: function
   * Returns: function
   *
   * Takes a function f. Returns a new function with the same arity as f. When called, the new function calls the
   * original. If the function f throws during execution, then the Nothing object is returned. Otherwise the result of
   * the function is wrapped in a [`Just`](#Just) and returned.
   *
   * The function will be curried in the same style as the original, or using [`curry`](#curry) if the function was not
   * curried.
   *
   * Examples:
   *   var g = function(x) {
   *     if (x < 10)
   *       throw new Error('Bad value');
   *     return x;
   *   };
   *
   *   var f = funkierJS.makeMaybeReturner(g);
   *   f(11); // => Just(11)
   *   f(5); // => Nothing
   *
   */

  var makeMaybeReturner = curry(function(f) {
    f = checkFunction(f, {message: 'Value to be transformed must be a function'});

    return curryWithConsistentStyle(f, function() {
      var args = [].slice.call(arguments);

      try {
        var result = f.apply(this, arguments);
        return Just(result);
      } catch (e) {
        return Nothing;
      }
    }, arityOf(f));
  });


  return {
    getJustValue: getJustValue,
    isJust: isJust,
    isMaybe: isMaybe,
    isNothing: isNothing,
    makeMaybeReturner: makeMaybeReturner,
    Just: Just,
    Maybe: Maybe,
    Nothing: Nothing
  };
})();

},{"../funcUtils":24,"../internalUtilities":27,"./curry":13}],19:[function(require,module,exports){
module.exports = (function() {
  "use strict";
  /* jshint -W001 */


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;
  var objectCurry = curryModule.objectCurry;


  var base = require('./base');
  var flip = base.flip;


  var maybe = require('./maybe');
  var Just = maybe.Just;
  var Nothing = maybe.Nothing;


  var internalUtilities = require('../internalUtilities');
  var checkObjectLike = internalUtilities.checkObjectLike;


  /*
   * <apifunction>
   *
   * callPropWithArity
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: arity: natural
   * Returns: function
   *
   * Given a property name and an arity, returns a curried function taking arity + 1 arguments. The new function
   * requires all the original arguments in their original order, and an object as its final parameter. The returned
   * function will then try to call the named property on the given object,
   *
   * Note that the function is curried in the standard sense. In particular the function is not object curried.
   *
   * Examples:
   *   var myMap = funkierJS.callPropWithArity('map', 1);
   *   myMap(f, arr); // => returns arr.map(f);
   *
   *   var myFoldr = funkierJS.callPropWithArity('reduceRight', 2);
   *   myFoldr(f, initialValue, arr); // => arr.reduceRight(f, initialValue);
   *
   */

  var callPropWithArity = curry(function(prop, arity) {
    return curryWithArity(arity + 1, function() {
      // curryWithArity guarantees we will be called with arity + 1 args
      var propArgs = [].slice.call(arguments, 0, arity);
      var obj = arguments[arity];

      return obj[prop].apply(obj, propArgs);
    });
  });


  /*
   * <apifunction>
   *
   * callProp
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Returns: function
   *
   * A shorthand for `callPropWithArity(prop, 0)`. Returns a new function that takes an object, and calls the specified
   * property on the given object.
   *
   * Examples:
   *   var myObj = { return42: function() { return 42; }};
   *   var callReturn42 = funkierJS.callProp('return42');
   *   var callReturn42(myObj); // => 42
   *
   */

  var callProp = flip(callPropWithArity)(0);


  /*
   * <apifunction>
   *
   * hasOwnProperty
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: obj: objectLike
   * Returns: boolean
   *
   * A curried wrapper around `Object.prototype.hasOwnProperty`. Takes a string representing a property name and an
   * object, and returns true if the given object itself (i.e. not objects in the prototype chain) has the specified
   * property.
   *
   * Examples:
   *   funkierJS.hasOwnProperty('funkier', {funkier: 1}); // => true
   *   funkierJS.hasOwnProperty('toString', {funkier: 1}); // => false
   *
   */

  var hasOwnProperty = curry(function(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  });


  /*
   * <apifunction>
   *
   * hasProperty
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: obj: objectLike
   * Returns: boolean
   *
   * A curried wrapper around the `in` operator. Takes a string representing a property name and an object, and
   * returns true if the given object or some object in the prototype chain has the specified property.
   *
   * Examples:
   *   funkierJS.hasProperty('funkier', {funkier: 1}); // => true
   *   funkierJS.hasProperty('toString', {funkier: 1}); // => true
   *
   */

  var hasProperty = curry(function(prop, object) {
    return prop in object;
  });


  /*
   * <apifunction>
   *
   * instanceOf
   *
   * Category: Object
   *
   * Parameter: constructor: function
   * Parameter: obj: objectLike
   * Returns: boolean
   *
   * A curried wrapper around the `instanceof` operator. Takes a constructor function and an object, and returns true
   * if the function's prototype property is in the prototype chain of the given object.
   *
   * Examples:
   *   var Constructor = function() {};
   *   funkierJS.instanceOf(Constructor, new Constructor()); // => true
   *   funkierJS.instanceOf(Function, {}); // => false
   *
   */

  var instanceOf = curry(function(constructor, object) {
    return object instanceof constructor;
  });


  /*
   * <apifunction>
   *
   * isPrototypeOf
   *
   * Category: Object
   *
   * Parameter: protoObject: objectLike
   * Parameter: obj: objectLike
   * Returns: boolean
   *
   * A curried wrapper around `Object.prototype.isPrototypeOf`. Takes two objects: the prototype object, and the object
   * whose prototype chain you wish to check.  Returns true if protoObj is in the prototype chain of o.
   *
   * Examples:
   *   var Constructor = function() {};
   *   funkierJS.isPrototypeOf(Constructor.prototype, new Constructor()); // => true
   *   funkierJS.isPrototypeOf(Function.prototype, {}); // => false
   *
   */

  var isPrototypeOf = curry(function(proto, obj) {
    return Object.prototype.isPrototypeOf.call(proto, obj);
  });


  /*
   * <apifunction>
   *
   * createObject
   *
   * Category: Object
   *
   * Parameter: protoObject: objectLike
   * Returns: object
   *
   * Returns a new object whose internal prototype property is the given object protoObject.
   *
   * Note: this is an unary function that discards excess arguments. If you need to simultaneously add new properties
   * to the created object, use [createObjectWithProps](#createObjectWithProps).
   *
   * Examples:
   *   var obj = {};
   *   var newObj = funkierJS.createObject(obj);
   *   funkierJS.isPrototypeOf(obj, newObj); // => true
   *
   */

  var createObject = curry(function(obj) {
    return Object.create(obj);
  });


  /*
   * <apifunction>
   *
   * createObjectWithProps
   *
   * Category: Object
   *
   * Parameter: protoObject: objectLike
   * Parameter: descriptorsObject: object
   * Returns: object
   *
   * Creates an object whose internal prototype property is protoObj, and which has the additional properties described
   * in the given property descriptor object descriptorsObject. The property descriptor object is expected to be of the
   * form accepted by `Object.create`, `Object.defineProperties` etc.
   *
   * Examples:
   *   var obj = {};
   *   var newObj = funkierJS.createObjectWithProps(obj, {prop: {configurable: false, enumerable: false,
   *                                                             writeable: true, value: 1}});
   *   funkierJS.isPrototypeOf(obj, newObj); // => true
   *   funkierJS.hasOwnProperty('prop', newObj); // => true',
   *
   */

  var createObjectWithProps = curry(function(obj, descriptor) {
    return Object.create(obj, descriptor);
  });


  /*
   * <apifunction>
   *
   * defineProperty
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: descriptor: object
   * Parameter: o: objectLike
   * Returns: objectLike
   *
   * A curried wrapper around `Object.defineProperty`. Takes a property name string, a property descriptor object and
   * the object that the property hould be defined on. Returns the object o, after having defined the relevant property
   * per the descriptor. Throws a TypeError if the descriptor is not an object.
   *
   * Examples:
   *   var a = {};',
   *   funkierJS.hasOwnProperty('foo', a); // => false
   *   funkierJS.defineProperty('foo', {value: 42}, a);
   *   funkierJS.hasOwnProperty('foo', a); // => true
   *
   */

  var defineProperty = curry(function(prop, descriptor, obj) {
    descriptor = checkObjectLike(descriptor, {strict: true});
    return Object.defineProperty(obj, prop, descriptor);
  });


  /*
   * <apifunction>
   *
   * defineProperties
   *
   * Category: Object
   *
   * Parameter: descriptors: object
   * Parameter: o: objectLike
   * Returns: objectLike
   *
   * A curried wrapper around `Object.defineProperties`. Takes an object whose own properties map to property
   * descriptors, and an object o. Returns the object o, after having defined the relevant properties named by the
   * properties of the descriptors parameter, and whose values are dictated by the descriptor parameter.
   *
   * Examples:
   *   var a = {};',
   *   funkierJS.hasOwnProperty('foo', a); // => false
   *   funkierJS.defineProperties({foo: {value: 42}}, a);
   *   funkierJS.hasOwnProperty('foo', a); // => true
   *
   */

  var defineProperties = curry(function(descriptors, obj) {
    // We're not strict here: for example one might want to install array-like properties from an array
    descriptors = checkObjectLike(descriptors, {allowNull: false});
    obj = checkObjectLike(obj, {allowNull: false});
    return Object.defineProperties(obj, descriptors);
  });


  /*
   * <apifunction>
   *
   * getOwnPropertyDescriptor
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: o: objectLike
   * Returns: object
   *
   * A curried wrapper around `Object.getOwnPropertyDescriptor`. Takes a property name and an object. If the object
   * itself has the given property, then the object's property descriptor for the given object is returned, otherwise
   * it returns undefined.
   *
   * Examples:
   *   var a = {foo: 42};',
   *   funkierJS.getOwnPropertyDescriptor('foo', a); // => {configurable: true, enumerable: true, writable: true,
   *                                                        value: 42}
   *   funkierJS.getOwnPropertyDescriptor('toString', a); // => undefined',
   *
   */

  var getOwnPropertyDescriptor = flip(Object.getOwnPropertyDescriptor);


  /*
   * <apifunction>
   *
   * extract
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: obj: object
   * Returns: any
   *
   * Synonyms: tap
   *
   * Extracts the given property from the given object. Equivalent to evaluating `obj[prop]`.
   *
   * Examples:
   *   funkierJS.extract('foo', {foo: 42}); // => 42
   *
   */

  var extract = curry(function(prop, obj) {
    return obj[prop];
  });


  /*
   * <apifunction>
   *
   * extractOrDefault
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: default: any
   * Parameter: obj: object
   * Returns: any
   *
   * Synonyms: defaultTap
   *
   * Extracts the given property from the given object, unless the property is not found in the object or its prototype
   * chain, in which case the specified default value is returned.
   *
   * Examples:
   *   funkierJS.extractOrDefaultt('foo', 43, {bar: 42}); // => 43
   *
   */

  var extractOrDefault = curry(function(prop, defaultVal, obj) {
    if (!(prop in obj))
      return defaultVal;

    return obj[prop];
  });


  /*
   * <apifunction>
   *
   * maybeExtract
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: obj: object
   * Returns: Maybe
   *
   * Synonyms: safeExtract | maybeTap | safeTap
   *
   * Extracts the given property from the given object, and wraps it in a [`Just`](#Just) value. When the property is
   * not present, either in the object, or its prototype chain, then [`Nothing`](#Nothing) is returned.
   *
   * Examples:
   *   funkierJS.maybeExtract('foo', {}); // => Nothing
   *
   */

  var maybeExtract = curry(function(prop, obj) {
    if (!(prop in obj))
      return Nothing;

    // Handle case where there is no getter
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (('set' in descriptor) && descriptor.get === undefined)
      return Nothing;

    return Just(obj[prop]);
  });


  // A thousand curses!
  // Per the ECMAScript spec, when setting a property on an object, the property descriptor - if it exists -
  // should be checked. Setting should fail when writable=false or there is no setter in the descriptor.
  // If the property descriptor doesn't exist on the property, then walk up the prototype chain making the
  // same check.
  //
  // Versions of V8 up to 3.11.9 fail to walk up the prototype chain. Further, when it was fixed, the fix
  // was gated behind a flag, which defaulted to false until 3.13.6, when the flag was flipped and V8 became
  // spec-compliant. The flag was removed in 3.25.4.
  var engineHandlesProtosCorrectly = (function() {
    var A = function(){};
    Object.defineProperty(A.prototype, 'foo', {writable: false});
    var compliant = false;
    var b = new A();

    try {
      b.foo = 1;
    } catch (e) {
      compliant = true;
    }

    return compliant;
  })();


  // Utility function for set: work backwards to Object.prototype, looking for a property descriptor
  var findPropertyDescriptor = function(prop, obj) {
    var descriptor;
    var toppedOut = false;

    while (descriptor === undefined && !toppedOut) {
      descriptor = getOwnPropertyDescriptor(prop, obj);
      if (descriptor === undefined) {
        if (obj === Object.prototype) {
          toppedOut = true;
        } else {
          obj = Object.getPrototypeOf(obj);
        }
      }
    }

    return descriptor;
  };


 // Utility function, taking a property and an object, returning true if that property is writable
  var checkIfWritable = function(prop, obj) {
    var writable = true;
    var descriptor = findPropertyDescriptor(prop, obj);

    // Don't modify writable false properties
    if (descriptor && 'writable' in descriptor && descriptor.writable === false)
      writable = false;

    // Don't modify no setter properties
    if (descriptor && writable && 'set' in descriptor && descriptor.set === undefined)
      writable = false;

    return writable;
  };


  /*
   * <apifunction>
   *
   * set
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: val: any
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Synonyms: setProp
   *
   * Sets the given property to the given value on the given object, returning the object. Equivalent to evaluating
   * `o[prop] = value`. The property will be created if it doesn't exist on the object. Throws when the property is
   * not writable, when it has no setter function, when the object is frozen, or when it is sealed and the property
   * is not already present.
   *
   * Alternatively, one can use [`safeSet`](#safeSet) for a version that will not throw in the above circumstances.
   * Similarly, [`modify`](#modify) and [`safeModify`](#safeModify) can be used to guarantee the property is not
   * created when it does not exist, or [`create`](#create) and [`safeCreateProp`](#safeCreateProp) can be used when
   * one wants to ensure existing values will not be changed.
   *
   * Examples:
   *   var a = {foo: 1};
   *   funkierJS.set('foo', 42, a); // => returns a
   *   a.foo // => 42
   *
   */

  var set = curry(function(prop, val, obj) {
    // We manually emulate the operation of [[CanPut]], rather than just setting in a
    // try-catch. We don't want to suppress other errors: for example the property's
    // setter function might throw
    var writable = checkIfWritable(prop, obj);

    if (writable && !hasOwnProperty(prop, obj) && (Object.isSealed(obj) || !Object.isExtensible(obj)))
      writable = false;

    if (!writable)
      throw new Error('Cannot write to property ' + prop);

    obj[prop] = val;
    return obj;
  });


  /*
   * <apifunction>
   *
   * safeSet
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: val: any
   * Parameter: obj: objectLike
   * Returns: Maybe
   *
   * Synonyms: maybeSet | maybeSetProp | safeSetProp
   *
   * Sets the given property to the given value on the given object, returning the object wrapped in a [`Just`](#Just)
   * value when successful. Equivalent to evaluating `o[prop] = value`. The property will be created if it doesn't exist
   * on the object. If unable to modify or create the property, then [`Nothing`](#Nothing) will be returned.
   *
   * Alternatively, one can use [`set`](#set) for a version that will throw in the above circumstances.
   * Similarly, [`modify`](#modify) and [`safeModify`](#safeModify) can be used to guarantee the property is not
   * created when it does not exist, or [`create`](#create) and [`safeCreateProp`](#safeCreateProp) can be used when
   * one wants to ensure existing values will not be changed.
   *
   * Examples:
   *   var a = {foo: 1};
   *   Object.freeze(a);
   *   funkierJS.safeSet('foo', 42, a); // => returns Nothing
   *   a.foo // => 1
   *
   */

  var safeSet = curry(function(prop, val, obj) {
    // We manually emulate the operation of [[CanPut]], rather than just setting in a
    // try-catch. We don't want to suppress other errors: for example the property's
    // setter function might throw
    var writable = checkIfWritable(prop, obj);

    if (writable && !hasOwnProperty(prop, obj) && (Object.isSealed(obj) || !Object.isExtensible(obj)))
      writable = false;

    if (!writable)
      return Nothing;

    obj[prop] = val;
    return Just(obj);
  });


  /*
   * <apifunction>
   *
   * modify
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: val: any
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Synonyms: modifyProp
   *
   * Sets the given property to the given value on the given object, providing it exists, and returns the object.
   * Equivalent to evaluating `o[prop] = value`. The property will not be created when it doesn't exist on the object.
   * Throws when the property is not writable, when it has no setter function, or when the object is frozen.
   *
   * Alternatively, one can use [`safeModify`](#safeModify) for a version that will not throw in the above
   * circumstances.  Similarly, [`set`](#set) and [`safeSet`](#safeSet) can be used to both modify existing properties
   * and create them where required, or [`create`](#create) and [`safeCreateProp`](#safeCreateProp) can be used when
   * one wants to ensure existing values will not be changed.
   *
   * Examples:
   *   var a = {foo: 1};
   *   funkierJS.modify('foo', 42, a); // => returns a
   *   a.foo // => 42
   *
   */

  var modify = curry(function(prop, val, obj) {
    // Return straight away if the property doesn't exist
    if (!hasProperty(prop, obj))
      throw new Error('Cannot modify non-existent property ' + prop);

    return set(prop, val, obj);
  });


  /*
   * <apifunction>
   *
   * safeModify
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: val: any
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Synonyms: maybeModify | maybeModifyProp | safeModifyProp
   *
   * Sets the given property to the given value on the given object, providing it exists, and returns the object,
   * wrapped in a [`Just`](#Just) value when successful. Equivalent to evaluating `o[prop] = value`. The property will
   * not be created when it doesn't exist on the object; nor will it be amended when the property is not writable, when
   * it has no setter function, or when the object is frozen. In such cases, [`Nothing`](#Nothing) will be returned.
   *
   * Alternatively, one can use [`modify`](#modify) for a version that will throw in the above circumstances.
   * Similarly, [`set`](#set) and [`safeSet`](#safeSet) can be used to both modify existing properties and create them
   * where required, or [`create`](#create) and [`safeCreateProp`](#safeCreateProp) can be used when one wants to ensure
   * existing values will not be changed.
   *
   * Examples:
   *   var a = {foo: 1};
   *   Object.freeze(a);
   *   funkierJS.safeModify('foo', 42, a); // => Nothing
   *   a.foo // => 1
   *
   */

  var safeModify = curry(function(prop, val, obj) {
    // Return straight away if the property doesn't exist
    if (!hasProperty(prop, obj))
      return Nothing;

    return safeSet(prop, val, obj);
  });


  /*
   * <apifunction>
   *
   * createProp
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: val: any
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Creates the given property to the given value on the given object, returning the object. Equivalent to evaluating
   * `o[prop] = value`. The property will be not be modified if it already exists; in that case this method will throw.
   * Additionally, it throws when the object is frozen, sealed, or cannot be extended. The property will be
   * successfully created when it already exists, but only in the prototype chain.
   *
   * Alternatively, one can use [`safeCreateProp`](#safeCreateProp) for a version that will not throw in the above
   * circumstances.  Similarly, [`modify`](#modify) and [`safeModify`](#safeModify) can be used to modify existing
   * properties without creating them, and [`set`](#set) and [`safeSet`](#safeSet) can be used to either modify or
   * create the property as required.
   *
   * Examples:
   *   var a = {foo: 1};
   *   funkierJS.create('bar', 42, a); // => returns a
   *   a.bar // => 42
   *
   */

  var createProp = curry(function(prop, val, obj) {
    // Return straight away if the property exists
    if (hasOwnProperty(prop, obj))
      throw new Error('Attempt to recreate existing property ' + prop);

    return set(prop, val, obj);
  });


  /*
   * <apifunction>
   *
   * safeCreateProp
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: val: any
   * Parameter: obj: objectLike
   * Returns: Maybe
   *
   * Synonyms: maybeCreate
   *
   *
   * Creates the given property to the given value on the given object, returning the object wrapped in a Just.
   * Equivalent to evaluating o[prop] = value. The property will be not be modified if it already exists; in
   * that case Nothing will be returned. Additionally, Nothing will be returned when the object is frozen, sealed, or
   * cannot be extended. Note that the property will be successfully created when it already exists, but only in the
   * prototype chain.
   *
   * Alternatively, one can use [`create`](#create) for a version that will throw on failure. Similarly,
   * [`modify`](#modify) and [`safeModify`](#safeModify) can be used to modify existing properties without
   * creating them, and [`set`](#set) and [`safeSet`](#safeSet) can be used to either modify or create the property as
   * required.
   *
   * Examples:
   *   var a = {foo: 1};
   *   Object.freeze(a);
   *   funkierJS.safeCreateProp('bar', 42, a); // => returns Nothing
   *   a.foo // => undefined
   *
   */

  var safeCreateProp = curry(function(prop, val, obj) {
    // Return straight away if the property exists
    if (hasOwnProperty(prop, obj))
      return Nothing;

    return safeSet(prop, val, obj);
  });



  /*
   * <apifunction>
   *
   * deleteProp
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Deletes the given property from the given the given object, returning the object. Equivalent to evaluating
   * `delete o[prop]`. Throws when the property is not configurable, including when the object is frozen or sealed.
   *
   * Alternatively, one can use [`safeDeleteProp`](#safeDeleteProp) that will return the appropriate Maybe value
   * depending on the outcome of the operation.
   *
   * Examples:
   *   var a = {foo: 1};
   *   funkierJS.delete('foo',  a); // => returns a
   *   a.foo // => undefined
   *
   */

  var deleteProp = curry(function(prop, obj) {
    obj = checkObjectLike(obj);

    if (!obj.hasOwnProperty(prop))
      return obj;

    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (descriptor.configurable === false)
      throw new Error('Cannot delete property ' + prop + ': not configurable!');

    delete obj[prop];
    return obj;
  });


  /*
   * <apifunction>
   *
   * safeDeleteProp
   *
   * Category: Object
   *
   * Parameter: prop: string
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Synonyms: maybeDelete
   *
   * Deletes the given property from the given the given object, returning the object wrapped as a [`Just`](#Just)
   * value. Equivalent to evaluating `delete o[prop]`. When the property is not configurable (either due to the
   * individual descriptor or the object being frozen or sealed) then [`Nothing`](#Nothing) will be returned.
   *
   * Alternatively, one can use [`delete`](#delete) that will return not wrap the object, and throw on error.
   *
   * Examples:
   *   var a = {};
   *   funkierJS.delete('foo',  a); // => returns Nothing
   *
   */

  var safeDeleteProp = curry(function(prop, obj) {
    obj = checkObjectLike(obj);

    if (!obj.hasOwnProperty(prop))
      return Just(obj);

    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (descriptor.configurable === false)
      return Nothing;

    delete obj[prop];
    return Just(obj);
  });


  /*
   * <apifunction>
   *
   * keys
   *
   * Category: Object
   *
   * Parameter: obj: objectLike
   * Returns: array
   *
   * A wrapper around `Object.keys`. Takes an object, and returns an array containing the names of the object's own
   * properties. Returns an empty array for non-objects.
   *
   * Examples:
   *   funkierJS.keys({foo: 1, bar: 2}); // => returns ['foo', 'bar'] or ['bar', 'foo'] depending on native
   *                                     //    environment
   *
   */

  var keys = curry(function(obj) {
    if (typeof(obj) !== 'object' || obj === null)
      return [];

    return Object.keys(obj);
  });


  /*
   * <apifunction>
   *
   * getOwnPropertyNames
   *
   * Category: Object
   *
   * Parameter: obj: objectLike
   * Returns: array
   *
   * A wrapper around `Object.getOwnPropertyNames`. Takes an object, and returns an array containing the names of the
   * object's own properties, including non-enumerable properties. Returns an empty array for non-objects. The order of
   * the property names is not defined.
   *
   * Examples:
   *   funkierJS.getOwnPropertyNames({foo: 1, bar: 2}); // => returns ['foo', 'bar'] or ['bar', 'foo'] depending on
   *                                                    // native environment
   *
   */

  var getOwnPropertyNames = curry(function(obj) {
    if (typeof(obj) !== 'object' || obj === null)
      return [];

    return Object.getOwnPropertyNames(obj);
  });



  /*
   * <apifunction>
   *
   * keyValues
   *
   * Category: Object
   *
   * Parameter: obj: objectLike
   * Returns: array
   *
   * Takes an object, and returns an array containing 2-element arrays. The first element of each sub-array is the name
   * of a property from the object, and the second element is the value of the property. This function only returns
   * key-value pairs for the object's own properties. Returns an empty array for non-objects.  The order of the values
   * is not defined.
   *
   * Examples:
   *   funkierJS.keyValues({foo: 1, bar: 2}); // => returns [['foo', 1], ['bar', 2]] or [['bar', 2], ['foo', 1]]
   *                                          // depending on native environment
   *
   */

  var keyValues = curry(function(obj) {
    if (typeof(obj) !== 'object' || obj === null)
      return [];

    return keys(obj).map(function(k) {return [k, obj[k]];});
  });


  /*
   * <apifunction>
   *
   * descriptors
   *
   * Category: Object
   *
   * Parameter: obj: objectLike
   * Returns: array
   *
   * Takes an object, and returns an array containing 2-element arrays. The first element of each sub-array is the name
   * of a property from the object, and the second element is its property descriptor. This function only returns
   * key-value pairs for the object's own properties. Returns an empty array for non-objects.  The order of the values
   * is not defined.
   *
   * Examples:
   *   funkierJS.descriptors({foo: 1}); // => returns [['foo', {configurable: true, writable: true, enumerable: true,
   *                                                            value: 1}]
   *
   */

  var descriptors = curry(function(obj) {
    if (typeof(obj) !== 'object' || obj === null)
      return [];

    return keys(obj).map(function(k) {return [k, getOwnPropertyDescriptor(k, obj)];});
  });


  /*
   * <apifunction>
   *
   * clone
   *
   * Category: Object
   *
   * Synonyms: shallowClone
   *
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Returns a shallow clone of the given object. All enumerable and non-enumerable properties from the given object
   * and its prototype chain will be copied, and will be enumerable or non-enumerable as appropriate. Note that values
   * from `Object.prototype`, `Array.prototype`, will not be copied, but those prototypes will be in the prototype chain
   * of the clone if they are in the prototype chain of the original object. Functions are returned unchanged.
   * Non-primitive values are copied by reference.
   *
   * Exercise caution when cloning properties that have get/set functions defined in the descriptor: the cloned object
   * will have these same functions using the same scope. Getting/setting such a property in the clone may affect the
   * corresponding property in the original.
   *
   */

  var shallowCloneInternal = function(obj, isRecursive) {
    if (typeof(obj) === 'function')
      return obj;

    if (typeof(obj) !== 'object')
      throw new TypeError('shallowClone called on non-object');

    if (Array.isArray(obj)) {
      var newArray = obj.slice();

      Object.keys(obj).forEach(function(k) {
        var n = k - 0;
        if (isNaN(n)) {
          newArray[k] = obj[k];
          return;
        }

        if (Math.floor(n) === n && Math.ceil(n) === n) return;
        newArray[k] = obj[k];
      });

      return newArray;
    }

    if (obj === null)
      return isRecursive ? Object.create(null) : null;

    if (obj === Object.prototype)
      return {};

    var result = shallowCloneInternal(Object.getPrototypeOf(obj), true);

    Object.getOwnPropertyNames(obj).forEach(function(k) {
      var desc = Object.getOwnPropertyDescriptor(obj, k);
      Object.defineProperty(result, k, desc);
    });

    return result;
  };


  var shallowClone = curry(function(obj) {
    return shallowCloneInternal(obj, false);
  });


  /*
   * <apifunction>
   *
   * extend
   *
   * Category: Object
   *
   * Parameter: source: objectLike
   * Parameter: dest: objectLike
   * Returns: objectLike
   *
   * Takes two objects, source and dest, and walks the prototype chain of source, copying all enumerable properties
   * into dest. Any extant properties with the same name are overwritten. Returns the modified dest object. All
   * properties are shallow-copied: in other words, if `foo` is a property of source whose value is an object, then
   * afterwards `source.foo === dest.foo` will be true.
   *
   * Examples:
   *   var a = {bar: 1};
   *   funkierJS.extend(a, {foo: 42}); // => a === {foo: 42, bar: 1}
   *
   */

  var extend = curry(function(source, dest) {
    for (var k in source)
      dest[k] = source[k];

    return dest;
  });


  /*
   * <apifunction>
   *
   * extendOwn
   *
   * Category: Object
   *
   * Parameter: source: objectLike
   * Parameter: dest: objectLike
   * Returns: objectLike
   *
   * Takes two objects, source and dest, and copies all enumerable properties from source into dest. Properties from
   * source's prototype chain are not copied. Any extant properties with the same name are overwritten.
   * Returns the modified dest object. All properties are shallow-copied: in other words, if `foo` is a property of
   * source whose value is an object, then afterwards `source.foo === dest.foo` will be true.
   *
   * Examples:
   *   var a = funkierJS.createObject({bar: 1});
   *   a.baz = 2;
   *   var b = {foo: 3};
   *   funkierJS.extendOwn(b, a); // b == {foo: 3, baz: 2}
   *
   */

  var extendOwn = curry(function(source, dest) {
    var keys = Object.keys(source);

    keys.forEach(function(k) {
      dest[k] = source[k];
    });

    return dest;
  });


  /*
   * <apifunction>
   *
   * curryOwn
   *
   * Category: Object
   *
   * Parameter: obj: objectLike
   * Returns: objectLike
   *
   * Takes an object, and providing every enumerable function is writable, (i.e. the function has not been configured as
   * writable: false), then curries the member functions of the object using the [`objectCurry`](#objectCurry) method.
   * If any member functions are found that do not meet this requirement, then the object is left unchanged. Only the
   * object's own properties are affected; those in the prototype chain are unperturbed. Properties with getter/setters
   * in their descriptor are ignored.
   *
   * The all-or-nothing approach was taken to avoid the difficulty in reasoning that would ensue on partial success:
   * the client would be left having to manually enumerate the functions to see which ones did get curried. The
   * avoidance of functions returned from properties with getter/setter descriptors is to avoid any lexical scoping
   * ambiguities.
   *
   * Examples:
   *   var obj = {foo: function(x, y) { return this.bar + x + y; }, bar: 10};
   *   funkierJS.curryOwn(obj);
   *   obj.foo(2)(3); // => 15
   *
   */

  var curryOwn = curry(function(obj) {
    var keys = Object.keys(obj);

    var funcKeys = keys.filter(function(k) {
      var desc = Object.getOwnPropertyDescriptor(obj, k);
      return typeof(obj[k]) === 'function' && desc.hasOwnProperty('configurable') && desc.hasOwnProperty('writable');
    });

    if (funcKeys.some(function(k) { return Object.getOwnPropertyDescriptor(obj, k).writable === false; }))
      return obj;

    funcKeys.forEach(function(k) {
      obj[k] = objectCurry(obj[k]);
    });

    return obj;
  });


  return {
    callProp: callProp,
    callPropWithArity: callPropWithArity,
    clone: shallowClone,
    createObject: createObject,
    createObjectWithProps: createObjectWithProps,
    createProp: createProp,
    curryOwn: curryOwn,
    descriptors: descriptors,
    defaultTap: extractOrDefault,
    defineProperty: defineProperty,
    defineProperties: defineProperties,
    deleteProp: deleteProp,
    extend: extend,
    extendOwn: extendOwn,
    extract: extract,
    extractOrDefault: extractOrDefault,
    getOwnPropertyDescriptor: getOwnPropertyDescriptor,
    getOwnPropertyNames: getOwnPropertyNames,
    hasOwnProperty: hasOwnProperty,
    hasProperty: hasProperty,
    instanceOf: instanceOf,
    isPrototypeOf: isPrototypeOf,
    keys: keys,
    keyValues: keyValues,
    maybeCreate: safeCreateProp,
    maybeDelete: safeDeleteProp,
    maybeExtract: maybeExtract,
    maybeModify: safeModify,
    maybeModifyProp: safeModify,
    maybeSet: safeSet,
    maybeSetProp: safeSet,
    maybeTap: maybeExtract,
    modify: modify,
    modifyProp: modify,
    safeCreateProp: safeCreateProp,
    safeDeleteProp: safeDeleteProp,
    safeExtract: maybeExtract,
    safeModify: safeModify,
    safeModifyProp: safeModify,
    safeSet: safeSet,
    safeSetProp: safeSet,
    safeTap: maybeExtract,
    set: set,
    setProp: set,
    shallowClone: shallowClone,
    tap: extract
  };
})();

},{"../internalUtilities":27,"./base":11,"./curry":13,"./maybe":18}],20:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;

  var utils = require('../internalUtilities');
  var valueStringifier = utils.valueStringifier;


  /*
   * A Pair represents an immutable tuple. The constructor function takes two elements,
   * first, and second, and returns a new tuple. The contents of the tuple can be accessed
   * with the accessor functions fst and snd respectively. The constructor is new-agnostic.
   * When called with one argument, a function will be returned that expects a second argument;
   * supplying this function with a value will yield a Pair. Throws a TypeError if called with
   * zero arguments.
   *
   */


  /*
   * <apifunction>
   *
   * Pair
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Parameter: b: any
   * Returns: Pair
   *
   * A Pair represents an immutable tuple. The constructor function takes two elements, first and second. and returns a
   * new immutable tuple. The contents of the tuple can be accessed with the accessor functions [`fst`](#fst) and
   * [`snd`](#snd) respectively. The constructor is new-agnostic.
   *
   * The constructor is curried: when called with one argument, a function will be returned that expects a second
   * argument; supplying this function with a value will yield a Pair. Note that the constructor is internally curried
   * outside of the usual mechanisms.
   *
   * Throws a TypeError if called with zero arguments.
   *
   * Examples:
   * var p1 = new funkierJS.Pair(2, 3);
   * var p2 = funkierJS.Pair(2)(3);
   * var pairs = funkierJS.map(funkierJS.new Pair(3), [4, 5, 6]);
   *
   */

  var Pair = function(a, b) {
    if (arguments.length === 0)
      throw new TypeError('Pair constructor takes two arguments');

    if (arguments.length === 1)
      return pairMaker(a);

    if (!(this instanceof Pair))
      return new Pair(a, b);

    Object.defineProperty(this, 'first', {enumerable: false, configurable: false, value: a});
    Object.defineProperty(this, 'second', {enumerable: false, configurable: false, value: b});
  };


  Pair.prototype = {
    toString: function() {
      // We use coercion rather than an explicit toString call as it's permissible for the
      // values to be null or undefined
      return ['Pair (', valueStringifier(this.first), ', ', valueStringifier(this.second), ')'].join('');
    },

    constructor: Pair
  };


  // Utility function for Pair to provide the illusion of currying
  var pairMaker = function(a) {
    var fn = curry(function(b) {
      return new Pair(a, b);
    });

    // Lie to instanceof
    fn.prototype = Pair.prototype;
    return fn;
  };


  /*
   * <apifunction>
   *
   * fst
   *
   * Category: DataTypes
   *
   * Synonyms: first
   *
   * Parameter: p: Pair
   * Returns: any
   *
   * Accessor function for [`Pair`](#Pair) tuples. Returns the first value that was supplied to the [`Pair`](#Pair)
   * constructor. Throws if called with a non-pair value.
   *
   * Examples:
   * var p = new funkierJS.Pair(2, 3);
   * funkierJS.fst(p); // => 2',
   *
   */

  var fst = curry(function(pair) {
    if (!(pair instanceof Pair))
      throw new TypeError('Not a pair');

    return pair.first;
  });


  /*
   * <apifunction>
   *
   * snd
   *
   * Category: DataTypes
   *
   * Synonyms: second
   *
   * Parameter: p: Pair
   * Returns: any
   *
   * Accessor function for [`Pair`](#Pair) tuples. Returns the second value that was supplied to the [`Pair`](#Pair)
   * constructor. Throws if called with a non-pair value.
   *
   * Examples:
   * var p = new funkierJS.Pair(2, 3);
   * funkierJS.cnd(p); // => 3',
   *
   */

  var snd = curry(function(pair) {
    if (!(pair instanceof Pair))
      throw new TypeError('Not a pair');

    return pair.second;
  });



  /*
   * <apifunction>
   *
   * isPair
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if the given value is a [`Pair`](#Pair), and false otherwise.
   *
   * Examples:
   *   funkierJS.isPair(funkierJS.Pair(2, 3)); // => True
   *
   */

  var isPair = curry(function(obj) {
    return obj instanceof Pair;
  });



  /*
   * <apifunction>
   *
   * asArray
   *
   * Category: DataTypes
   *
   * Parameter: p: Pair
   * Returns: array
   *
   * Takes a pair, and returns a 2-element array containing the values contained in the given [`Pair`](#Pair) p.
   * Specifically, if the resulting array is named arr, then we have `arr[0] === fst(p)` and `arr[1] === snd(p)`.
   * Throws a TypeError if p is not a pair.
   *
   * Examples:
   *   funkierJS.asArray(funkierJS.Pair(7, 10)); // => [7, 10]',
   *
   */

  var asArray = curry(function(p) {
    if (!(p instanceof Pair))
      throw new TypeError('Not a pair');

    return [fst(p), snd(p)];
  });


  return {
    Pair: Pair,
    asArray: asArray,
    first: fst,
    fst: fst,
    isPair: isPair,
    second: snd,
    snd: snd
  };
})();

},{"../internalUtilities":27,"./curry":13}],21:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;
  var arityOf = curryModule.arityOf;
  var curryWithConsistentStyle = curryModule._curryWithConsistentStyle;

  var internalUtilities = require('../internalUtilities');
  var valueStringifier = internalUtilities.valueStringifier;
  var checkArrayLike = internalUtilities.checkArrayLike;

  var funcUtils = require('../funcUtils');
  var checkFunction = funcUtils.checkFunction;


  /*
   * Result encapsulates the idea of functions throwing errors. It can be considered equivalent
   * to the Either datatype from Haskell, or the Result type from Rust.
   */


  /*
   * <apifunction>
   *
   * Result
   *
   * Category: DataTypes
   *
   * The `Result` type encapsulates the idea of functions throwing errors. It can be considered equivalent to the
   * `Either` datatype from Haskell, or the `Result` type from Rust.
   *
   * Result is the 'base class' of [`Ok`](#Ok) and [`Err`](#Err). It is provided only for the instanceof operator.
   *
   * It is an error to call Result.
   *
   */

  var Result = function() {
    throw new Error('Result cannot be instantiated directly');
  };
  Result.prototype = {toString: function() {return 'Result';}, constructor: Result};


  /*
   * <apifunction>
   *
   * Ok
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: Ok
   *
   * An Ok is a type of [`Result`](#Result) representing a successful computation. The constructor is new-agnostic.
   * Throws when called with no arguments.
   *
   * Examples:
   *   var result = funkierJS.Ok(42);
   *
   */

  var Ok = function(val) {
    if (arguments.length !== 1)
      throw new TypeError('Ok called with incorrect number of arguments');

    if (!(this instanceof Ok))
      return new Ok(val);

    Object.defineProperty(this, 'value', {configurable: false, writable: false, enumerable: false, value: val});
  };


  Ok.prototype = Object.create(Result.prototype);
  Ok.prototype.toString = function() {
    return 'Result {Ok ' + valueStringifier(this.value) + '}';
  };


  /*
   * <apifunction>
   *
   * Err
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: Just
   *
   * An Err is a type of [`Result`](#Result) representing a unsuccessful computation. The constructor is new-agnostic.
   * Throws if called without any arguments
   *
   * Examples:
   *   var result = funkierJS.Err(new TypeError('boom');
   *
   */


  var Err = function(val) {
    if (arguments.length !== 1)
      throw new TypeError('Err called with incorrect number of arguments');

    if (!(this instanceof Err))
      return new Err(val);

    Object.defineProperty(this, 'value', {configurable: false, writable: false, enumerable: false, value: val});
  };


  Err.prototype = Object.create(Result.prototype);
  Err.prototype.toString = function() {
    return 'Result {Err ' + valueStringifier(this.value) + '}';
  };


  /*
   * <apifunction>
   *
   * isResult
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true when the given value is a [`Result`](#Result) object, and false otherwise.
   *
   * Examples:
   *   funkierJS.isResult(funkierJS.Ok(3)) && funkierJS.isResult(funkierJS.Err(false)); // => true
   *
   */

  var isResult = curry(function(val) {
    return val === Result || val instanceof Result;
  });


  /*
   * <apifunction>
   *
   * isErr
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true when the given value is a [`Err`](#Err) object, and false otherwise.
   *
   * Examples:
   *   funkierJS.isErr(funkierJS.Err(4)); // => true
   *
   */

  var isErr = curry(function(val) {
    return val instanceof Err;
  });


  /*
   * <apifunction>
   *
   * isOk
   *
   * Category: DataTypes
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true when the given value is a [`Ok`](#Ok) object, and false otherwise.
   *
   * Examples:
   *   funkierJS.isOk(funkierJS.Ok('foo)); // => true
   *
   */

  var isOk = curry(function(val) {
    return val instanceof Ok;
  });


  /*
   * <apifunction>
   *
   * getOkValue
   *
   * Category: DataTypes
   *
   * Parameter: o: Ok
   * Returns: any
   *
   * Returns the value wrapped by the given [`Ok`](#Ok) instance o. Throws a TypeError if called with anything other
   * than an [`Ok`](#Ok).
   *
   * Examples:
   *   funkierJS.getOkValue(funkierJS.Ok(3)); // => 3',
   *
   */

  var getOkValue = curry(function(val) {
    if (!isOk(val))
      throw new TypeError('Value is not an Ok');

    return val.value;
  });


  /*
   * <apifunction>
   *
   * getErrValue
   *
   * Category: DataTypes
   *
   * Parameter: e: Err
   * Returns: any
   *
   * Returns the value wrapped by the given [`Err`](#Err) instance e. Throws a TypeError if called with anything other
   * than an [`Err`](#Err).
   *
   * Examples:
   *   funkierJS.getErrValue(funkierJS.Err(4)); // => 4',
   *
   */

  var getErrValue = curry(function(val) {
    if (!isErr(val))
      throw new TypeError('Value is not an Err');

    return val.value;
  });


  /*
   * <apifunction>
   *
   * makeResultReturner
   *
   * Category: DataTypes
   *
   * Parameter: f: function
   * Returns: function
   *
   * Takes a function f. Returns a new function with the same arity as f. When called, the new function calls the
   * original. If the function f throws during execution, then the exception will be caught, and an [`Err`](#Err) object
   * wrapping the exception is returned. Otherwise the result of the function is wrapped in an [`Ok`](#Ok) and returned.
   *
   * The function will be curried in the same style as the original, or using [`curry`](#curry) if the function was not
   * curried.
   *
   * Examples:
   *   var g = function(x) {
   *     if (x < 10)
   *       throw new Error('Bad value');
   *     return x;
   *   };
   *
   *   var f = funkierJS.makeResultReturner(g);
   *   f(11); // => Ok(11)
   *   f(5); // => Err(Error('Bad value');
   *
   */

  var makeResultReturner = curry(function(f) {
    f = checkFunction(f, {message: 'Value to be transformed must be a function'});

    return curryWithConsistentStyle(f, function() {
      var args = [].slice.call(arguments);

      try {
        var result = f.apply(this, arguments);
        return Ok(result);
      } catch (e) {
        return Err(e);
      }
    }, arityOf(f));
  });


  /*
   * <apifunction>
   *
   * either
   *
   * Category: DataTypes
   *
   * Parameter: f1: function
   * Parameter: f2: function
   * Parameter: r: Result
   * Returns: function
   *
   * Takes two functions of arity 1 or greater, and a [`Result`](#Result). If the [`Result`](#Result) is an [`Ok`](#Ok)
   * value, the first function f1 will be called with the unwrapped value.  Otherwise, if the [`Result`](#Result) is an
   * [`Err`](#Err) value, the second function is called with the unwrapped value. In either case, the result of of the
   * called function is returned.
   *
   * Throws a TypeError if either of the first two arguments is not a function of arity 1 or more, or if the given value
   * is not a Result.
   *
   * Note that, if required, the functions must already have their execution context set. Internally, the execution
   * context within `either` is `null`, so it cannot supply a useful execution context to any object-curried functions
   * supplied to this function.
   *
   * Examples:
   * var f = funkierJS.either(function(x) {console.log('Good: ' + x);}, function(x) {console.log('Bad: ' + x);});
   * f(funkierJS.Ok(2)); // => logs 'Good: 2' to the console
   * f(funkierJS.Err(':(')); // logs 'Bad: :(' to the console
   *
   */

  var either = curry(function(okFn, errFn, result) {
    okFn = checkFunction(okFn, {arity: 1, minimum: true, message: 'Ok value must be a function of arity 1 or more'});
    errFn = checkFunction(errFn, {arity: 1, minimum: true, message: 'Err value must be a function of arity 1 or more'});

    if (isOk(result))
      return okFn(getOkValue(result));

    if (isErr(result))
      return errFn(getErrValue(result));

    throw new TypeError('Invalid value');
  });


  return {
    either: either,
    getErrValue: getErrValue,
    getOkValue: getOkValue,
    isErr: isErr,
    isOk: isOk,
    isResult: isResult,
    makeResultReturner: makeResultReturner,
    Err: Err,
    Ok: Ok,
    Result: Result
  };
})();

},{"../funcUtils":24,"../internalUtilities":27,"./curry":13}],22:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var curryModule = require('./curry');
  var curry = curryModule.curry;

  var internalUtilities = require('../internalUtilities');
  var defineValue = internalUtilities.defineValue;
  var checkIntegral = internalUtilities.checkIntegral;

  var base = require('./base');
  var flip = base.flip;

  var object = require('./object');
  var callProp = object.callProp;
  var callPropWithArity = object.callPropWithArity;

  var funcUtils = require('../funcUtils');
  var checkFunction = funcUtils.checkFunction;


  /*
   * <apifunction>
   *
   * toString
   *
   * Category: string
   *
   * Parameter: val: any
   *
   * Calls val's `toString` property, and returns the result.
   *
   * Examples:
   *   funkierJS.toString({}); // => '[object Object]'
   *
   */

  var toString = curry(function(val) {
    return val.toString();
  });


  /*
   * <apifunction>
   *
   * toLocaleString
   *
   * Category: string
   *
   * Parameter: val: any
   * Returns: string
   *
   * Calls val's `toLocaleString` property, and returns the result.
   *
   * Examples:
   *   funkierJS.toLocaleString(1000); // => '1000' (in some environments)
   */

  var toLocaleString = curry(function(val) {
    return val.toLocaleString();
  });


  /*
   * <apifunction>
   *
   * toCharCode
   *
   * Category: string
   *
   * Parameter: i: number
   * Parameter: s: string
   * Returns: number
   *
   * A curried wrapper around `String.charCodeAt`. Takes an index i, and a string s, and returns the Unicode value of
   * the character at the given index in s.
   *
   * Examples:
   *   funkierJS.toCharCode(2, 'funkier'); // => 117
   *
   */

  var toCharCode = callPropWithArity('charCodeAt', 1);


  /*
   * <apifunction>
   *
   * ord
   *
   * Category: string
   *
   * Parameter: s: string
   *
   * Takes a string s, and returns the Unicode value of the character at index 0. Equivalent to `toCharCode(0, s)`.
   *
   * Examples:
   *   funkierJS.ord('A'); // => 65
   *
   */

  var ord = toCharCode(0);


  /*
   * <apifunction>
   *
   * chr
   *
   * Category: string
   *
   * Parameter: n: number
   * Returns: string
   *
   * Equivalent to `String.fromCharCode`. Takes a number n, and returns the character whose Unicode value is that
   * number.
   *
   * Examples:
   *   funkierJS.chr(69); // => 'E'
   *
   */

  var chr = curry(function(c) {
    return String.fromCharCode(c);
  });


  /*
   * <apifunction>
   *
   * toLowerCase
   *
   * Category: string
   *
   * Parameter: s: string
   * Returns: string
   *
   * Equivalent to `String.prototype.toLowerCase`. Takes a string s, and returns a lowercase version of s.
   *
   * Examples:
   *   funkierJS.toLowerCase('I LIKE TO SHOUT'); // => 'i like to shout'
   *
   */

  var toLowerCase = callProp('toLowerCase');


  /*
   * <apifunction>
   *
   * toLocaleLowerCase
   *
   * Category: string
   *
   * Parameter: s: string
   * Returns: string
   *
   * Equivalent to `String.prototype.toLocaleLowerCase`. Takes a string s, and returns a lowercase version of s,
   * converted following locale conventions.
   *
   * Examples:
   *   funkierJS.toLocaleLowerCase('I LIKE TO SHOUT'); // => 'i like to shout'
   *
   */

  var toLocaleLowerCase = callProp('toLocaleLowerCase');


  /*
   * <apifunction>
   *
   * toUpperCase
   *
   * Category: string
   *
   * Parameter: s: string
   * Returns: string
   *
   * Equivalent to `String.prototype.toUpperCase`. Takes a string s, and returns a uppercase version of s.
   *
   * Examples:
   *   funkierJS.oUpperCase('i like to whisper'); // => 'I LIKE TO WHISPER'
   *
   */

  var toUpperCase = callProp('toUpperCase');


  /*
   * <apifunction>
   *
   * toLocaleUpperCase
   *
   * Category: string
   *
   * Parameter: s: string
   *
   * Equivalent to `String.prototype.toLocaleUpperCase`. Takes a string s, and returns a uppercase version of s,
   * converted following locale conventions.
   *
   * Examples:
   *   funkierJS.toLocaleUpperCase('i like to whisper'); // => 'I LIKE TO WHISPER'
   *
   */

  var toLocaleUpperCase = callProp('toLocaleUpperCase');


  /*
   * <apifunction>
   *
   * split
   *
   * Category: string
   *
   * Parameter: delimiter: string
   * Parameter: s: string
   * Returns: array
   *
   * A curried wrapper around `String.prototype.split`. Takes a string delimiter, and a target string s, and returns an
   * array containing the substrings of s that were separated by the given delimiter.
   *
   * Throws a TypeError if either parameter is not a string.
   *
   * To specify the delimiter as a RegExp, use [`regExpSplit`](#regExpSplit).
   * To specify an upper bound, use [`splitMax`](#splitMax')/[`regExpSplitMax`](#regExpSplitMax).
   *
   * Examples:
   *   funkierJS.split('|', '1|2|3'); // => ['1', '2', '3']
   *
   */

  var split = curry(function(delimiter, s) {
    if (typeof(s) !== 'string' || typeof(delimiter) !== 'string')
      throw new TypeError('Delimiter and string must be strings');

    return s.split(delimiter);
  });


  /*
   * <apifunction>
   *
   * regExpSplit
   *
   * Category: string
   *
   * Parameter: delimiter: RegExp
   * Parameter: s: string
   * Returns: array
   *
   * Synonyms: splitRegExp
   *
   * A curried wrapper around `String.prototype.split`. Takes a pattern regexp, and a target string s, and returns an
   * array containing the substrings of s that were separated by substrings matching the given pattern.
   *
   * Throws a TypeError if the first parameter is not a RegExp or if the second parameter is not a string.
   *
   * To specify the delimiter as a string, use [`split`](#split).
   * To specify an upper bound, use [`splitMax`](#splitMax')/[`regExpSplitMax`](#regExpSplitMax).
   *
   * Examples:
   *   regExpSplit/a/, 'banana'); // => ['b', 'n', 'n']
   *
   */

  var regExpSplit = curry(function(delimiter, s) {
    if (typeof(s) !== 'string')
      throw new TypeError('Value to split must be a string');
    if (!(delimiter instanceof RegExp))
      throw new TypeError('Pattern to split on must be a RegExp');

    return s.split(delimiter);
  });


  /*
   * <apifunction>
   *
   * splitMax
   *
   * Category: string
   *
   * Parameter: delimiter: string
   * Parameter: limit: natural
   * Parameter: s: string
   * Returns: array
   *
   * Synonyms: splitLimit | splitCount
   *
   * A curried wrapper around `String.prototype.split`. Takes a string delimiter, a count, and a target string s, and
   * returns an array containing the substrings of s that were separated by the given delimiter, the returned array
   * containing at most limit such substrings.
   *
   * Throws a TypeError if the first or last parameter is not a string, or if limit is not integral.
   *
   * To specify the delimiter as a RegExp, use [`regExpSplitMax`](#regExpSplitMax).
   * To split without an upper bound, use [`split`](#split')/[`regExpSplit`](#regExpSplit).
   *
   * Examples:
   *   funkierJS.split('|', 2, '1|2|3'); // => ['1', '2']
   *
   */

  var splitMax = curry(function(delimiter, limit, s) {
    limit = checkIntegral(limit);

    if (typeof(s) !== 'string' || typeof(delimiter) !== 'string')
      throw new TypeError('Delimiter and string must be strings');

    return s.split(delimiter, limit);
  });


  /*
   * <apifunction>
   *
   * regExpSplitMax
   *
   * Category: string
   *
   * Parameter: delimiter: RegExp
   * Parameter: limit: natural
   * Parameter: s: string
   * Returns: array
   *
   * Synonyms: regExpSplitLimit | regExpSplitCount
   *
   * A curried wrapper around `String.prototype.split`. Takes a RegExp delimiter, a count, and a target string s, and
   * returns an array containing the substrings of s that were separated by strings matching the given delimiter, the
   * returned array containing at most limit such substrings.
   *
   * Throws a TypeError if the first parameter is not a RegExp, if the limit count is not integral, or if the last
   * parameter is not a string.
   *
   * To specify the delimiter as a string, use [`splitMax`](#splitMax).
   * To split without an upper bound, use [`split`](#split')/[`regExpSplit`](#regExpSplit).
   *
   *   funkierJS.splitRegExpLimit(/a/, 2, 'banana'); // => ['b', 'n']
   *
   */

  var regExpSplitMax = curry(function(delimiter, limit, s) {
    limit = checkIntegral(limit);

    if (typeof(s) !== 'string')
      throw new TypeError('Value to split must be a string');
    if (!(delimiter instanceof RegExp))
      throw new TypeError('Pattern to split on must be a RegExp');

    return s.split(delimiter, limit);
  });


  /*
   * Modification functions are not yet ready for implementation.
   *
  var replaceOneString = defineValue(
   *
   * replaceOneString
   *
   * Category: string
   *
   * Parameter: regexp: RegExp, replacement: string, s: string
   *
   * Takes 3 parameters:
   *   - regexp: a pattern to be replaced
   *   - replacement: the value to replace regexp with
   *   - s: the string to be searched
   * and replaces the first occurrence of regexp with replacement, and returns the new
   * string.
   *
   * The following sequences have special meaning: if replacement contains these, then
   * when the match is replaced, these patterns will be replaced by the values they
   * represent:
   *   - $1, $2, ... $99: the text matching the parenthesized subpatterns
   *   - $& refers to the text that was matched
   *   - $` refers to the text before the match
   *   - $\' refers to the text after the match
   *
   * Throws a TypeError if regexp is not a RegExp, or if replacement is not a string.
   *
   * Note: this function ignores the global flag of the given RegExp.
   *
   * To specify a function to be called with the match, use [[replaceOneStringWith]].
   * To replace all matches, use [[replaceString]]/[[replaceStringWith]].
   *
   * Examples:
   * var s = replaceOneString(/a/, \'i\', \'banana\'); // s => \'binana\'
    curry(function(regexp, replacement, s) {
      if (!(regexp instanceof RegExp) || typeof(replacement) !== 'string')
        throw new TypeError('replaceOneString called with invalid types');

      var r = new RegExp(regexp.source);
      return s.replace(r, replacement);
    })
  );


  var replaceString = defineValue(
   * replaceString
   *
   * Category: string
   *
   * Parameter: regexp: RegExp, replacement: string, s: string
   *
   * Takes 3 parameters:
   *   - regexp: a pattern to be replaced
   *   - replacement: the value to replace regexp with
   *   - s: the string to be searched
   * and replaces all occurrences of regexp with replacement, and returns the new
   * string.
   * The following sequences have special meaning: if replacement contains these, then
   * when the match is replaced, these patterns will be replaced by the values they
   * represent:
   *   - $1, $2, ... $99: the text matching the parenthesized subpatterns
   *   - $& refers to the text that was matched
   *   - $` refers to the text before the match
   *   - $\' refers to the text after the match
   *
   * Throws a TypeError if regexp is not a RegExp, or if replacement is not a string.
   *
   * Note: this function ignores the global flag of the given RegExp.
   *
   * To specify a function to be called with the match, use [[replaceStringWith]].
   * To replace only the first match, use [[replaceOneString]]/[[replaceOneStringWith]].
   *
   * Examples:
   * var s = replaceString(/a/, \'i\', \'banana\'); // s => \'binini\'
    curry(function(regexp, replacement, s) {
      if (!(regexp instanceof RegExp) || typeof(replacement) !== 'string')
        throw new TypeError('replaceString called with invalid types');

      var r = new RegExp(regexp.source, 'g');
      return s.replace(r, replacement);
    })
  );


  var replaceOneStringWith = defineValue(
   * replaceOneStringWith
   *
   * Category: string
   *
   * Parameter: regexp: RegExp, f: function, s: string
   *
   * Takes 3 parameters:
   *   - regexp: a pattern to be replaced
   *   - f: a function to call that will return the replacement text
   *   - s: the string to be searched
   * and replaces the first occurrence of substr with the value returned by f, and
   * returns the new string.
   *
   * The function f will be called with 3 or more parameters: the matched text,
   * followed by an argument for each parenthesized expression, each such argument
   * containing the text that the subexpression matched. The penultimate argument
   * will be the index of the start of the match, and the last argument will be the
   * original string. If f returns a non-string value, it will be coerced to a string.
   *
   * Throws a TypeError if regexp is not a RegExp, if f is not a function, or if f
   * has arity 0.
   *
   * Note: this function ignores the global flag of the given RegExp.
   *
   * To specify a string to be replace the match, use [[replaceOneString]].
   * To replace all matches, use [[replaceString]]/[[replaceStringWith]].
   *
   * Examples:
   * var f = function(match, paren, i, s) {return paren + i;};
   * var s = replaceOneStringWith(/(a)/, f, \'banana\'); // s => \'ba1nana\'
    curry(function(regexp, f, s) {
      f = checkFunction(f, {arity: 1, minimum: true, message: 'to must be a function of arity at least 1'});
      if (!(regexp instanceof RegExp))
        throw new TypeError('replaceOneStringWith called with invalid types');

      var r = new RegExp(regexp.source);
      return s.replace(r, f);
    })
  );


  var replaceStringWith = defineValue(
   * replaceStringWith
   *
   * Category: string
   *
   * Parameter: regexp: RegExp, f: function, s: string
   *
   * Takes 3 parameters:
   *   - regexp: a pattern to be replaced
   *   - f: a function to call that will return the replacement text
   *   - s: the string to be searched
   * and replaces all occurrences of substr with the value returned by f, and returns
   * the new string.
   *
   * The function f will be called with 3 or more parameters: the matched text,
   * followed by an argument for each parenthesized expression, each such argument
   * containing the text that the subexpression matched. The penultimate argument will
   * be the index of the start of the match, and the last argument will be the original
   * string. If f returns a non-string value, it will be coerced to a string.
   *
   * Throws a TypeError if regexp is not a RegExp, if f is not a function, or if f
   * has arity 0.
   *
   * Note: this function ignores the global flag of the given RegExp.
   *
   * To specify a string to be replace the match, use [[replaceString]].
   * To replace only the first match, use [[replaceOneString]]/[[replaceOneStringWith]].
   *
   * Examples:
   * var f = function(match, paren, i, s) {return paren + i;};
   * var s = replaceOneStringWith(/(a)/, f, \'banana\'); // s => \'ba1na2na3\'
    curry(function(regexp, f, s) {
      f = checkFunction(f, {arity: 1, minimum: true, message: 'to must be a function of arity at least 1'});
      if (!(regexp instanceof RegExp))
        throw new TypeError('replaceStringWith called with invalid types');

      var r = new RegExp(regexp.source, 'g');
      return s.replace(r, f);
    })
  );
  */


  /*
   * <apifunction>
   *
   * test
   *
   * Category: string
   *
   * Parameter: regexp: RegExp
   * Parameter: s: string
   * Returns: boolean
   *
   * A curried wrapper around `RegExp.prototype.test`. Takes a regexp, and a string s, and returns true if the string
   * contains a substring matching the given pattern, and false otherwise.
   *
   * Throws a TypeError if regexp is not a RegExp, or if s is not a string.
   *
   * Examples:
   *   funkierJS.test(/a/, 'banana'); // => true
   *
   */

  var test = curry(function(regexp, s) {
    if (!(regexp instanceof RegExp) || typeof(s) !== 'string')
      throw new TypeError('test called with invalid types');
    return regexp.test(s);
  });


  // Helper function for the various match functions
  var makeMatchResult = function(reResult) {
    return {
      index: reResult.index,
      matchedText: reResult[0],
      subexpressions: reResult.slice(1)
    };
  };


  /*
   * <apifunction>
   *
   * matches
   *
   * Category: string
   *
   * Parameter: r: Regexp
   * Parameter: s: string
   * Returns: array
   *
   * Finds all matches within a string for a given regular expression. Takes two parameters: a regular expression and a
   * string. Returns an array of objects, one object per match.
   *
   * Each object has the following properties:
   *   - index: the index in the original string where the match was found
   *   - matchedText: the substring that matched the pattern
   *   - subexpressions: an array of substrings that matched the parenthesed expressions in the regular expressions.
   *                     The substring matching the first parenthesised expression will be at position 0, the string
   *                     matching the second at position 1, and so on. If the regular expression did not contain any
   *                     parenthesised subexpressions, this array will be empty.
   *
   * This function is not affected by the presence or absence of a global flag in the supplied regular expression. It
   * is not affected by and does not change the lastIndex property of the regular expression if it exists.
   *
   * Throws a TypeError if the first parameter is not a regular expression.
   *
   * Examples:
   *   funkierJS.matches(/a/, 'banana');
   *   // a => [{index: 1, matchedText: 'a', []}, {index: 3, matchedText: 'a', []},
   *   //       {index: 5, matchedText: 'a', []}]
   *
   */

  var matches = curry(function(regexp, s) {
    if (!(regexp instanceof RegExp))
      throw new TypeError('Pattern is not a regular expression');

    regexp = new RegExp(regexp.source, 'g');
    var result = [];
    var next = regexp.exec(s);

    while (next !== null) {
      result.push(makeMatchResult(next));
      next = regexp.exec(s);
    }

    return result;
  });


  /*
   * <apifunction>
   *
   * matchesFrom
   *
   * Category: string
   *
   * Parameter: r: Regexp
   * Parameter: index: number
   * Parameter: s: string
   * Returns: array
   *
   * Finds all matches within a string for a given regular expression from the given index. Takes three parameters: a
   * regular expression, an index and a string. Returns an array of objects, one object per match.
   *
   * Each object has the following properties:
   *   - index: the index in the original string where the match was found
   *   - matchedText: the substring that matched the pattern
   *   - subexpressions: an array of substrings that matched the parenthesed expressions in the regular expressions.
   *                     The substring matching the first parenthesised expression will be at position 0, the string
   *                     matching the second at position 1, and so on. If the regular expression did not contain any
   *                     parenthesised subexpressions, this array will be empty.
   *
   * This function is not affected by the presence or absence of a global flag in the supplied regular expression. It
   * is not affected by and does not change the lastIndex property of the regular expression if it exists.
   *
   * If the index is negative, it is taken as an offset from the end of the string.
   *
   * Throws a TypeError if the first parameter is not a regular expression.
   *
   * Examples:
   *  funkierJS.matchesFrom(/a/, 2, 'banana');
   *  // => [{index: 3, matchedText: 'a', []}, {index: 5, matchedText: 'a', []}]
   *
   */

  var matchesFrom = curry(function(regexp, index, s) {
    return matches(regexp, s.slice(index));
  });


  /*
   * <apifunction>
   *
   * firstMatch
   *
   * Category: string
   *
   * Parameter: r: Regexp
   * Parameter: s: string
   * Returns: object | null
   *
   * Finds the first match in a string for a given regular expression. Takes two parameters: a regular expression and a
   * string. Returns a single object or null.
   *
   * If not null, the object has the following properties:
   *   - index: the index in the original string where the match was found
   *   - matchedText: the substring that matched the pattern
   *   - subexpressions: an array of substrings that matched the parenthesed expressions in the regular expressions.
   *                     The substring matching the first parenthesised expression will be at position 0, the string
   *                     matching the second at position 1, and so on. If the regular expression did not contain any
   *                     parenthesised subexpressions, this array will be empty.
   *
   * This function is not affected by the presence or absence of a global flag in the supplied regular expression. It
   * is not affected by and does not change the lastIndex property of the regular expression if it exists.
   *
   * Throws a TypeError if the first parameter is not a regular expression.
   *
   * Examples:
   *   funkierJS.firstMatch(/a/, \'banana\'); // => {index: 3, matchedText: \'a\', []}
   *
   */

  var firstMatch = curry(function(regexp, s) {
    if (!(regexp instanceof RegExp))
      throw new TypeError('Pattern is not a regular expression');

    regexp = new RegExp(regexp.source, 'g');
    var result = regexp.exec(s);
    return result === null ? result : makeMatchResult(result);
  });


  /*
   * <apifunction>
   *
   * firstMatchFrom
   *
   * Category: string
   *
   * Parameter: r: Regexp
   * Parameter: index: natural
   * Parameter: s: string
   * Returns: object | null
   *
   * Finds the first match in a string for a given regular expression from a given index. Takes three parameters: a
   * regular expression an index, and a string. Returns a single object or null.
   *
   * If not null, the object has the following properties:
   *   - index: the index in the original string where the match was found
   *   - matchedText: the substring that matched the pattern
   *   - subexpressions: an array of substrings that matched the parenthesed expressions in the regular expressions.
   *                     The substring matching the first parenthesised expression will be at position 0, the string
   *                     matching the second at position 1, and so on. If the regular expression did not contain any
   *                     parenthesised subexpressions, this array will be empty.
   *
   * This function is not affected by the presence or absence of a global flag in the supplied regular expression. It
   * is not affected by and does not change the lastIndex property of the regular expression if it exists.
   *
   * Throws a TypeError if the first parameter is not a regular expression.
   *
   * Examples:
   *   funkierJS.firstMatchFrom(/a/, 4, 'banana'); // => {index: 5, matchedText: 'a', []}
   *
   */

  var firstMatchFrom = curry(function(regexp, index, s) {
    return firstMatch(regexp, s.slice(index));
  });


  /*
   * <apifunction>
   *
   * trim
   *
   * Category: string
   *
   * Parameter: s: string
   * Returns: string
   *
   * Returns a string containing the contents of the original string, less any leading and trailing whitespace.
   *
   * Examples:
   *   funkierJS.trim(' abc   '); // 'abc'
   *
   */

  var trim = curry(function(s) {
    return s.trim();
  });


  return {
    chr: chr,
    firstMatch: firstMatch,
    firstMatchFrom: firstMatchFrom,
    matches: matches,
    matchesFrom: matchesFrom,
    ord: ord,
    regExpSplit: regExpSplit,
    regExpSplitCount: regExpSplitMax,
    regExpSplitLimit: regExpSplitMax,
    regExpSplitMax: regExpSplitMax,
    /*
    replaceOneString: replaceOneString,
    replaceOneStringWith: replaceOneStringWith,
    replaceString: replaceString,
    replaceStringWith: replaceStringWith,
    */
    split: split,
    splitCount: splitMax,
    splitLimit: splitMax,
    splitRegExp: regExpSplit,
    splitMax: splitMax,
    test: test,
    toCharCode: toCharCode,
    toLocaleLowerCase: toLocaleLowerCase,
    toLocaleString: toLocaleString,
    toLocaleUpperCase: toLocaleUpperCase,
    toLowerCase: toLowerCase,
    toUpperCase: toUpperCase,
    toString: toString,
    trim: trim
  };
})();

},{"../funcUtils":24,"../internalUtilities":27,"./base":11,"./curry":13,"./object":19}],23:[function(require,module,exports){
module.exports = (function() {
  "use strict";

  var curry = require('./curry').curry;


  /*
   * <apifunction>
   *
   * equals
   *
   * Category: types
   *
   * Parameter: a: any
   * Parameter: b: any
   * Returns: boolean
   *
   * A wrapper around the non-strict equality (==) operator.
   *
   * Examples:
   *   funkierJS.equals(1, '1'); // => true
   *
   */

  var equals = curry(function(x, y) {
    return x == y;
  });


  /*
   * <apifunction>
   *
   * strictEquals
   *
   * Category: types
   *
   * Parameter: a: any
   * Parameter: b: any
   * Returns: boolean
   *
   * A wrapper around the strict equality (===) operator.
   *
   * Examples:
   *   funkierJS.strictEquals(1, '1'); // => false
   *
   */

  var strictEquals = curry(function(x, y) {
    return x === y;
  });


  /*
   * <apifunction>
   *
   * notEqual
   *
   * Category: types
   *
   * Synonyms: notEquals
   *
   * Parameter: a: any
   * Parameter: b: any
   * Returns: boolean
   *
   * A wrapper around the inequality (!=) operator.
   *
   * Examples:
   *   funkierJS.notEqual({}, {}); // => true
   *
   */

  var notEqual = curry(function(x, y) {
    return x != y;
  });


  /*
   * <apifunction>
   *
   * strictNotEqual
   *
   * Category: types
   *
   * Synonyms: strictNotEquals | strictInequality
   *
   * Parameter: a: any
   * Parameter: b: any
   * Returns: boolean
   *
   * A wrapper around the strict inequality (!==) operator.
   *
   * Examples:
   *   funkierJS.strictNotEqual(1, '1'); // => true
   *
   */

  var strictNotEqual = curry(function(x, y) {
    return x !== y;
  });


  // Helper function for deepEqual. Assumes both objects are arrays.
  var deepEqualArr = function(a, b, aStack, bStack) {
    if (a.length !== b.length)
      return false;

    for (var i = aStack.length - 1; i >= 0; i--) {
      if (aStack[i] === a)
        return bStack[i] === b || bStack[i] === a;
      if (bStack[i] === b)
        return false;
    }

    aStack.push(a);
    bStack.push(b);
    var ok = true;
      ok = ok && deepEqualInternal(a[i], b[i], aStack, bStack);

    // Can't just iterate over the indices: the array might have custom keys
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) {
      ok = false;
    } else {
      aKeys.sort();
      bKeys.sort();

      ok = aKeys.every(function(k, i) {
        if (k !== bKeys[i])
          return false;
        return deepEqualInternal(a[k], b[k], aStack, bStack);
      });
    }

    aStack.pop();
    bStack.pop();
    return ok;
  };


  // Helper function for deepEqual. Assumes identity has already been checked, and
  // that a check has been made for both objects being arrays.
  var deepEqualObj = function(a, b, aStack, bStack) {
    // Identity should have already been checked (ie a ==== b === null)
    if (a === null || b === null)
      return false;

    // Likewise, we should already have checked for arrays
    if (Array.isArray(a) || Array.isArray(b))
      return false;

    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
      return false;

    // Check for recursive objects
    for (var i = aStack.length - 1; i >= 0; i--) {
      if (aStack[i] === a)
        return bStack[i] === b || bStack[i] === a;
      if (bStack[i] === b)
        return false;
    }

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    aKeys.sort();
    bKeys.sort();

    if (!deepEqualArr(aKeys, bKeys, aStack, bStack))
      return false;

    aStack.push(a);
    bStack.push(b);
    var ok = true;
    for (i = 0; ok && i < aKeys.length; i++)
      ok = ok && deepEqualInternal(a[aKeys[i]], b[bKeys[i]], aStack, bStack);

    aStack.pop();
    bStack.pop();
    return ok;
  };


  var deepEqualInternal = function(a, b, aStack, bStack) {
    if (strictEquals(a, b))
      return true;

    if (typeof(a) !== typeof(b))
       return false;

    if (typeof(a) !== 'object')
      return false;

    if (Array.isArray(a) && Array.isArray(b))
      return deepEqualArr(a, b, aStack, bStack);

    return deepEqualObj(a, b, aStack, bStack);
  };


  /*
   * <apifunction>
   *
   * deepEqual
   *
   * Category: types
   *
   * Synonyms: deepEquals
   *
   * Parameter: a: any
   * Parameter: b: any
   * Returns: boolean
   *
   * Check two values for deep equality. Deep equality holds if any of the following if the two values are the same
   * object, if both values are objects with the same object, the same prototype, the same enumerable properties
   * and those properties are themselves deeply equal (non-enumerable properties are not checked), or if both values
   * are arrays with the same length, any additional properties installed on the arrays are deeply equal, and the items
   * at each index are themselves deeply equal.
   *
   * Examples:
   *   funkierJS.deepEqual({foo: 1, bar: [2, 3]}, {bar: [2, 3], foo: 1}); // => true
   *
   */

  var deepEqual = curry(function(a, b) {
    return deepEqualInternal(a, b, [], []);
  });


  /*
   * <apifunction>
   *
   * is
   *
   * Category: types
   *
   * Synonyms: hasType
   *
   * Parameter: type: string
   * Parameter: value: any
   * Returns: boolean
   *
   * Given a string that could be returned by the `typeof` operator, and a value, returns true if typeof the given
   * object equals the given string. Throws if the first argument is not a string.
   *
   * Examples:
   *   funkierJS.is('number', 1); // => true
   *
   */

  var is = curry(function(s, obj) {
    if (typeof(s) !== 'string')
      throw new TypeError('Type to be checked is not a string');

    return typeof(obj) === s;
  });


  /*
   * <apifunction>
   *
   * isNumber
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if typeof the given value equals "number", false otherwise.
   *
   * Examples:
   *   funkierJS.isNumber(1); // => true
   *
   */

  var isNumber = is('number');


  /*
   * <apifunction>
   *
   * isString
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if typeof the given value equals `"string"`, false otherwise.
   *
   * Examples:
   *   funkierJS.isString('a'); // => true
   *
   */

  var isString = is('string');


  /*
   * <apifunction>
   *
   * isBoolean
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if typeof the given value equals `"boolean"`, false otherwise.
   *
   * Examples:
   *   funkierJS.isBoolean(false); // => true
   *
   */

  var isBoolean = is('boolean');


  /*
   * <apifunction>
   *
   * isUndefined
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if typeof the given value equals `"undefined"`, false otherwise.
   *
   * Examples:
   *   funkierJS.isUndefined(1); // => false
   *
   */

  var isUndefined = is('undefined');


  /*
   * <apifunction>
   *
   * isObject
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if typeof the given value equals `"object"`, false otherwise.
   *
   * Examples:
   *   funkierJS.isObject(null); // => true
   *
   */

  var isObject = is('object');


  /*
   * <apifunction>
   *
   * isArray
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if the given value is an array, false otherwise
   *
   * Examples:
   *   funkierJS.isArray([]); // => true
   *
   */

  var isArray = curry(function(obj) {
    return Array.isArray(obj);
  });


  /*
   * <apifunction>
   *
   * isNull
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if the given object is `null`, false otherwise
   *
   * Examples:
   *   funkierJS.isNull(null); // => true
   *
   */

  var isNull = curry(function(obj) {
    return obj === null;
  });


  /*
   * <apifunction>
   *
   * isRealObject
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: boolean
   *
   * Returns true if the value is a *real* Javascript object, i.e. an object for which `funkierJS.isObject(a) === true`
   * and `funkierJS.isNull(a) === false` and `funkierJS.isArray(a) === false`.
   *
   * Examples:
   *   funkierJS.isRealObject(null); // => false
   *
   */

  var isRealObject = curry(function(obj) {
    return isObject(obj) && !(isArray(obj) || isNull(obj));
  });


  /*
   * <apifunction>
   *
   * getType
   *
   * Category: types
   *
   * Parameter: a: any
   * Returns: string
   *
   * A functional wrapper around the typeof operator. Takes any Javascript value, and returns a string representing
   * the object's type: the result will be one of "number", "string", "boolean", "function", "undefined", or "object".
   *
   * Examples:
   *   funkierJS.getType({}); // => "object"
   *
   */

  var getType = curry(function(val) {
    return typeof(val);
  });


  return {
    deepEqual: deepEqual,
    deepEquals: deepEqual,
    equals: equals,
    getType: getType,
    hasType: is,
    is: is,
    isArray: isArray,
    isBoolean: isBoolean,
    isNumber: isNumber,
    isNull: isNull,
    isObject: isObject,
    isRealObject: isRealObject,
    isString: isString,
    isUndefined: isUndefined,
    notEqual: notEqual,
    notEquals: notEqual,
    strictEquals: strictEquals,
    strictInequality: strictNotEqual,
    strictNotEqual: strictNotEqual,
    strictNotEquals: strictNotEqual
  };
})();

},{"./curry":13}],24:[function(require,module,exports){
module.exports = (function() {
  "use strict";

  /*
   * A collection of internal utilities. Not exported to consumers.
   *
   * These utilities are deliberately split out from those in utils.js. Some functions here
   * depend on arityOf from curry.js, and we want curry.js to be able to use the functions
   * in utils.
   *
   */


  var curryModule = require('./components/curry');
  var arityOf = curryModule.arityOf;


  /*
   * Takes a value. Throws a TypeError if the value is not a function, and possibly return the
   * function otherwise, after any optional checks.
   *
   * This function takes an optional options object. The following properties are recognised:
   *   - message: the message the TypeError should contain if it proves necessary to throw
   *   - arity: in isolation, will restrict to accepting functions of this arity
   *   - minimum: when true, changes the meaning of arity to be the minimum accepted
   *
   */

  var checkFunction = function(f, options) {
    options = options || {};
    var message = options.message || 'Value is not a function';
    var arity = 'arity' in options ? options.arity : null;
    var minimum = options.minimum || false;

    if (minimum && !options.message)
      message = 'Value is not a function of arity  ' + arity;

    var maximum = options.maximum || false;
    if (maximum && !options.message)
      message = 'Value is not a function of arity  ' + arity;

    if (typeof(f) !== 'function')
      throw new TypeError(message);

    if (arity !== null) {
      var fArity = arityOf(f);

      if ((minimum && fArity < arity) || (maximum && fArity > arity) || (!minimum && !maximum && fArity !== arity))
        throw new TypeError(message);
    }

    return f;
  };


  return {
    checkFunction: checkFunction
  };
})();

},{"./components/curry":13}],25:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var funkier = {};

  // Imports need to be explicit for browserify to find them
  var imports = {
    array: require('./components/array'),
    base: require('./components/base'),
    categories: require('./components/categories'),
    curry: require('./components/curry'),
    date: require('./components/date'),
    fn: require('./components/fn'),
    logical: require('./components/logical'),
    object: require('./components/object'),
    maths: require('./components/maths'),
    maybe: require('./components/maybe'),
    pair: require('./components/pair'),
    result: require('./components/result'),
    string: require('./components/string'),
    types: require('./components/types')
  };


  // Export our imports
  Object.keys(imports).forEach(function(mod) {
    var m = imports[mod];
    Object.keys(m).forEach(function(k) {
      if (k[0] === '_') return;

      funkier[k] = m[k];
    });
  });


  // Install auto-generated help
  require('./help')(funkier);


  return funkier;
})();

},{"./components/array":10,"./components/base":11,"./components/categories":12,"./components/curry":13,"./components/date":14,"./components/fn":15,"./components/logical":16,"./components/maths":17,"./components/maybe":18,"./components/object":19,"./components/pair":20,"./components/result":21,"./components/string":22,"./components/types":23,"./help":26}],26:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /* NOTE: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT MANUALLY */


  return function(funkier) {
    var helpFn = function(value) {
      switch (value) {
        case helpFn:
          console.log('help:');
          console.log('Displays useful help for funkierJS API values');
          console.log('');
          console.log('Usage: help(f);');
          console.log('');
          console.log('Find full help online at https://graememcc.github.io/funkierJS/docs/');
          break;

        case funkier.Err:
          console.log('Err:');
          console.log('');
          console.log('An Err is a type of Result representing a unsuccessful computation. The constructor is new-agnostic.');
          console.log('Throws if called without any arguments');
          console.log('');
          console.log('');
          console.log('Usage: var x = Err(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#err');
          break;

        case funkier.Just:
          console.log('Just:');
          console.log('');
          console.log('A Just is a type of Maybe representing a successful computation. The constructor is new-agnostic.');
          console.log('Throws when called with no arguments.');
          console.log('');
          console.log('');
          console.log('Usage: var x = Just(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#just');
          break;

        case funkier.Maybe:
          console.log('Maybe:');
          console.log('');
          console.log('The Maybe type encapsulates the idea of sentinel values returned by functions to represent an error or unusual');
          console.log('conditions. Authors can return an instance of the Just constructor when a function executes successfully, and the');
          console.log('Nothing object when an error occurs, or the computation is otherwise unsuccessful.');
          console.log('');
          console.log('');
          console.log('Usage: var x = Maybe()');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#maybe');
          break;

        case funkier.Nothing:
          console.log('Nothing:');
          console.log('');
          console.log('A Nothing is a type of Maybe representing an unsuccessful computation.');
          console.log('');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#nothing');
          break;

        case funkier.Ok:
          console.log('Ok:');
          console.log('');
          console.log('An Ok is a type of Result representing a successful computation. The constructor is new-agnostic.');
          console.log('Throws when called with no arguments.');
          console.log('');
          console.log('');
          console.log('Usage: var x = Ok(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#ok');
          break;

        case funkier.Pair:
          console.log('Pair:');
          console.log('');
          console.log('A Pair represents an immutable tuple. The constructor function takes two elements, first and second. and returns a');
          console.log('new immutable tuple. The contents of the tuple can be accessed with the accessor functions fst and');
          console.log('snd respectively. The constructor is new-agnostic.');
          console.log('');
          console.log('');
          console.log('Usage: var x = Pair(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#pair');
          break;

        case funkier.Result:
          console.log('Result:');
          console.log('');
          console.log('The Result type encapsulates the idea of functions throwing errors. It can be considered equivalent to the');
          console.log('Either datatype from Haskell, or the Result type from Rust.');
          console.log('');
          console.log('');
          console.log('Usage: var x = Result()');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#result');
          break;

        case funkier.add:
          console.log('add:');
          console.log('');
          console.log('Synonyms: plus');
          console.log('');
          console.log('A wrapper around the addition operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = add(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#add');
          break;

        case funkier.and:
          console.log('and:');
          console.log('');
          console.log('A wrapper around the logical and (&&) operator. Returns the logical and of the given arguments');
          console.log('');
          console.log('');
          console.log('Usage: var x = and(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#and');
          break;

        case funkier.andPred:
          console.log('andPred:');
          console.log('');
          console.log('Takes two unary predicate functions, and returns a new unary function that, when called, will call the original');
          console.log('functions with the given argument, and logically and their results, returning that value. Throws if either');
          console.log('argument is not a function of arity 1.');
          console.log('');
          console.log('');
          console.log('Usage: var x = andPred(f1, f2)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#andpred');
          break;

        case funkier.append:
          console.log('append:');
          console.log('');
          console.log('Takes a value, and an array, string or arrayLike, and returns a new array or string with the given value appended.');
          console.log('');
          console.log('');
          console.log('Usage: var x = append(value, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#append');
          break;

        case funkier.apply:
          console.log('apply:');
          console.log('');
          console.log('Applies the given function f with the arguments given in the array args. If the function is not curried, it will be');
          console.log('curried (using curry) and partially applied if necessary. If the function is object curried, and has');
          console.log('not yet acquired an execution context, then it will be invoked with a null execution context (as apply is itself');
          console.log('curried, and so will have no visibility into the execution context it was invoked with). The result of applying the');
          console.log('given arguments to the function is returned.  Throws a TypeError if args is not an array, or if f is not a');
          console.log('function.');
          console.log('');
          console.log('');
          console.log('Usage: var x = apply(args, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#apply');
          break;

        case funkier.arityOf:
          console.log('arityOf:');
          console.log('');
          console.log('Synonyms: arity');
          console.log('');
          console.log('Reports the real arity of a function. If the function has not been curried by funkier.js, this simply returns the');
          console.log('function\'s length property. For a function that has been curried, the arity of the original function will be');
          console.log('reported (the function\'s length property will always be 0 or 1 in this case). For a partially applied function,');
          console.log('the amount of arguments not yet supplied will be returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = arityOf(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#arityof');
          break;

        case funkier.asArray:
          console.log('asArray:');
          console.log('');
          console.log('Takes a pair, and returns a 2-element array containing the values contained in the given Pair p.');
          console.log('Specifically, if the resulting array is named arr, then we have arr[0] === fst(p) and arr[1] === snd(p).');
          console.log('Throws a TypeError if p is not a pair.');
          console.log('');
          console.log('');
          console.log('Usage: var x = asArray(p)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#asarray');
          break;

        case funkier.bind:
          console.log('bind:');
          console.log('');
          console.log('Synonyms: bindWithContext');
          console.log('');
          console.log('Given an object and function, returns a curried function with the same arity as the original, and whose execution');
          console.log('context is permanently bound to the supplied object. The function will be called when sufficient arguments have');
          console.log('been supplied. Superfluous arguments are discarded. It is possible to partially apply the resulting function, and');
          console.log('indeed the further resulting function(s). The resulting function and its partial applications will throw if they');
          console.log('require at least one argument, but are invoked without any. bind throws if the first parameter is not an');
          console.log('an acceptable type for an execution context, or if the last parameter is not a function.');
          console.log('');
          console.log('');
          console.log('Usage: var x = bind(ctx, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#bind');
          break;

        case funkier.bindWithContextAndArity:
          console.log('bindWithContextAndArity:');
          console.log('');
          console.log('Given an arity, object and function, returns a curried function whose execution context is permanently bound to');
          console.log('the supplied object, and whose arity equals the arity given. The supplied arity need not equal the function\'s');
          console.log('length. The function will be only called when the specified number of arguments have been supplied. Superfluous');
          console.log('arguments are discarded. It is possible to partially apply the resulting function, and indeed the further');
          console.log('resulting function(s). The resulting function and its partial applications will throw if they require at least');
          console.log('one argument, but are invoked without any. bindWithContextAndArity throws if the arity is not a natural');
          console.log('number, if the second parameter is not an acceptable type for an execution context, or if the last parameter is');
          console.log('not a function.');
          console.log('');
          console.log('');
          console.log('Usage: var x = bindWithContextAndArity(n, ctx, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#bindwithcontextandarity');
          break;

        case funkier.bitwiseAnd:
          console.log('bitwiseAnd:');
          console.log('');
          console.log('A wrapper around the bitwise and (&) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = bitwiseAnd(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#bitwiseand');
          break;

        case funkier.bitwiseNot:
          console.log('bitwiseNot:');
          console.log('');
          console.log('A wrapper around the bitwise not (~) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = bitwiseNot(x)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#bitwisenot');
          break;

        case funkier.bitwiseOr:
          console.log('bitwiseOr:');
          console.log('');
          console.log('A wrapper around the bitwise or (&) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = bitwiseOr(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#bitwiseor');
          break;

        case funkier.bitwiseXor:
          console.log('bitwiseXor:');
          console.log('');
          console.log('A wrapper around the bitwise xor (^) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = bitwiseXor(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#bitwisexor');
          break;

        case funkier.callProp:
          console.log('callProp:');
          console.log('');
          console.log('A shorthand for callPropWithArity(prop, 0). Returns a new function that takes an object, and calls the specified');
          console.log('property on the given object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = callProp(prop)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#callprop');
          break;

        case funkier.callPropWithArity:
          console.log('callPropWithArity:');
          console.log('');
          console.log('Given a property name and an arity, returns a curried function taking arity + 1 arguments. The new function');
          console.log('requires all the original arguments in their original order, and an object as its final parameter. The returned');
          console.log('function will then try to call the named property on the given object,');
          console.log('');
          console.log('');
          console.log('Usage: var x = callPropWithArity(prop, arity)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#callpropwitharity');
          break;

        case funkier.chr:
          console.log('chr:');
          console.log('');
          console.log('Equivalent to String.fromCharCode. Takes a number n, and returns the character whose Unicode value is that');
          console.log('number.');
          console.log('');
          console.log('');
          console.log('Usage: var x = chr(n)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#chr');
          break;

        case funkier.clone:
          console.log('clone:');
          console.log('');
          console.log('Synonyms: shallowClone');
          console.log('');
          console.log('Returns a shallow clone of the given object. All enumerable and non-enumerable properties from the given object');
          console.log('and its prototype chain will be copied, and will be enumerable or non-enumerable as appropriate. Note that values');
          console.log('from Object.prototype, Array.prototype, will not be copied, but those prototypes will be in the prototype chain');
          console.log('of the clone if they are in the prototype chain of the original object. Functions are returned unchanged.');
          console.log('Non-primitive values are copied by reference.');
          console.log('');
          console.log('');
          console.log('Usage: var x = clone(obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#clone');
          break;

        case funkier.compose:
          console.log('compose:');
          console.log('');
          console.log('Composes the two functions, returning a new function that consumes one argument, which is passed to g. The result');
          console.log('of that call is then passed to f. That result is then returned. Throws if either parameter is not a function, or');
          console.log('has arity 0.');
          console.log('');
          console.log('');
          console.log('Usage: var x = compose(f, g)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#compose');
          break;

        case funkier.composeMany:
          console.log('composeMany:');
          console.log('');
          console.log('Repeatedly composes the given array of functions, from right to left. All functions are curried where necessary.');
          console.log('Functions are curried from right to left. Throws an Error if any array member is not a function, if it has arity');
          console.log('zero, or if the value supplied is not an array.');
          console.log('');
          console.log('');
          console.log('Usage: var x = composeMany(fns)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#composemany');
          break;

        case funkier.composeOn:
          console.log('composeOn:');
          console.log('');
          console.log('Composes the two functions, returning a new function that consumes the specified number of arguments, which are');
          console.log('then passed to g. The result of that call is then passed to f. That result is then returned. Throws if the');
          console.log('first parameter is not an integer greater than zero, if either parameter is not a function, or if either parameter');
          console.log('has arity 0.');
          console.log('');
          console.log('');
          console.log('Usage: var x = composeOn(argCount, f, g)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#composeon');
          break;

        case funkier.concat:
          console.log('concat:');
          console.log('');
          console.log('Takes two arrays, arrayLikes or strings, and returns their concatenation.');
          console.log('');
          console.log('');
          console.log('Usage: var x = concat(arr1, arr2)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#concat');
          break;

        case funkier.constant:
          console.log('constant:');
          console.log('');
          console.log('Intended to be partially applied, first taking a value, returning a function that takes another parameter');
          console.log('and which always returns the first value.');
          console.log('');
          console.log('');
          console.log('Usage: var x = constant(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#constant');
          break;

        case funkier.constant0:
          console.log('constant0:');
          console.log('');
          console.log('Returns a function of arity zero that when called always returns the supplied value.');
          console.log('');
          console.log('');
          console.log('Usage: var x = constant0(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#constant0');
          break;

        case funkier.copy:
          console.log('copy:');
          console.log('');
          console.log('Takes an arrayLike, and returns a new array which is a shallow copy.');
          console.log('');
          console.log('');
          console.log('Usage: var x = copy(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#copy');
          break;

        case funkier.createObject:
          console.log('createObject:');
          console.log('');
          console.log('Returns a new object whose internal prototype property is the given object protoObject.');
          console.log('');
          console.log('');
          console.log('Usage: var x = createObject(protoObject)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#createobject');
          break;

        case funkier.createObjectWithProps:
          console.log('createObjectWithProps:');
          console.log('');
          console.log('Creates an object whose internal prototype property is protoObj, and which has the additional properties described');
          console.log('in the given property descriptor object descriptorsObject. The property descriptor object is expected to be of the');
          console.log('form accepted by Object.create, Object.defineProperties etc.');
          console.log('');
          console.log('');
          console.log('Usage: var x = createObjectWithProps(protoObject, descriptorsObject)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#createobjectwithprops');
          break;

        case funkier.createProp:
          console.log('createProp:');
          console.log('');
          console.log('Creates the given property to the given value on the given object, returning the object. Equivalent to evaluating');
          console.log('o[prop] = value. The property will be not be modified if it already exists; in that case this method will throw.');
          console.log('Additionally, it throws when the object is frozen, sealed, or cannot be extended. The property will be');
          console.log('successfully created when it already exists, but only in the prototype chain.');
          console.log('');
          console.log('');
          console.log('Usage: var x = createProp(prop, val, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#createprop');
          break;

        case funkier.curry:
          console.log('curry:');
          console.log('');
          console.log('Curries the given function f, returning a function which accepts the same number of arguments as the original');
          console.log('function\'s length property, but which may be partially applied. The function can be partially applied by passing');
          console.log('arguments one at a time, or by passing several arguments at once. The function can also be called with more');
          console.log('arguments than the given function\'s length, but the superfluous arguments will be ignored, and will not be');
          console.log('passed to the original function. If the curried function or any subsequent partial applications require at least');
          console.log('one argument, then calling the function with no arguments will throw. curry throws if its argument is not a');
          console.log('function. It will also throw if the function is known to be bound to a specific execution context.');
          console.log('');
          console.log('');
          console.log('Usage: var x = curry(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#curry');
          break;

        case funkier.curryOwn:
          console.log('curryOwn:');
          console.log('');
          console.log('Takes an object, and providing every enumerable function is writable, (i.e. the function has not been configured as');
          console.log('writable: false), then curries the member functions of the object using the objectCurry method.');
          console.log('If any member functions are found that do not meet this requirement, then the object is left unchanged. Only the');
          console.log('object\'s own properties are affected; those in the prototype chain are unperturbed. Properties with getter/setters');
          console.log('in their descriptor are ignored.');
          console.log('');
          console.log('');
          console.log('Usage: var x = curryOwn(obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#curryown');
          break;

        case funkier.curryWithArity:
          console.log('curryWithArity:');
          console.log('');
          console.log('Curries the given function f to the supplied arity, which need not equal the function\'s length. The function will');
          console.log('be called when that number of arguments have been supplied. Superfluous arguments are discarded. The original');
          console.log('function will be called with a null execution context. It is possible to partially apply the resulting function,');
          console.log('and indeed the further resulting function(s). The resulting function and its partial applications will throw if');
          console.log('they require at least one argument, but are invoked without any. curryWithArity throws if the arity is not a');
          console.log('natural number, or if the second parameter is not a function. It will also throw if the given function is known');
          console.log('to be bound to a specific execution context.');
          console.log('');
          console.log('');
          console.log('Usage: var x = curryWithArity(n, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#currywitharity');
          break;

        case funkier.deepEqual:
          console.log('deepEqual:');
          console.log('');
          console.log('Synonyms: deepEquals');
          console.log('');
          console.log('Check two values for deep equality. Deep equality holds if any of the following if the two values are the same');
          console.log('object, if both values are objects with the same object, the same prototype, the same enumerable properties');
          console.log('and those properties are themselves deeply equal (non-enumerable properties are not checked), or if both values');
          console.log('are arrays with the same length, any additional properties installed on the arrays are deeply equal, and the items');
          console.log('at each index are themselves deeply equal.');
          console.log('');
          console.log('');
          console.log('Usage: var x = deepEqual(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#deepequal');
          break;

        case funkier.defineProperties:
          console.log('defineProperties:');
          console.log('');
          console.log('A curried wrapper around Object.defineProperties. Takes an object whose own properties map to property');
          console.log('descriptors, and an object o. Returns the object o, after having defined the relevant properties named by the');
          console.log('properties of the descriptors parameter, and whose values are dictated by the descriptor parameter.');
          console.log('');
          console.log('');
          console.log('Usage: var x = defineProperties(descriptors, o)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#defineproperties');
          break;

        case funkier.defineProperty:
          console.log('defineProperty:');
          console.log('');
          console.log('A curried wrapper around Object.defineProperty. Takes a property name string, a property descriptor object and');
          console.log('the object that the property hould be defined on. Returns the object o, after having defined the relevant property');
          console.log('per the descriptor. Throws a TypeError if the descriptor is not an object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = defineProperty(prop, descriptor, o)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#defineproperty');
          break;

        case funkier.deleteProp:
          console.log('deleteProp:');
          console.log('');
          console.log('Deletes the given property from the given the given object, returning the object. Equivalent to evaluating');
          console.log('delete o[prop]. Throws when the property is not configurable, including when the object is frozen or sealed.');
          console.log('');
          console.log('');
          console.log('Usage: var x = deleteProp(prop, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#deleteprop');
          break;

        case funkier.descriptors:
          console.log('descriptors:');
          console.log('');
          console.log('Takes an object, and returns an array containing 2-element arrays. The first element of each sub-array is the name');
          console.log('of a property from the object, and the second element is its property descriptor. This function only returns');
          console.log('key-value pairs for the object\'s own properties. Returns an empty array for non-objects.  The order of the values');
          console.log('is not defined.');
          console.log('');
          console.log('');
          console.log('Usage: var x = descriptors(obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#descriptors');
          break;

        case funkier.div:
          console.log('div:');
          console.log('');
          console.log('Returns the quotient on dividing x by y.');
          console.log('');
          console.log('');
          console.log('Usage: var x = div(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#div');
          break;

        case funkier.divide:
          console.log('divide:');
          console.log('');
          console.log('A wrapper around the division operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = divide(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#divide');
          break;

        case funkier.drop:
          console.log('drop:');
          console.log('');
          console.log('Takes a count, and an array, string or arrayLike. Returns an array or string containing the first count elements');
          console.log('removed from the given arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = drop(count, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#drop');
          break;

        case funkier.dropWhile:
          console.log('dropWhile:');
          console.log('');
          console.log('Takes a predicate function p, and source, an array, string or arrayLike. Returns a new array or string containing');
          console.log('the remaining members our source upon removing the initial elements for which the predicate function returned true.');
          console.log('');
          console.log('');
          console.log('Usage: var x = dropWhile(pred, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#dropwhile');
          break;

        case funkier.each:
          console.log('each:');
          console.log('');
          console.log('Takes a function f, and an array, string or arrayLike arr. Calls f with each member of the array in sequence, and');
          console.log('returns undefined.');
          console.log('');
          console.log('');
          console.log('Usage: var x = each(f, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#each');
          break;

        case funkier.either:
          console.log('either:');
          console.log('');
          console.log('Takes two functions of arity 1 or greater, and a Result. If the Result is an Ok');
          console.log('value, the first function f1 will be called with the unwrapped value.  Otherwise, if the Result is an');
          console.log('Err value, the second function is called with the unwrapped value. In either case, the result of of the');
          console.log('called function is returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = either(f1, f2, r)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#either');
          break;

        case funkier.element:
          console.log('element:');
          console.log('');
          console.log('Takes a value and an array, string or arrayLike. Returns true if the value is in the arrayLike (checked for strict');
          console.log('identity) and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = element(val, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#element');
          break;

        case funkier.elementWith:
          console.log('elementWith:');
          console.log('');
          console.log('A generalised version of element. Takes a predicate function p of one argument, and an array, string or arrayLike.');
          console.log('Returns true if there is an element in the arrayLike for which p returns true, and returns false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = elementWith(pred, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#elementwith');
          break;

        case funkier.equals:
          console.log('equals:');
          console.log('');
          console.log('A wrapper around the non-strict equality (==) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = equals(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#equals');
          break;

        case funkier.even:
          console.log('even:');
          console.log('');
          console.log('Given a number, returns true if it is divisible by 2, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = even(x)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#even');
          break;

        case funkier.every:
          console.log('every:');
          console.log('');
          console.log('Synonyms: all');
          console.log('');
          console.log('Takes two parameters: a predicate function p that takes one argument, and an array, string or arrayLike. Calls the');
          console.log('predicate with every element of the array or string, until either the predicate function returns false, or the end');
          console.log('of the array or string is reached.');
          console.log('');
          console.log('');
          console.log('Usage: var x = every(pred, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#every');
          break;

        case funkier.exp:
          console.log('exp:');
          console.log('');
          console.log('Synonyms: pow');
          console.log('');
          console.log('A curried wrapper around Math.pow.');
          console.log('');
          console.log('');
          console.log('Usage: var x = exp(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#exp');
          break;

        case funkier.extend:
          console.log('extend:');
          console.log('');
          console.log('Takes two objects, source and dest, and walks the prototype chain of source, copying all enumerable properties');
          console.log('into dest. Any extant properties with the same name are overwritten. Returns the modified dest object. All');
          console.log('properties are shallow-copied: in other words, if foo is a property of source whose value is an object, then');
          console.log('afterwards source.foo === dest.foo will be true.');
          console.log('');
          console.log('');
          console.log('Usage: var x = extend(source, dest)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#extend');
          break;

        case funkier.extendOwn:
          console.log('extendOwn:');
          console.log('');
          console.log('Takes two objects, source and dest, and copies all enumerable properties from source into dest. Properties from');
          console.log('source\'s prototype chain are not copied. Any extant properties with the same name are overwritten.');
          console.log('Returns the modified dest object. All properties are shallow-copied: in other words, if foo is a property of');
          console.log('source whose value is an object, then afterwards source.foo === dest.foo will be true.');
          console.log('');
          console.log('');
          console.log('Usage: var x = extendOwn(source, dest)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#extendown');
          break;

        case funkier.extract:
          console.log('extract:');
          console.log('');
          console.log('Synonyms: tap');
          console.log('');
          console.log('Extracts the given property from the given object. Equivalent to evaluating obj[prop].');
          console.log('');
          console.log('');
          console.log('Usage: var x = extract(prop, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#extract');
          break;

        case funkier.extractOrDefault:
          console.log('extractOrDefault:');
          console.log('');
          console.log('Synonyms: defaultTap');
          console.log('');
          console.log('Extracts the given property from the given object, unless the property is not found in the object or its prototype');
          console.log('chain, in which case the specified default value is returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = extractOrDefault(prop, default, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#extractordefault');
          break;

        case funkier.filter:
          console.log('filter:');
          console.log('');
          console.log('Takes a predicate function pred, and an array, string or arrayLike arr. Returns an array or string containing');
          console.log('those members of arrin the same order as the original arrayfor which the predicate function returned true.');
          console.log('');
          console.log('');
          console.log('Usage: var x = filter(pred, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#filter');
          break;

        case funkier.firstMatch:
          console.log('firstMatch:');
          console.log('');
          console.log('Finds the first match in a string for a given regular expression. Takes two parameters: a regular expression and a');
          console.log('string. Returns a single object or null.');
          console.log('');
          console.log('');
          console.log('Usage: var x = firstMatch(r, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#firstmatch');
          break;

        case funkier.firstMatchFrom:
          console.log('firstMatchFrom:');
          console.log('');
          console.log('Finds the first match in a string for a given regular expression from a given index. Takes three parameters: a');
          console.log('regular expression an index, and a string. Returns a single object or null.');
          console.log('');
          console.log('');
          console.log('Usage: var x = firstMatchFrom(r, index, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#firstmatchfrom');
          break;

        case funkier.flatten:
          console.log('flatten:');
          console.log('');
          console.log('Takes an array containing arrays or strings. Returns an array containing the concatenation of those arrays/strings.');
          console.log('Note that flatten only strips off one layer.');
          console.log('');
          console.log('');
          console.log('Usage: var x = flatten(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#flatten');
          break;

        case funkier.flattenMap:
          console.log('flattenMap:');
          console.log('');
          console.log('Takes a function of arity 1, and an array, string or arrayLike. Maps the function over the array/string and');
          console.log('flattens the result. The supplied function must be of arity 1, as it is expected to return an array or string; a');
          console.log('TypeError is thrown if this is not the case.');
          console.log('');
          console.log('');
          console.log('Usage: var x = flattenMap(f, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#flattenmap');
          break;

        case funkier.flip:
          console.log('flip:');
          console.log('');
          console.log('Takes a binary function f, and returns a curried function that takes the arguments in the opposite order.');
          console.log('');
          console.log('');
          console.log('Usage: var x = flip(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#flip');
          break;

        case funkier.fmap:
          console.log('fmap:');
          console.log('');
          console.log('Synonyms: fMap');
          console.log('');
          console.log('Takes a known Functor, and maps the given function over it. Known functors are currently arrays, strings,');
          console.log('Maybes and `Results, although this may change in future versions. Throws if the');
          console.log('first value is not a function of arity 1, or the second is not a known functor.');
          console.log('');
          console.log('');
          console.log('Usage: var x = fmap(f, g)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#fmap');
          break;

        case funkier.foldl:
          console.log('foldl:');
          console.log('');
          console.log('Synonyms: reduce');
          console.log('');
          console.log('Takes three parameters: a function f of two arguments, an initial value, and an array, string or arrayLike.');
          console.log('Traverses the array or string from left to right, calling the function with two arguments: the current accumulation');
          console.log('value, and the current element. The value returned will form the next accumulation value, and foldl returns the');
          console.log('value returned by the final call. The first call\'s accumulation parameter will be the given initial value.');
          console.log('');
          console.log('');
          console.log('Usage: var x = foldl(f, initial, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#foldl');
          break;

        case funkier.foldl1:
          console.log('foldl1:');
          console.log('');
          console.log('Synonyms: reduce1');
          console.log('');
          console.log('Takes two parameters: a function f of two arguments, and an array, string or arrayLike value. Traverses the array');
          console.log('from left to right from the second element, calling the function with two arguments: the current accumulation');
          console.log('value, and the current element. The value returned will form the next accumulation value, and foldl1 returns');
          console.log('returns the value returned by the final call. The first call\'s accumulation parameter will be the first element of');
          console.log('the array or string.');
          console.log('');
          console.log('');
          console.log('Usage: var x = foldl1(f, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#foldl1');
          break;

        case funkier.foldr:
          console.log('foldr:');
          console.log('');
          console.log('Synonyms: reduceRight');
          console.log('');
          console.log('Takes three parameters: a function f of two arguments, an initial value, and an array, string or arrayLike value.');
          console.log('Traverses the array or string from right to left, calling the function with two arguments: the current accumulation');
          console.log('value, and the current element. The value returned will form the next accumulation value, and foldr returns the');
          console.log('value returned by the final call. The first call\'s accumulation parameter willbe the given initial value.');
          console.log('');
          console.log('');
          console.log('Usage: var x = foldr(f, initial, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#foldr');
          break;

        case funkier.foldr1:
          console.log('foldr1:');
          console.log('');
          console.log('Synonyms: reduceRight1');
          console.log('');
          console.log('Takes two parameters: a function f of two arguments, and an array, string or arrayLike. Traverses the array from');
          console.log('right to left from the penultimate element, calling the function with two arguments: the current accumulation');
          console.log('value, and the current element. The value returned will form the next accumulation value, and foldr1 returns');
          console.log('returns the value returned by the final call. The first call\'s accumulation parameter will be the last element of');
          console.log('the array or string.');
          console.log('');
          console.log('');
          console.log('Usage: var x = foldr1(f, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#foldr1');
          break;

        case funkier.fst:
          console.log('fst:');
          console.log('');
          console.log('Synonyms: first');
          console.log('');
          console.log('Accessor function for Pair tuples. Returns the first value that was supplied to the Pair');
          console.log('constructor. Throws if called with a non-pair value.');
          console.log('');
          console.log('');
          console.log('Usage: var x = fst(p)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#fst');
          break;

        case funkier.getCurrentTimeString:
          console.log('getCurrentTimeString:');
          console.log('');
          console.log('A wrapper around calling the Date constructor without the new operator. Returns a string representing the');
          console.log('current date and time.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getCurrentTimeString()');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getcurrenttimestring');
          break;

        case funkier.getDayOfMonth:
          console.log('getDayOfMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.getDate. Takes a Date object, and returns an integer representing the day of');
          console.log('the month (1-31) of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getDayOfMonth(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getdayofmonth');
          break;

        case funkier.getDayOfWeek:
          console.log('getDayOfWeek:');
          console.log('');
          console.log('A wrapper around Date.prototype.getDay. Takes a Date object, and returns an integer representing the day of the');
          console.log('month (0-6) of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getDayOfWeek(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getdayofweek');
          break;

        case funkier.getErrValue:
          console.log('getErrValue:');
          console.log('');
          console.log('Returns the value wrapped by the given Err instance e. Throws a TypeError if called with anything other');
          console.log('than an Err.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getErrValue(e)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#geterrvalue');
          break;

        case funkier.getFullYear:
          console.log('getFullYear:');
          console.log('');
          console.log('A wrapper around Date.prototype.getFullYear. Takes a Date object, and returns a 4-digit integer representing');
          console.log('the year of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getFullYear(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getfullyear');
          break;

        case funkier.getHours:
          console.log('getHours:');
          console.log('');
          console.log('A wrapper around Date.prototype.getHours. Takes a Date object, and returns a integer representing the hour');
          console.log('field (0-23) of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getHours(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#gethours');
          break;

        case funkier.getIndex:
          console.log('getIndex:');
          console.log('');
          console.log('Takes an index and an array, string or other arrayLike value and returns the element at the given index. Throws a');
          console.log('TypeError if the index is outside the range for the given object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getIndex(index, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getindex');
          break;

        case funkier.getJustValue:
          console.log('getJustValue:');
          console.log('');
          console.log('Returns the value wrapped by the given Just instance j. Throws a TypeError if called with anything other');
          console.log('than a Just.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getJustValue(j)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getjustvalue');
          break;

        case funkier.getMilliseconds:
          console.log('getMilliseconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.getMilliseconds. Takes a Date object, and returns a integer representing the');
          console.log('milliseconds field (0-999) of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getMilliseconds(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getmilliseconds');
          break;

        case funkier.getMinutes:
          console.log('getMinutes:');
          console.log('');
          console.log('A wrapper around Date.prototype.getMinutes. Takes a Date object, and returns a integer representing the minutes');
          console.log('field (0-59) of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getMinutes(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getminutes');
          break;

        case funkier.getMonth:
          console.log('getMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.getMonths. Takes a Date object, and returns a integer representing the month');
          console.log('field (0-11) of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getMonth(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getmonth');
          break;

        case funkier.getOkValue:
          console.log('getOkValue:');
          console.log('');
          console.log('Returns the value wrapped by the given Ok instance o. Throws a TypeError if called with anything other');
          console.log('than an Ok.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getOkValue(o)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getokvalue');
          break;

        case funkier.getOwnPropertyDescriptor:
          console.log('getOwnPropertyDescriptor:');
          console.log('');
          console.log('A curried wrapper around Object.getOwnPropertyDescriptor. Takes a property name and an object. If the object');
          console.log('itself has the given property, then the object\'s property descriptor for the given object is returned, otherwise');
          console.log('it returns undefined.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getOwnPropertyDescriptor(prop, o)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getownpropertydescriptor');
          break;

        case funkier.getOwnPropertyNames:
          console.log('getOwnPropertyNames:');
          console.log('');
          console.log('A wrapper around Object.getOwnPropertyNames. Takes an object, and returns an array containing the names of the');
          console.log('object\'s own properties, including non-enumerable properties. Returns an empty array for non-objects. The order of');
          console.log('the property names is not defined.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getOwnPropertyNames(obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getownpropertynames');
          break;

        case funkier.getSeconds:
          console.log('getSeconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.getSeconds. Takes a Date object, and returns a integer representing the seconds');
          console.log('field (0-59) of the given date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getSeconds(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getseconds');
          break;

        case funkier.getTimezoneOffset:
          console.log('getTimezoneOffset:');
          console.log('');
          console.log('A wrapper around Date.prototype.getTimezoneOffset. Takes a Date object, and returns the delta in minutes');
          console.log('between the Javascript environment and UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getTimezoneOffset(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#gettimezoneoffset');
          break;

        case funkier.getType:
          console.log('getType:');
          console.log('');
          console.log('A functional wrapper around the typeof operator. Takes any Javascript value, and returns a string representing');
          console.log('the object\'s type: the result will be one of "number", "string", "boolean", "function", "undefined", or "object".');
          console.log('');
          console.log('');
          console.log('Usage: var x = getType(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#gettype');
          break;

        case funkier.getUTCDayOfMonth:
          console.log('getUTCDayOfMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCDate. Takes a Date object, and returns an integer representing the day of');
          console.log('the month (1-31) of the given date, adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCDayOfMonth(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutcdayofmonth');
          break;

        case funkier.getUTCDayOfWeek:
          console.log('getUTCDayOfWeek:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCDay. Takes a Date object, and returns an integer representing the day of');
          console.log('the week (0-6) of the given date, adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCDayOfWeek(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutcdayofweek');
          break;

        case funkier.getUTCFullYear:
          console.log('getUTCFullYear:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCFullYear. Takes a Date object, and returns a 4-digit integer representing');
          console.log('the year of the given date, adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCFullYear(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutcfullyear');
          break;

        case funkier.getUTCHours:
          console.log('getUTCHours:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCHours. Takes a Date object, and returns an integer representing the hours');
          console.log('field of the given date (0-23), adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCHours(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutchours');
          break;

        case funkier.getUTCMilliseconds:
          console.log('getUTCMilliseconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCMilliseconds. Takes a Date object, and returns an integer representing');
          console.log('the milliseconds field of the given date (0-999), adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCMilliseconds(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutcmilliseconds');
          break;

        case funkier.getUTCMinutes:
          console.log('getUTCMinutes:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCMinutes. Takes a Date object, and returns an integer representing the');
          console.log('minutes field of the given date (0-59), adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCMinutes(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutcminutes');
          break;

        case funkier.getUTCMonth:
          console.log('getUTCMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCMonth. Takes a Date object, and returns an integer representing the month');
          console.log('field of the given date (0-11), adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCMonth(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutcmonth');
          break;

        case funkier.getUTCSeconds:
          console.log('getUTCSeconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.getUTCSeconds. Takes a Date object, and returns an integer representing the');
          console.log('seconds field of the given date (0-59), adjusted for UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = getUTCSeconds(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#getutcseconds');
          break;

        case funkier.greaterThan:
          console.log('greaterThan:');
          console.log('');
          console.log('Synonyms: gt');
          console.log('');
          console.log('A wrapper around the less than or equal (<=) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = greaterThan(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#greaterthan');
          break;

        case funkier.greaterThanEqual:
          console.log('greaterThanEqual:');
          console.log('');
          console.log('Synonyms: gte');
          console.log('');
          console.log('A wrapper around the greater than or equal (=>) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = greaterThanEqual(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#greaterthanequal');
          break;

        case funkier.hasOwnProperty:
          console.log('hasOwnProperty:');
          console.log('');
          console.log('A curried wrapper around Object.prototype.hasOwnProperty. Takes a string representing a property name and an');
          console.log('object, and returns true if the given object itself (i.e. not objects in the prototype chain) has the specified');
          console.log('property.');
          console.log('');
          console.log('');
          console.log('Usage: var x = hasOwnProperty(prop, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#hasownproperty');
          break;

        case funkier.hasProperty:
          console.log('hasProperty:');
          console.log('');
          console.log('A curried wrapper around the in operator. Takes a string representing a property name and an object, and');
          console.log('returns true if the given object or some object in the prototype chain has the specified property.');
          console.log('');
          console.log('');
          console.log('Usage: var x = hasProperty(prop, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#hasproperty');
          break;

        case funkier.head:
          console.log('head:');
          console.log('');
          console.log('Takes an array, string or other arrayLike value and returns the first element. Throws a TypeError when given an');
          console.log('empty arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = head(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#head');
          break;

        case funkier.id:
          console.log('id:');
          console.log('');
          console.log('Returns the supplied value. Superfluous values are ignored.');
          console.log('');
          console.log('');
          console.log('Usage: var x = id(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#id');
          break;

        case funkier.init:
          console.log('init:');
          console.log('');
          console.log('Takes an array, string or arrayLike. Returns an array or string containing every element except the last.');
          console.log('');
          console.log('');
          console.log('Usage: var x = init(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#init');
          break;

        case funkier.inits:
          console.log('inits:');
          console.log('');
          console.log('Synonyms: prefixes');
          console.log('');
          console.log('Takes an array, string or arrayLike. Returns all the prefixes of the given arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = inits(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#inits');
          break;

        case funkier.instanceOf:
          console.log('instanceOf:');
          console.log('');
          console.log('A curried wrapper around the instanceof operator. Takes a constructor function and an object, and returns true');
          console.log('if the function\'s prototype property is in the prototype chain of the given object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = instanceOf(constructor, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#instanceof');
          break;

        case funkier.intersperse:
          console.log('intersperse:');
          console.log('');
          console.log('Takes a value, and an array, string or arrayLike, and returns a new array or string with the value in between each');
          console.log('pair of elements of the original.');
          console.log('');
          console.log('');
          console.log('Usage: var x = intersperse(val, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#intersperse');
          break;

        case funkier.is:
          console.log('is:');
          console.log('');
          console.log('Synonyms: hasType');
          console.log('');
          console.log('Given a string that could be returned by the typeof operator, and a value, returns true if typeof the given');
          console.log('object equals the given string. Throws if the first argument is not a string.');
          console.log('');
          console.log('');
          console.log('Usage: var x = is(type, value)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#is');
          break;

        case funkier.isArray:
          console.log('isArray:');
          console.log('');
          console.log('Returns true if the given value is an array, false otherwise');
          console.log('');
          console.log('');
          console.log('Usage: var x = isArray(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isarray');
          break;

        case funkier.isBoolean:
          console.log('isBoolean:');
          console.log('');
          console.log('Returns true if typeof the given value equals "boolean", false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isBoolean(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isboolean');
          break;

        case funkier.isEmpty:
          console.log('isEmpty:');
          console.log('');
          console.log('Returns true if the given array, arrayLike or string is empty, and false if not.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isEmpty(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isempty');
          break;

        case funkier.isErr:
          console.log('isErr:');
          console.log('');
          console.log('Returns true when the given value is a Err object, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isErr(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#iserr');
          break;

        case funkier.isJust:
          console.log('isJust:');
          console.log('');
          console.log('Returns true if the given value is a Just object, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isJust(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isjust');
          break;

        case funkier.isMaybe:
          console.log('isMaybe:');
          console.log('');
          console.log('Returns true when the given value is a Maybe object, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isMaybe(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#ismaybe');
          break;

        case funkier.isNothing:
          console.log('isNothing:');
          console.log('');
          console.log('Returns true if the given value is the Nothing object, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isNothing(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isnothing');
          break;

        case funkier.isNull:
          console.log('isNull:');
          console.log('');
          console.log('Returns true if the given object is null, false otherwise');
          console.log('');
          console.log('');
          console.log('Usage: var x = isNull(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isnull');
          break;

        case funkier.isNumber:
          console.log('isNumber:');
          console.log('');
          console.log('Returns true if typeof the given value equals "number", false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isNumber(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isnumber');
          break;

        case funkier.isObject:
          console.log('isObject:');
          console.log('');
          console.log('Returns true if typeof the given value equals "object", false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isObject(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isobject');
          break;

        case funkier.isOk:
          console.log('isOk:');
          console.log('');
          console.log('Returns true when the given value is a Ok object, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isOk(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isok');
          break;

        case funkier.isPair:
          console.log('isPair:');
          console.log('');
          console.log('Returns true if the given value is a Pair, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isPair(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#ispair');
          break;

        case funkier.isPrototypeOf:
          console.log('isPrototypeOf:');
          console.log('');
          console.log('A curried wrapper around Object.prototype.isPrototypeOf. Takes two objects: the prototype object, and the object');
          console.log('whose prototype chain you wish to check.  Returns true if protoObj is in the prototype chain of o.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isPrototypeOf(protoObject, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isprototypeof');
          break;

        case funkier.isRealObject:
          console.log('isRealObject:');
          console.log('');
          console.log('Returns true if the value is a real Javascript object, i.e. an object for which funkierJS.isObject(a) === true');
          console.log('and funkierJS.isNull(a) === false and funkierJS.isArray(a) === false.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isRealObject(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isrealobject');
          break;

        case funkier.isResult:
          console.log('isResult:');
          console.log('');
          console.log('Returns true when the given value is a Result object, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isResult(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isresult');
          break;

        case funkier.isString:
          console.log('isString:');
          console.log('');
          console.log('Returns true if typeof the given value equals "string", false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isString(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isstring');
          break;

        case funkier.isUndefined:
          console.log('isUndefined:');
          console.log('');
          console.log('Returns true if typeof the given value equals "undefined", false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = isUndefined(a)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#isundefined');
          break;

        case funkier.join:
          console.log('join:');
          console.log('');
          console.log('Takes a separator value that can be coerced to a string, and an array. Returns a string, containing the toString');
          console.log('of each element in the array, separated by the toString of the given separator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = join(separator, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#join');
          break;

        case funkier.keyValues:
          console.log('keyValues:');
          console.log('');
          console.log('Takes an object, and returns an array containing 2-element arrays. The first element of each sub-array is the name');
          console.log('of a property from the object, and the second element is the value of the property. This function only returns');
          console.log('key-value pairs for the object\'s own properties. Returns an empty array for non-objects.  The order of the values');
          console.log('is not defined.');
          console.log('');
          console.log('');
          console.log('Usage: var x = keyValues(obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#keyvalues');
          break;

        case funkier.keys:
          console.log('keys:');
          console.log('');
          console.log('A wrapper around Object.keys. Takes an object, and returns an array containing the names of the object\'s own');
          console.log('properties. Returns an empty array for non-objects.');
          console.log('');
          console.log('');
          console.log('Usage: var x = keys(obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#keys');
          break;

        case funkier.last:
          console.log('last:');
          console.log('');
          console.log('Takes an array, string or other arrayLike value, and returns the last element. Throws a TypeError when given an');
          console.log('empty arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = last(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#last');
          break;

        case funkier.leftShift:
          console.log('leftShift:');
          console.log('');
          console.log('A wrapper around the left shift (<<) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = leftShift(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#leftshift');
          break;

        case funkier.length:
          console.log('length:');
          console.log('');
          console.log('Takes an array, string or other arrayLike value, and returns its length. Throws a TypeError if the given value is not an arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = length(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#length');
          break;

        case funkier.lessThan:
          console.log('lessThan:');
          console.log('');
          console.log('Synonyms: lt');
          console.log('');
          console.log('A wrapper around the less than (<) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = lessThan(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#lessthan');
          break;

        case funkier.lessThanEqual:
          console.log('lessThanEqual:');
          console.log('');
          console.log('Synonyms: lte');
          console.log('');
          console.log('A wrapper around the less than or equal (<=) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = lessThanEqual(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#lessthanequal');
          break;

        case funkier.log:
          console.log('log:');
          console.log('');
          console.log('Returns the logarithm of y in the given base x. Note that this function uses the change of base formula, so may');
          console.log('be subject to rounding errors.');
          console.log('');
          console.log('');
          console.log('Usage: var x = log(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#log');
          break;

        case funkier.makeDateFromMilliseconds:
          console.log('makeDateFromMilliseconds:');
          console.log('');
          console.log('A wrapper around calling the Date constructor with a single numeric argument. Throws a TypeError when called with a');
          console.log('non-numeric argument. Returns a new Date object whose value represents the date which is that many elapsed');
          console.log('milliseconds since the epoch.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeDateFromMilliseconds(milliseconds)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makedatefrommilliseconds');
          break;

        case funkier.makeDateFromString:
          console.log('makeDateFromString:');
          console.log('');
          console.log('A wrapper around calling the Date constructor with a single string argument. Throws a TypeError when called with');
          console.log('a non-string argument, or a string that cannot be parsed as a date. Returns a new Date object whose value');
          console.log('represents that given in the string.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeDateFromString(dateString)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makedatefromstring');
          break;

        case funkier.makeDayDate:
          console.log('makeDayDate:');
          console.log('');
          console.log('A curried wrapper around calling the Date constructor with three arguments: the year, the month and the day. No');
          console.log('validation or type-checking occurs on the parameters. Excess arguments are ignored. All other fields in the Date');
          console.log('are initialized to zero. Returns the new Date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeDayDate(year, month, day)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makedaydate');
          break;

        case funkier.makeHourDate:
          console.log('makeHourDate:');
          console.log('');
          console.log('A curried wrapper around calling the Date constructor with four arguments: the year, the month, the day and the');
          console.log('hour. No validation or type-checking occurs on the parameters. Excess arguments are ignored. All other fields in');
          console.log('the Date are initialized to zero. Returns the new Date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeHourDate(year, month, day, hour)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makehourdate');
          break;

        case funkier.makeMaybeReturner:
          console.log('makeMaybeReturner:');
          console.log('');
          console.log('Takes a function f. Returns a new function with the same arity as f. When called, the new function calls the');
          console.log('original. If the function f throws during execution, then the Nothing object is returned. Otherwise the result of');
          console.log('the function is wrapped in a Just and returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeMaybeReturner(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makemaybereturner');
          break;

        case funkier.makeMillisecondDate:
          console.log('makeMillisecondDate:');
          console.log('');
          console.log('A curried wrapper around calling the Date constructor with seven arguments: the year, the month, the day, the');
          console.log('hour, the minute, the seconds, and the milliseconds. No validation or type-checking occurs on the parameters.');
          console.log('Returns the new Date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeMillisecondDate(year, month, day, hour, minute, second, millisecond)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makemilliseconddate');
          break;

        case funkier.makeMinuteDate:
          console.log('makeMinuteDate:');
          console.log('');
          console.log('A curried wrapper around calling the Date constructor with five arguments: the year, the month, the day, the hour');
          console.log('and the minute. No validation or type-checking occurs on the parameters. Excess arguments are ignored. All other');
          console.log('fields in the Date are initialized to zero. Returns the new Date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeMinuteDate(year, month, day, hour, minute)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makeminutedate');
          break;

        case funkier.makeMonthDate:
          console.log('makeMonthDate:');
          console.log('');
          console.log('A curried wrapper around calling the Date constructor with two arguments: the year and the month. No validation');
          console.log('or type-checking occurs on the parameters. Excess arguments are ignored. All other fields in the Date are');
          console.log('initialized to zero, with the exception of the day, which is initialized to 1. Returns the new Date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeMonthDate(year, month)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makemonthdate');
          break;

        case funkier.makeResultReturner:
          console.log('makeResultReturner:');
          console.log('');
          console.log('Takes a function f. Returns a new function with the same arity as f. When called, the new function calls the');
          console.log('original. If the function f throws during execution, then the exception will be caught, and an Err object');
          console.log('wrapping the exception is returned. Otherwise the result of the function is wrapped in an Ok and returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeResultReturner(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makeresultreturner');
          break;

        case funkier.makeSecondDate:
          console.log('makeSecondDate:');
          console.log('');
          console.log('A curried wrapper around calling the Date constructor with six arguments: the year, the month, the day, the hour,');
          console.log('the minute, and the seconds. No validation or type-checking occurs on the parameters. Excess arguments are ignored.');
          console.log('All other fields in the Date are initialized to zero. Returns the new Date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = makeSecondDate(year, month, day, hour, minute, second)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#makeseconddate');
          break;

        case funkier.map:
          console.log('map:');
          console.log('');
          console.log('Takes a function f, and an array,string or other arrayLike. Returns an array arr2 where, for each element arr2[i],');
          console.log('we have arr2[i] === f(arr[i]). Throws a TypeError if the first argument is not a function, if the function does not');
          console.log('have an arity of at least 1, or if the last argument is not an arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = map(f, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#map');
          break;

        case funkier.matches:
          console.log('matches:');
          console.log('');
          console.log('Finds all matches within a string for a given regular expression. Takes two parameters: a regular expression and a');
          console.log('string. Returns an array of objects, one object per match.');
          console.log('');
          console.log('');
          console.log('Usage: var x = matches(r, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#matches');
          break;

        case funkier.matchesFrom:
          console.log('matchesFrom:');
          console.log('');
          console.log('Finds all matches within a string for a given regular expression from the given index. Takes three parameters: a');
          console.log('regular expression, an index and a string. Returns an array of objects, one object per match.');
          console.log('');
          console.log('');
          console.log('Usage: var x = matchesFrom(r, index, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#matchesfrom');
          break;

        case funkier.max:
          console.log('max:');
          console.log('');
          console.log('A curried wrapper around Math.max. Takes exactly two arguments.');
          console.log('');
          console.log('');
          console.log('Usage: var x = max(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#max');
          break;

        case funkier.maximum:
          console.log('maximum:');
          console.log('');
          console.log('Returns the largest element of the given array, string or arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = maximum(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#maximum');
          break;

        case funkier.maybeExtract:
          console.log('maybeExtract:');
          console.log('');
          console.log('Synonyms: safeExtract, maybeTap, safeTap');
          console.log('');
          console.log('Extracts the given property from the given object, and wraps it in a Just value. When the property is');
          console.log('not present, either in the object, or its prototype chain, then Nothing is returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = maybeExtract(prop, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#maybeextract');
          break;

        case funkier.min:
          console.log('min:');
          console.log('');
          console.log('A curried wrapper around Math.min. Takes exactly two arguments.');
          console.log('');
          console.log('');
          console.log('Usage: var x = min(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#min');
          break;

        case funkier.minimum:
          console.log('minimum:');
          console.log('');
          console.log('Returns the smallest element of the given array, string or arrayLike. Throws a TypeError if the value is not an');
          console.log('arrayLike, or it is empty.');
          console.log('');
          console.log('');
          console.log('Usage: var x = minimum(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#minimum');
          break;

        case funkier.modify:
          console.log('modify:');
          console.log('');
          console.log('Synonyms: modifyProp');
          console.log('');
          console.log('Sets the given property to the given value on the given object, providing it exists, and returns the object.');
          console.log('Equivalent to evaluating o[prop] = value. The property will not be created when it doesn\'t exist on the object.');
          console.log('Throws when the property is not writable, when it has no setter function, or when the object is frozen.');
          console.log('');
          console.log('');
          console.log('Usage: var x = modify(prop, val, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#modify');
          break;

        case funkier.multiply:
          console.log('multiply:');
          console.log('');
          console.log('A wrapper around the multiplication operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = multiply(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#multiply');
          break;

        case funkier.not:
          console.log('not:');
          console.log('');
          console.log('A wrapper around the logical not (!) operator. Returns the logical negation of the given argument.');
          console.log('');
          console.log('');
          console.log('Usage: var x = not(b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#not');
          break;

        case funkier.notEqual:
          console.log('notEqual:');
          console.log('');
          console.log('Synonyms: notEquals');
          console.log('');
          console.log('A wrapper around the inequality (!=) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = notEqual(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#notequal');
          break;

        case funkier.notPred:
          console.log('notPred:');
          console.log('');
          console.log('Takes a unary predicate function, and returns a new unary function that, when called, will call the original');
          console.log('function with the given argument, and return the negated result. Throws if f is not a function, or has an');
          console.log('arity other than 1.');
          console.log('');
          console.log('');
          console.log('Usage: var x = notPred(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#notpred');
          break;

        case funkier.nub:
          console.log('nub:');
          console.log('');
          console.log('Synonyms: uniq');
          console.log('');
          console.log('Takes an array, string or arrayLike. Returns a new array/string, with all duplicate elementstested for strict');
          console.log('equalityremoved. The order of elements is preserved.');
          console.log('');
          console.log('');
          console.log('Usage: var x = nub(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#nub');
          break;

        case funkier.nubWith:
          console.log('nubWith:');
          console.log('');
          console.log('Synonyms: uniqWith');
          console.log('');
          console.log('Takes a predicate function of arity 2, and an array, string or arrayLike. Returns a new array/string, with all');
          console.log('duplicate elements removed. A duplicate is defined as a value for which the predicate function returned true when');
          console.log('called with a previously encountered element and the element under consideration. The order of elements is');
          console.log('preserved.');
          console.log('');
          console.log('');
          console.log('Usage: var x = nubWith(pred, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#nubwith');
          break;

        case funkier.objectCurry:
          console.log('objectCurry:');
          console.log('');
          console.log('Given a function, returns a curried function which calls the underlying with the execution context active when the');
          console.log('first arguments are supplied. This means that when partially applying the function, the resulting functions will');
          console.log('have their execution context permanently bound. This method of binding is designed for currying functions that');
          console.log('exist on an object\'s prototype. The function will be only called when sufficient arguments have been supplied.');
          console.log('Superfluous arguments are discarded. The resulting function may be called without any arguments even when it has');
          console.log('non-zero arity, for the purposes of establishing an execution context (usually when passing the function to some');
          console.log('other function-manipulating function); however the partial applications of the result will throw if they');
          console.log('require at least one argument, but are invoked without any. objectCurry throws if its parameter is not a');
          console.log('function. The resulting function will throw if invoked with an undefined execution context.');
          console.log('');
          console.log('');
          console.log('Usage: var x = objectCurry(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#objectcurry');
          break;

        case funkier.objectCurryWithArity:
          console.log('objectCurryWithArity:');
          console.log('');
          console.log('Given an arity and function, returns a curried function which calls the underlying with the execution context');
          console.log('active when the first arguments are supplied. This means that when partially applying the function, the');
          console.log('resulting functions will have their execution context permanently bound. This method of binding is designed for');
          console.log('currying functions that exist on an object\'s prototype. The function will be only called when the specified number');
          console.log('of arguments have been supplied. Superfluous arguments are discarded. If the resulting function has non-zero');
          console.log('length, it may be called without any arguments for the purpose of establishing an execution context; however');
          console.log('its partial applications throw if they require at least one argument, but are invoked without any.');
          console.log('objectCurryWithArity throws if the arity is not a natural number or if the second parameter is not a function.');
          console.log('The resulting function will throw if invoked with an undefined execution context.');
          console.log('');
          console.log('');
          console.log('Usage: var x = objectCurryWithArity(n, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#objectcurrywitharity');
          break;

        case funkier.occurrences:
          console.log('occurrences:');
          console.log('');
          console.log('Takes a valueneedleand haystack, an array, arrayLike or string. Searches for all occurrences of the valuetested');
          console.log('for strict equalityand returns an array containing all the indices into haystack where the values may be found.');
          console.log('');
          console.log('');
          console.log('Usage: var x = occurrences(needle, haystack)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#occurrences');
          break;

        case funkier.occurrencesWith:
          console.log('occurrencesWith:');
          console.log('');
          console.log('Takes a predicate function pred, and haystack, an array, arrayLike or string. Searches for all occurrences of the');
          console.log('valuetested by the given predicateand returns an array containing all the indices into haystack where the');
          console.log('predicate holds.');
          console.log('');
          console.log('');
          console.log('Usage: var x = occurrencesWith(needle, haystack)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#occurrenceswith');
          break;

        case funkier.odd:
          console.log('odd:');
          console.log('');
          console.log('Given a number, returns true if it is not divisible by 2, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = odd(x)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#odd');
          break;

        case funkier.or:
          console.log('or:');
          console.log('');
          console.log('A wrapper around the logical or (||) operator. Returns the logical or of the given arguments');
          console.log('');
          console.log('');
          console.log('Usage: var x = or(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#or');
          break;

        case funkier.orPred:
          console.log('orPred:');
          console.log('');
          console.log('Takes two unary predicate functions, and returns a new unary function that, when called, will call the original');
          console.log('functions with the given argument, and logically or their results, returning that value. Throws if either');
          console.log('argument is not a function of arity 1.');
          console.log('');
          console.log('');
          console.log('Usage: var x = orPred(f1, f2)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#orpred');
          break;

        case funkier.ord:
          console.log('ord:');
          console.log('');
          console.log('Takes a string s, and returns the Unicode value of the character at index 0. Equivalent to toCharCode(0, s).');
          console.log('');
          console.log('');
          console.log('Usage: var x = ord(s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#ord');
          break;

        case funkier.parseInt:
          console.log('parseInt:');
          console.log('');
          console.log('A curried wrapper around parseInt when called with one argument. Takes a string and attempts to convert it');
          console.log('assuming it represents a number in base 10. Returns NaN if the string does not represent a valid number in base');
          console.log('10.');
          console.log('');
          console.log('');
          console.log('Usage: var x = parseInt(s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#parseint');
          break;

        case funkier.permuteLeft:
          console.log('permuteLeft:');
          console.log('');
          console.log('Synonyms: rotateLeft');
          console.log('');
          console.log('Takes a function, returns a curried function of the same arity which takes the same parameters, except in a');
          console.log('different position. The first parameter of the original function will be the last parameter of the new function,');
          console.log('the second parameter of the original will be the first parameter of the new function and so on. This function is');
          console.log('essentially a no-op for curried functions of arity 0 and 1, equivalent to curry for uncurried');
          console.log('functions of arities 0 and 1, and equivalent to flip for functions of arity 2.');
          console.log('');
          console.log('');
          console.log('Usage: var x = permuteLeft(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#permuteleft');
          break;

        case funkier.permuteRight:
          console.log('permuteRight:');
          console.log('');
          console.log('Synonyms: rotateRight');
          console.log('');
          console.log('Takes a function, returns a curried function of the same arity which takes the same parameters, except in a');
          console.log('different position. The first parameter of the original function will be the second parameter of the new function,');
          console.log('the second parameter of the original will be the third parameter of the new function and so on. This function is');
          console.log('essentially a no-op for curried functions of arity 0 and 1, equivalent to curry for uncurried');
          console.log('functions of arities 0 and 1, and equivalent to flip for functions of arity 2.');
          console.log('');
          console.log('');
          console.log('Usage: var x = permuteRight(f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#permuteright');
          break;

        case funkier.post:
          console.log('post:');
          console.log('');
          console.log('Takes two functions wrappingFunction, and f, and returns a new function with the same arity as the function f,');
          console.log('and curried in the same manner (or curried with curry if f was not curried). When this new function');
          console.log('is called, it will first call f with the same execution context and arguments that the new function was called');
          console.log('with. Its return value will be saved. Next, wrappingFunction will be called, again with the same execution');
          console.log('context, and two arguments: an array containing the arguments to f, and f\'s return value. Anything returned from');
          console.log('wrappingFunction will be discarded, and f\'s return value will be returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = post(wrappingFunction, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#post');
          break;

        case funkier.pre:
          console.log('pre:');
          console.log('');
          console.log('Takes two functions wrappingFunction, and f, and returns a new function with the same arity as the function f,');
          console.log('and curried in the same manner (or curried with curry if f was not curried). When this new function');
          console.log('is called, it will first call wrappingFunction, with the same execution context, and a single argument: an array');
          console.log('containing all the arguments the function was called with. When wrappingFunction returns, its return value');
          console.log('will be discarded, and f will be called with the same execution context and invoked with the same arguments as the');
          console.log('new function was invoked with. The return value from f will be returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = pre(wrappingFunction, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#pre');
          break;

        case funkier.prepend:
          console.log('prepend:');
          console.log('');
          console.log('Takes a value, and an array, string or arrayLike, and returns a new array or string with the given value prepended.');
          console.log('');
          console.log('');
          console.log('Usage: var x = prepend(value, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#prepend');
          break;

        case funkier.product:
          console.log('product:');
          console.log('');
          console.log('Returns the product of the elements of the given array, or arrayLike. Throws a TypeError if the value is not an');
          console.log('arrayLike, or it is empty.');
          console.log('');
          console.log('');
          console.log('Usage: var x = product(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#product');
          break;

        case funkier.range:
          console.log('range:');
          console.log('');
          console.log('Takes two numbers, a and b. Returns an array containing the arithmetic sequence of elements from a up to but not');
          console.log('including b, each element increasing by 1.');
          console.log('');
          console.log('');
          console.log('Usage: var x = range(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#range');
          break;

        case funkier.rangeStride:
          console.log('rangeStride:');
          console.log('');
          console.log('Synonyms: rangeStep');
          console.log('');
          console.log('Takes three numbers, a stride and b. Returns an array containing the arithmetic sequence of elements from a up to');
          console.log('but not including b, each element increasing by stride.');
          console.log('');
          console.log('');
          console.log('Usage: var x = rangeStride(a, stride, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#rangestride');
          break;

        case funkier.regExpSplit:
          console.log('regExpSplit:');
          console.log('');
          console.log('Synonyms: splitRegExp');
          console.log('');
          console.log('A curried wrapper around String.prototype.split. Takes a pattern regexp, and a target string s, and returns an');
          console.log('array containing the substrings of s that were separated by substrings matching the given pattern.');
          console.log('');
          console.log('');
          console.log('Usage: var x = regExpSplit(delimiter, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#regexpsplit');
          break;

        case funkier.regExpSplitMax:
          console.log('regExpSplitMax:');
          console.log('');
          console.log('Synonyms: regExpSplitLimit, regExpSplitCount');
          console.log('');
          console.log('A curried wrapper around String.prototype.split. Takes a RegExp delimiter, a count, and a target string s, and');
          console.log('returns an array containing the substrings of s that were separated by strings matching the given delimiter, the');
          console.log('returned array containing at most limit such substrings.');
          console.log('');
          console.log('');
          console.log('Usage: var x = regExpSplitMax(delimiter, limit, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#regexpsplitmax');
          break;

        case funkier.rem:
          console.log('rem:');
          console.log('');
          console.log('A wrapper around the remainder (%) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = rem(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#rem');
          break;

        case funkier.replicate:
          console.log('replicate:');
          console.log('');
          console.log('Takes a length and a value, and returns an array of the given length, where each element is the given value. Throws');
          console.log('a TypeError if the given length is negative.');
          console.log('');
          console.log('');
          console.log('Usage: var x = replicate(length, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#replicate');
          break;

        case funkier.reverse:
          console.log('reverse:');
          console.log('');
          console.log('Takes an array, string or arrayLike, and returns a new array or string that is the reverse of the original.');
          console.log('');
          console.log('');
          console.log('Usage: var x = reverse(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#reverse');
          break;

        case funkier.rightShift:
          console.log('rightShift:');
          console.log('');
          console.log('A wrapper around the right shift (>>) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = rightShift(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#rightshift');
          break;

        case funkier.rightShiftZero:
          console.log('rightShiftZero:');
          console.log('');
          console.log('A wrapper around the left shift (>>>) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = rightShiftZero(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#rightshiftzero');
          break;

        case funkier.safeCreateProp:
          console.log('safeCreateProp:');
          console.log('');
          console.log('Synonyms: maybeCreate');
          console.log('');
          console.log('Creates the given property to the given value on the given object, returning the object wrapped in a Just.');
          console.log('Equivalent to evaluating o[prop] = value. The property will be not be modified if it already exists; in');
          console.log('that case Nothing will be returned. Additionally, Nothing will be returned when the object is frozen, sealed, or');
          console.log('cannot be extended. Note that the property will be successfully created when it already exists, but only in the');
          console.log('prototype chain.');
          console.log('');
          console.log('');
          console.log('Usage: var x = safeCreateProp(prop, val, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#safecreateprop');
          break;

        case funkier.safeDeleteProp:
          console.log('safeDeleteProp:');
          console.log('');
          console.log('Synonyms: maybeDelete');
          console.log('');
          console.log('Deletes the given property from the given the given object, returning the object wrapped as a Just');
          console.log('value. Equivalent to evaluating delete o[prop]. When the property is not configurable (either due to the');
          console.log('individual descriptor or the object being frozen or sealed) then Nothing will be returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = safeDeleteProp(prop, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#safedeleteprop');
          break;

        case funkier.safeModify:
          console.log('safeModify:');
          console.log('');
          console.log('Synonyms: maybeModify, maybeModifyProp, safeModifyProp');
          console.log('');
          console.log('Sets the given property to the given value on the given object, providing it exists, and returns the object,');
          console.log('wrapped in a Just value when successful. Equivalent to evaluating o[prop] = value. The property will');
          console.log('not be created when it doesn\'t exist on the object; nor will it be amended when the property is not writable, when');
          console.log('it has no setter function, or when the object is frozen. In such cases, Nothing will be returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = safeModify(prop, val, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#safemodify');
          break;

        case funkier.safeSet:
          console.log('safeSet:');
          console.log('');
          console.log('Synonyms: maybeSet, maybeSetProp, safeSetProp');
          console.log('');
          console.log('Sets the given property to the given value on the given object, returning the object wrapped in a Just');
          console.log('value when successful. Equivalent to evaluating o[prop] = value. The property will be created if it doesn\'t exist');
          console.log('on the object. If unable to modify or create the property, then Nothing will be returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = safeSet(prop, val, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#safeset');
          break;

        case funkier.sectionLeft:
          console.log('sectionLeft:');
          console.log('');
          console.log('Partially applies the binary function f with the given argument x, with x being supplied as the first argument');
          console.log('to f. The given function f will be curried if necessary. Throws if f is not a binary function.');
          console.log('');
          console.log('');
          console.log('Usage: var x = sectionLeft(f, x)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#sectionleft');
          break;

        case funkier.sectionRight:
          console.log('sectionRight:');
          console.log('');
          console.log('Partially applies the binary function f with the given argument x, with x being supplied as the second argument');
          console.log('to f. The given function f will be curried if necessary. Throws if f is not a binary function.');
          console.log('');
          console.log('');
          console.log('Usage: var x = sectionRight(f, x)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#sectionright');
          break;

        case funkier.set:
          console.log('set:');
          console.log('');
          console.log('Synonyms: setProp');
          console.log('');
          console.log('Sets the given property to the given value on the given object, returning the object. Equivalent to evaluating');
          console.log('o[prop] = value. The property will be created if it doesn\'t exist on the object. Throws when the property is');
          console.log('not writable, when it has no setter function, when the object is frozen, or when it is sealed and the property');
          console.log('is not already present.');
          console.log('');
          console.log('');
          console.log('Usage: var x = set(prop, val, obj)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#set');
          break;

        case funkier.setDayOfMonth:
          console.log('setDayOfMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.setDate. Takes a value between 1 and 31, and a Date object, and sets the day of');
          console.log('the month to the given value. Invalid values will cause a change in other fields: for example, changing the day to');
          console.log('31 in a month with 30 days will increment the month, which may in turn increment the year. Returns the given \'Date`');
          console.log('object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setDayOfMonth(day, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setdayofmonth');
          break;

        case funkier.setFullYear:
          console.log('setFullYear:');
          console.log('');
          console.log('A wrapper around Date.prototype.setFullYear. Takes a value and a Date object, and sets the year to the given');
          console.log('value. This may cause a change in other fields: for example, setting the year when the month and day represent');
          console.log('February 29 respectively may cause those values to change to March 1 if the new year is not a leap year.');
          console.log('Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setFullYear(year, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setfullyear');
          break;

        case funkier.setHours:
          console.log('setHours:');
          console.log('');
          console.log('A wrapper around Date.prototype.setHours. Takes a value between 0 and 23 representing the hour of the day, and');
          console.log('a Date object, and sets the hour to the given value. Invalid values will cause a change in other fields: if the');
          console.log('value > 23, then the day will be incremented by hours div 24. This may in turn cause a cascade of increments');
          console.log('to other fields. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setHours(hours, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#sethours');
          break;

        case funkier.setMilliseconds:
          console.log('setMilliseconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.setMilliseconds. Takes a value between 0 and 999 representing the milliseconds,');
          console.log('and a Date object, and sets the milliseconds to the given value. Invalid values will cause a change in other');
          console.log('fields: if the value > 999, then the seconds will be incremented by milliseconds div 1000. This may in turn cause');
          console.log('a cascade of increments to other fields. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setMilliseconds(milliseconds, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setmilliseconds');
          break;

        case funkier.setMinutes:
          console.log('setMinutes:');
          console.log('');
          console.log('A wrapper around Date.prototype.setMinutes. Takes a value between 0 and 59 representing the minutes, and a');
          console.log('Date object, and sets the minutes to the given value. Invalid values will cause a change in other fields: if the');
          console.log('value > 59, then the hours will be incremented by minutes div 60. This may in turn cause a cascade of increments');
          console.log('to other fields. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setMinutes(minutes, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setminutes');
          break;

        case funkier.setMonth:
          console.log('setMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.setMonth. Takes a value between 0 and 11 representing the month, and a Date');
          console.log('object, and sets the month to the given value. Invalid values will cause a change in other fields: if the');
          console.log('value > 11, then the year will be incremented by month div 12. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setMonth(month, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setmonth');
          break;

        case funkier.setSeconds:
          console.log('setSeconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.setSeconds. Takes a value between 0 and 59 representing the seconds, and a');
          console.log('Date object, and sets the seconds to the given value. Invalid values will cause a change in other fields: if the');
          console.log('value > 59, then the minutes will be incremented by seconds div 60. This may in turn cause a cascade of increments');
          console.log('to other fields. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setSeconds(seconds, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setseconds');
          break;

        case funkier.setTimeSinceEpoch:
          console.log('setTimeSinceEpoch:');
          console.log('');
          console.log('A wrapper around Date.prototype.setTime. Takes a value representing the number of seconds since midnight,');
          console.log('January 1, 1970 and a date. Simultaneously sets all of the fields of the given date to represent the date and');
          console.log('time that is that many seconds since the epoch. Returns the given Date.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setTimeSinceEpoch(milliseconds, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#settimesinceepoch');
          break;

        case funkier.setUTCDayOfMonth:
          console.log('setUTCDayOfMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.setUTCDate. Takes a value between 1 and 31, and a Date object, and sets the day');
          console.log('of the month to the local equivalent of the given value. Invalid values will cause a change in other fields: for');
          console.log('example, changing the day to 31 in a month with 30 days will increment the month, which may in turn increment the');
          console.log('year. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setUTCDayOfMonth(day, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setutcdayofmonth');
          break;

        case funkier.setUTCFullYear:
          console.log('setUTCFullYear:');
          console.log('');
          console.log('A wrapper around Date.prototype.setUTCFullYear. Takes a value and a Date object, and sets the year to the local');
          console.log('equivalent of the given value. This may cause a change in other fields: for example, setting the year when the');
          console.log('month and day represent February 29 respectively may cause those values to change to March 1 if the new year is not');
          console.log('a leap year. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setUTCFullYear(year, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setutcfullyear');
          break;

        case funkier.setUTCHours:
          console.log('setUTCHours:');
          console.log('');
          console.log('A wrapper around Date.prototype.setUTCHours. Takes a value between 0 and 23 representing the hour of the day, and');
          console.log('a Date object, and sets the hour to the local equivalent of the given value. Invalid values will cause a change');
          console.log('in other fields: if the value > 23, then the day will be incremented by hours div 24. This may in turn cause a');
          console.log('cascade of increments to other fields. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setUTCHours(hours, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setutchours');
          break;

        case funkier.setUTCMilliseconds:
          console.log('setUTCMilliseconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.setUTCMilliseconds. Takes a value between 0 and 999 representing the');
          console.log('milliseconds, and a Date object, and sets the milliseconds to the local equivalent of the given value. Invalid');
          console.log('values will cause a change in other fields: if the value > 999, then the seconds will be incremented by');
          console.log('milliseconds div 1000. This may in turn cause a cascade of increments to other fields. Returns the given Date');
          console.log('object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setUTCMilliseconds(milliseconds, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setutcmilliseconds');
          break;

        case funkier.setUTCMinutes:
          console.log('setUTCMinutes:');
          console.log('');
          console.log('A wrapper around Date.prototype.setUTCMinutes. Takes a value between 0 and 59 representing the minutes, and a');
          console.log('Date object, and sets the minutes to the local equivalent of the given value. Invalid values will cause a change');
          console.log('in other fields: if the value > 59, then the hours will be incremented by minutes div 60. This may in turn cause a');
          console.log('cascade of increments to other fields. Returns the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setUTCMinutes(minutes, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setutcminutes');
          break;

        case funkier.setUTCMonth:
          console.log('setUTCMonth:');
          console.log('');
          console.log('A wrapper around Date.prototype.setUTCMonth. Takes a value between 0 and 11 representing the month, and a');
          console.log('Date object, and sets the month to the local equivalent of the given value. Invalid values will cause a change');
          console.log('in other fields: if the value > 11, then the year will be incremented by month div 12. Returns the given Date');
          console.log('object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setUTCMonth(month, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setutcmonth');
          break;

        case funkier.setUTCSeconds:
          console.log('setUTCSeconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.setUTCSeconds. Takes a value between 0 and 59 representing the seconds, and a');
          console.log('Date object, and sets the seconds to the local equivalent of the given value. Invalid values will cause a change');
          console.log('in other fields: if the value > 59, then the minutes will be incremented by seconds div 60. This may in turn cause');
          console.log('a cascade of increments to other fields. Returns the local equivalent of the given Date object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = setUTCSeconds(seconds, d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#setutcseconds');
          break;

        case funkier.slice:
          console.log('slice:');
          console.log('');
          console.log('Takes two numbers, from and to, and an array, string or arrayLike. Returns the subarray or string containing the');
          console.log('elements between these two points (inclusive at from, exclusive at to). If to is greater than the length of the');
          console.log('object, then all values from \'from\' will be returned.');
          console.log('');
          console.log('');
          console.log('Usage: var x = slice(from, to, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#slice');
          break;

        case funkier.snd:
          console.log('snd:');
          console.log('');
          console.log('Synonyms: second');
          console.log('');
          console.log('Accessor function for Pair tuples. Returns the second value that was supplied to the Pair');
          console.log('constructor. Throws if called with a non-pair value.');
          console.log('');
          console.log('');
          console.log('Usage: var x = snd(p)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#snd');
          break;

        case funkier.some:
          console.log('some:');
          console.log('');
          console.log('Synonyms: any');
          console.log('');
          console.log('Takes two parameters: a predicate function p that takes one argument, and an array, string or arrayLike. Calls the');
          console.log('predicate with every element of the array or string, until either the predicate function returns true, or the end');
          console.log('of the array or string is reached.');
          console.log('');
          console.log('');
          console.log('Usage: var x = some(pred, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#some');
          break;

        case funkier.sort:
          console.log('sort:');
          console.log('');
          console.log('Takes an array, string or arrayLike, and returns a new array, sorted in lexicographical order.');
          console.log('');
          console.log('');
          console.log('Usage: var x = sort(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#sort');
          break;

        case funkier.sortWith:
          console.log('sortWith:');
          console.log('');
          console.log('Takes a function of two arguments, and an array, string or arrayLike. Returns a new array/string, sorted per the');
          console.log('given function. The function should return a negative number if the first argument is "less than" the second, 0 if');
          console.log('the two arguments are "equal", and a positive number if the first argument is greater than the second.');
          console.log('');
          console.log('');
          console.log('Usage: var x = sortWith(f, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#sortwith');
          break;

        case funkier.split:
          console.log('split:');
          console.log('');
          console.log('A curried wrapper around String.prototype.split. Takes a string delimiter, and a target string s, and returns an');
          console.log('array containing the substrings of s that were separated by the given delimiter.');
          console.log('');
          console.log('');
          console.log('Usage: var x = split(delimiter, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#split');
          break;

        case funkier.splitMax:
          console.log('splitMax:');
          console.log('');
          console.log('Synonyms: splitLimit, splitCount');
          console.log('');
          console.log('A curried wrapper around String.prototype.split. Takes a string delimiter, a count, and a target string s, and');
          console.log('returns an array containing the substrings of s that were separated by the given delimiter, the returned array');
          console.log('containing at most limit such substrings.');
          console.log('');
          console.log('');
          console.log('Usage: var x = splitMax(delimiter, limit, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#splitmax');
          break;

        case funkier.strictEquals:
          console.log('strictEquals:');
          console.log('');
          console.log('A wrapper around the strict equality (===) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = strictEquals(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#strictequals');
          break;

        case funkier.strictNotEqual:
          console.log('strictNotEqual:');
          console.log('');
          console.log('Synonyms: strictNotEquals, strictInequality');
          console.log('');
          console.log('A wrapper around the strict inequality (!==) operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = strictNotEqual(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#strictnotequal');
          break;

        case funkier.stringToInt:
          console.log('stringToInt:');
          console.log('');
          console.log('Synonyms: parseIntInBase');
          console.log('');
          console.log('A curried wrapper around parseInt when called with two arguments. Takes a base between 2 and 36, and a string, and');
          console.log('attempts to convert the string assuming it represents a number in the given base. Returns NaN if the string does');
          console.log('not represent a valid number in the given base.');
          console.log('');
          console.log('');
          console.log('Usage: var x = stringToInt(base, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#stringtoint');
          break;

        case funkier.subtract:
          console.log('subtract:');
          console.log('');
          console.log('A wrapper around the subtraction operator.');
          console.log('');
          console.log('');
          console.log('Usage: var x = subtract(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#subtract');
          break;

        case funkier.sum:
          console.log('sum:');
          console.log('');
          console.log('Returns the sum of the elements of the given array, or arrayLike. Throws a TypeError if the value is not an');
          console.log('arrayLike, or it is empty.');
          console.log('');
          console.log('');
          console.log('Usage: var x = sum(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#sum');
          break;

        case funkier.tail:
          console.log('tail:');
          console.log('');
          console.log('Takes an array, string or arrayLike. Returns an array or string containing every element except the first.');
          console.log('');
          console.log('');
          console.log('Usage: var x = tail(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tail');
          break;

        case funkier.tails:
          console.log('tails:');
          console.log('');
          console.log('Synonyms: suffixes');
          console.log('');
          console.log('Takes an array, string or arrayLike. Returns all the suffixes of the given arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = tails(arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tails');
          break;

        case funkier.take:
          console.log('take:');
          console.log('');
          console.log('Takes a count, and an array, string or arrayLike. Returns an array or string containing the first count elements');
          console.log('of the given arrayLike.');
          console.log('');
          console.log('');
          console.log('Usage: var x = take(count, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#take');
          break;

        case funkier.takeWhile:
          console.log('takeWhile:');
          console.log('');
          console.log('Takes a predicate function pred, and source, which should be an array, string or arrayLike. Returns a new array or');
          console.log('string containing the initial members of the given arrayLike for which the predicate returned true.');
          console.log('');
          console.log('');
          console.log('Usage: var x = takeWhile(pred, arr)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#takewhile');
          break;

        case funkier.test:
          console.log('test:');
          console.log('');
          console.log('A curried wrapper around RegExp.prototype.test. Takes a regexp, and a string s, and returns true if the string');
          console.log('contains a substring matching the given pattern, and false otherwise.');
          console.log('');
          console.log('');
          console.log('Usage: var x = test(regexp, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#test');
          break;

        case funkier.toBaseAndString:
          console.log('toBaseAndString:');
          console.log('');
          console.log('Synonyms: toBaseAndRadix');
          console.log('');
          console.log('A curried wrapper around Number.prototype.toString. Takes a base between 2 and 36, and a number. Returns a string');
          console.log('representing the given number in the given base.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toBaseAndString(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tobaseandstring');
          break;

        case funkier.toCharCode:
          console.log('toCharCode:');
          console.log('');
          console.log('A curried wrapper around String.charCodeAt. Takes an index i, and a string s, and returns the Unicode value of');
          console.log('the character at the given index in s.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toCharCode(i, s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tocharcode');
          break;

        case funkier.toDateString:
          console.log('toDateString:');
          console.log('');
          console.log('A wrapper around Date.prototype.toDateString. Takes a Date object, and returns a string representing the date');
          console.log('portion of the object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toDateString(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#todatestring');
          break;

        case funkier.toEpochMilliseconds:
          console.log('toEpochMilliseconds:');
          console.log('');
          console.log('A wrapper around Date.prototype.getTime. Takes a Date object, and returns the number of milliseconds elapsed');
          console.log('since midnight, January 1 1970.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toEpochMilliseconds(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#toepochmilliseconds');
          break;

        case funkier.toExponential:
          console.log('toExponential:');
          console.log('');
          console.log('A curried wrapper around Number.prototype.toExponential. Takes the number of digits after the decimal point');
          console.log('(which should be between 0 and 20), and a number. Returns a string representing the number in exponential notation,');
          console.log('with the specified number of places after the decimal point.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toExponential(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#toexponential');
          break;

        case funkier.toFixed:
          console.log('toFixed:');
          console.log('');
          console.log('A curried wrapper around Number.prototype.toFixed. Takes the number of digits after the decimal point (which');
          console.log('should be between 0 and 20), and a number. Returns a string representing the number but with the specified number');
          console.log('of places after the decimal point.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toFixed(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tofixed');
          break;

        case funkier.toISOString:
          console.log('toISOString:');
          console.log('');
          console.log('A wrapper around Date.prototype.toISOString. Takes a Date object, and returns a string representation of the');
          console.log('date in ISO format.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toISOString(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#toisostring');
          break;

        case funkier.toLocaleDateString:
          console.log('toLocaleDateString:');
          console.log('');
          console.log('A wrapper around Date.prototype.toLocaleDateString. Takes a Date object, and  a string representing the date');
          console.log('portion of the object, formatted according to locale conventions.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toLocaleDateString(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tolocaledatestring');
          break;

        case funkier.toLocaleLowerCase:
          console.log('toLocaleLowerCase:');
          console.log('');
          console.log('Equivalent to String.prototype.toLocaleLowerCase. Takes a string s, and returns a lowercase version of s,');
          console.log('converted following locale conventions.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toLocaleLowerCase(s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tolocalelowercase');
          break;

        case funkier.toLocaleString:
          console.log('toLocaleString:');
          console.log('');
          console.log('Calls val\'s toLocaleString property, and returns the result.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toLocaleString(val)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tolocalestring');
          break;

        case funkier.toLocaleUpperCase:
          console.log('toLocaleUpperCase:');
          console.log('');
          console.log('Equivalent to String.prototype.toLocaleUpperCase. Takes a string s, and returns a uppercase version of s,');
          console.log('converted following locale conventions.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toLocaleUpperCase(s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tolocaleuppercase');
          break;

        case funkier.toLowerCase:
          console.log('toLowerCase:');
          console.log('');
          console.log('Equivalent to String.prototype.toLowerCase. Takes a string s, and returns a lowercase version of s.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toLowerCase(s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tolowercase');
          break;

        case funkier.toPrecision:
          console.log('toPrecision:');
          console.log('');
          console.log('A curried wrapper around Number.prototype.toPrecision. Takes the number of digits significant digits (which');
          console.log('should be between 1 and 21), and a number. Returns a string representing the number with the specified number');
          console.log('of significant digits.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toPrecision(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#toprecision');
          break;

        case funkier.toString:
          console.log('toString:');
          console.log('');
          console.log('Calls val\'s toString property, and returns the result.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toString(val)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#tostring');
          break;

        case funkier.toTimeString:
          console.log('toTimeString:');
          console.log('');
          console.log('A wrapper around Date.prototype.toTimeString. Takes a Date object, and returns a string representing the time');
          console.log('portion of the object.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toTimeString(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#totimestring');
          break;

        case funkier.toUTCString:
          console.log('toUTCString:');
          console.log('');
          console.log('A wrapper around Date.prototype.toUTCString. Takes a Date object, and returns a string representation of the');
          console.log('equivalent date in UTC.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toUTCString(d)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#toutcstring');
          break;

        case funkier.toUpperCase:
          console.log('toUpperCase:');
          console.log('');
          console.log('Equivalent to String.prototype.toUpperCase. Takes a string s, and returns a uppercase version of s.');
          console.log('');
          console.log('');
          console.log('Usage: var x = toUpperCase(s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#touppercase');
          break;

        case funkier.trim:
          console.log('trim:');
          console.log('');
          console.log('Returns a string containing the contents of the original string, less any leading and trailing whitespace.');
          console.log('');
          console.log('');
          console.log('Usage: var x = trim(s)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#trim');
          break;

        case funkier.unzip:
          console.log('unzip:');
          console.log('');
          console.log('Takes an array of Pairs, and returns a Pair. The first element is an array containing the first element from each');
          console.log('pair, and likewise the second element is an array containing the second elements.');
          console.log('');
          console.log('');
          console.log('Usage: var x = unzip(source)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#unzip');
          break;

        case funkier.wrap:
          console.log('wrap:');
          console.log('');
          console.log('Takes 3 functions, before, after and f. Returns a new function with the same arity as f, and curried in the same');
          console.log('manner (or curried using curry if f was not curried. The functions before, f, and after will be called');
          console.log('when the returned function is invoked.');
          console.log('');
          console.log('');
          console.log('Usage: var x = wrap(before, after, f)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#wrap');
          break;

        case funkier.xor:
          console.log('xor:');
          console.log('');
          console.log('A wrapper around the logical xor operator. Returns the logical xor of the given arguments');
          console.log('');
          console.log('');
          console.log('Usage: var x = xor(x, y)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#xor');
          break;

        case funkier.xorPred:
          console.log('xorPred:');
          console.log('');
          console.log('Takes two unary predicate functions, and returns a new unary function that, when called, will call the original');
          console.log('functions with the given argument, and logically xor their results, returning that value. Throws if either');
          console.log('argument is not a function of arity 1.');
          console.log('');
          console.log('');
          console.log('Usage: var x = xorPred(f1, f2)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#xorpred');
          break;

        case funkier.zip:
          console.log('zip:');
          console.log('');
          console.log('Takes two arrayLikes, a and b, and returns a new array. The new array has the same length as the smaller of the two');
          console.log('arguments. Each element is a Pair p, such that fst(p) === a[i] and snd(p) === b[i] for each position');
          console.log('i in the result.');
          console.log('');
          console.log('');
          console.log('Usage: var x = zip(a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#zip');
          break;

        case funkier.zipWith:
          console.log('zipWith:');
          console.log('');
          console.log('Returns array');
          console.log('');
          console.log('');
          console.log('Usage: var x = zipWith(f, a, b)');
          console.log('');
          console.log('See https://graememcc.github.io/funkierJS/docs/index.html#zipwith');
          break;

        default:
          console.log('No help available');
      }
    };

    funkier.help = helpFn;
  };
})();

},{}],27:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /* checkIntegral: Takes a value and an optional options object. In the following circumstances it will return
   *                the supplied value (coerced to an integer if necessary):
   *                  - The value is an integer.
   *                  - The value can be coerced to an integer, and the options object does not contain a property
   *                    named "strict" that coerces to true.
   *
   *                For all other values, a TypeError will be thrown. The message of the TypeError can be specified
   *                by including an "errorMessage" property in the options object.
   *
   */

  var checkIntegral = function(n, options) {
    options = options || {};
    var message = options.errorMessage || 'Value is not an integer';

    if (options.strict && typeof(n) !== 'number')
      throw new TypeError(message);

    n = n - 0;

    if (isNaN(n) || !isFinite(n))
      throw new TypeError(message);

    if (n !== Math.round(n))
      throw new TypeError(message);

    return n;
  };


  /* checkPositiveIntegral: Takes a value and an optional options object. In the following circumstances it will return
   *                        the supplied value (coerced to an integer if necessary):
   *                          - The value is a positive integer.
   *                          - The value can be coerced to a positive integer, and the options object does not contain
   *                            a property named "strict" that coerces to true.
   *
   *                        For all other values, a TypeError will be thrown. The message of the TypeError can be
   *                        specified by including an "errorMessage" property in the options object.
   *
   */

  var checkPositiveIntegral = function(n, options) {
    options = options || {};
    var message = options.errorMessage || 'Value is not a positive integer';
    // Don't mutate the supplied options
    var newOptions = Object.create(options);
    newOptions.errorMessage = message;
    n = checkIntegral(n, newOptions);

    if (n < 0)
      throw new TypeError(message);

    return n;
  };


  /*
   * isObjectLike: returns true if the given value is a string, array, function, or object,
   *               and false otherwise.
   *
   */

  var isObjectLike = function(v, options) {
    options = options || {};
    var strict = options.strict || false;
    var allowNull = options.allowNull || false;

    var acceptable = strict ? ['object'] : ['string', 'function', 'object'];
    if (strict && Array.isArray(v))
      return false;

    return (v === null && allowNull) || (v !== null && acceptable.indexOf(typeof(v)) !== -1);
  };


  /* checkObjectLike: takes a value and throws if it is not object-like, otherwise returns the object
   *
   */

  var checkObjectLike = function(v, options) {
    options = options || {};
    var message = options.message || 'Value is not an object';
    var allowNull = options.allowNull || false;

    if (!isObjectLike(v, options))
      throw new TypeError(message);

    return v;
  };


  /*
   * isArrayLike: returns true if the given value is a string, array, or 'array-like', and false otherwise.
   *              Takes an optional 'noStrings' argument: strings will not be considered 'array-like' when
   *              this is true.
   *
   */

  var isArrayLike = function(v, noStrings) {
    noStrings = noStrings || false;

    if (typeof(v) === 'string')
      return !noStrings;

    if (typeof(v) !== 'object' || v === null)
      return false;

    if (Array.isArray(v))
      return true;

    if (!v.hasOwnProperty('length'))
      return false;

    var l = v.length;

    return l === 0 || (v.hasOwnProperty('0') && v.hasOwnProperty('' + (l - 1)));
  };


  /* checkArrayLike: takes a value and throws if it is not array-like, otherwise
   *                 return a copy.
   *
   */

  var checkArrayLike = function(v, options) {
    options = options || {};
    var message = options.message || 'Value is not a string or array';

    if (!isArrayLike(v, options.noStrings))
      throw new TypeError(message);

    // We allow an optional 'dontSlice' option for arrays and arraylikes. For example,
    // when implementing length, there is no need to copy the object, we can just read
    // the property
    if (typeof(v) === 'string' || ('dontSlice' in options && options.dontSlice))
      return v;

    return [].slice.call(v);
  };


  /*
   * valueStringifier: Returns a string representation of the given value.
   *
   */

  var valueStringifier = function(v) {
    switch (typeof(v)) {
      case 'number':
      case 'boolean':
      case 'undefined':
        return '' + v;
      case 'string':
        return '\'' + v + '\'';
      case 'function':
        return v.toString();
      case 'object':
        if (v === null)
          return 'null';
        if (Array.isArray(v))
          return '[' + v.join(', ') + ']';
        return '{' + v.toString() + '}';
      default:
        return v.toString();
    }
  };


  return {
    checkArrayLike: checkArrayLike,
    checkIntegral: checkIntegral,
    checkObjectLike: checkObjectLike,
    checkPositiveIntegral: checkPositiveIntegral,
    isArrayLike: isArrayLike,
    isObjectLike: isObjectLike,
    valueStringifier: valueStringifier
  };
})();

},{}],28:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":29,"./lib/keys.js":30}],29:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],30:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],31:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = String(string)

  if (string.length === 0) return 0

  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      return string.length
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return string.length * 2
    case 'hex':
      return string.length >>> 1
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(string).length
    case 'base64':
      return base64ToBytes(string).length
    default:
      return string.length
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":32,"ieee754":33,"is-array":34}],32:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],33:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],34:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],35:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],36:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  /*
   * Caution: over-engineering at work.
   *
   * The comment processor needs to test various combinations of input with different fields present or not present.
   * The array manipulation gradually became harder and harder to read, making it difficult to understand the intent
   * of the test. Hence, it was time to introduce some abstraction and add an interface for manipulating the test
   * input.
   *
   */

  // All the recognised properties. Many of this file's tests assume that they appear in ascending order in the test datagT
  var testDataProps = ['name', 'category', 'synonyms', 'parameters', 'returns', 'summary', 'details', 'examples'];


  var normalizePropName = function(name) {
    name = name.toLowerCase();
    if (name === 'return type' || name === 'returntype') name = 'returns';
    if (name === 'parameter') name = 'parameters';
    return name;
  };


  var getOffsetProperty = function(options) {
    return function(prop) {
      prop = normalizePropName(prop);
      var propIndex = this[prop];
      if (propIndex === undefined) throw new Error(options.name + ': Test data array does not have ' + prop);

      var indices = testDataProps.map(function(name) {
        return {name: name, index: this[name]};
      }, this).filter(function(obj, i, arr) { return obj.index !== undefined && options.compare(obj.index, propIndex); });
      indices.sort(function(a, b) { return options.sort(a.index, b.index); });

      return indices.length > 0 ? indices[0].name : undefined;
    };
  };


  var getNextProperty = getOffsetProperty({name: 'getNextProperty', compare: function(a, b) { return a > b; },
                                           sort: function(a, b) { return a - b; }});
  var getPreviousProperty = getOffsetProperty({name: 'getPreviousProperty', compare: function(a, b) { return a < b; },
                                           sort: function(a, b) { return b - a; }});


  var getPropertyLength = function(prop) {
    prop = normalizePropName(prop);
    var propIndex = this[prop];
    if (propIndex === undefined) throw new Error('getPropertyLength: Test data array does not have ' + prop);

    var nextProp = this.getNextProperty(prop);
    return (nextProp !== undefined ? this[nextProp] : this.length) - propIndex;
  };


  var removeProperty = function(prop) {
    prop = normalizePropName(prop);
    var propIndex = this[prop];
    if (propIndex === undefined) throw new Error('removeProperty: Test data array does not have ' + prop);

    var nextProp = this.getNextProperty(prop);
    var result = this.slice(0, propIndex).concat(this.slice(nextProp === undefined ? this.length : this[nextProp]));

    // We must only read diff if the property in question lies beyond the property removed. In particular, we shouldn't
    // read it if the last field is removed
    var diff;
    if (nextProp !== undefined) {
      diff = this[nextProp] - propIndex;
    }

    testDataProps.forEach(function(p) {
      var current = this[p];
      if (current === undefined || p === prop) return;
      result[p] = current < propIndex ? current : current - diff;
    }, this);

    return decorate(result, this.tag, this.file);
  };


  var moveBefore = function(propToMove, whereTo) {
    propToMove = normalizePropName(propToMove);
    var propToMoveIndex = this[propToMove];
    if (propToMoveIndex === undefined) throw new Error('moveBefore: Test data array does not have ' + propToMove);
    var propLength = this.getPropertyLength(propToMove);

    whereTo = normalizePropName(whereTo);
    var whereToIndex = this[whereTo];
    if (whereToIndex === undefined) throw new Error('moveBefore: Test data array does not have ' + whereTo);
    var whereToLength = this.getPropertyLength(whereTo);

    var movedPropDelta = whereToIndex < propToMoveIndex ? 0 : -propLength;
    var result = this.slice(0, propToMoveIndex).concat(this.slice(propToMoveIndex + propLength));
    result.splice.apply(result, [whereToIndex + movedPropDelta, 0].concat(this.slice(propToMoveIndex, propToMoveIndex + propLength)));

    var first = whereToIndex < propToMoveIndex ? whereToIndex : propToMoveIndex;
    var second = whereToIndex < propToMoveIndex ? propToMoveIndex + propLength : whereToIndex + whereToLength;

    var delta = (whereToIndex < propToMoveIndex ? 1 : -1) * propLength;
    var newLocationDelta = whereToIndex < propToMoveIndex ? propLength : 0;

    testDataProps.forEach(function(p) {
      var current = this[p];
      if (current === undefined) return;

      if (current < first || current >= second) {
        result[p] = current;
        return;
      }

      if (p === propToMove)
        result[p] = whereToIndex + movedPropDelta;
      else if (p === whereTo)
        result[p] = whereToIndex + newLocationDelta;
      else
        result[p] = this[p] + delta;
    }, this);

    return decorate(result, this.tag, this.file);
  };


  var moveAfter = function(propToMove, whereTo) {
    propToMove = normalizePropName(propToMove);
    var propToMoveIndex = this[propToMove];
    if (propToMoveIndex === undefined) throw new Error('moveBefore: Test data array does not have ' + propToMove);
    var propLength = this.getPropertyLength(propToMove);

    whereTo = normalizePropName(whereTo);
    var whereToIndex = this[whereTo];
    if (whereToIndex === undefined) throw new Error('moveBefore: Test data array does not have ' + whereTo);
    var whereToLength = this.getPropertyLength(whereTo);

    var movedPropDelta = whereToLength - (whereToIndex < propToMoveIndex ? 0 : propLength);
    var result = this.slice(0, propToMoveIndex).concat(this.slice(propToMoveIndex + propLength));
    result.splice.apply(result, [whereToIndex + movedPropDelta, 0].concat(this.slice(propToMoveIndex, propToMoveIndex + propLength)));

    var first = whereToIndex < propToMoveIndex ? whereToIndex : propToMoveIndex;
    var second = whereToIndex < propToMoveIndex ? propToMoveIndex + propLength : whereToIndex + whereToLength;

    var delta = (whereToIndex < propToMoveIndex ? 1 : -1) * propLength;
    var newLocationDelta = whereToIndex < propToMoveIndex ? 0 : -propLength;

    testDataProps.forEach(function(p) {
      var current = this[p];
      if (current === undefined) return;

      if (current < first || current >= second) {
        result[p] = current;
        return;
      }

      if (p === propToMove)
        result[p] = whereToIndex + movedPropDelta;
      else if (p === whereTo)
        result[p] = whereToIndex + newLocationDelta;
      else
        result[p] = this[p] + delta;
    }, this);

    return decorate(result, this.tag, this.file);
  };


  var getPropertyValue = function(prop) {
    prop = normalizePropName(prop);
    if (this[prop] === undefined) throw new Error('getPropertyValue: Test data array does not have ' + prop);

    var nextProp = this.getNextProperty(prop);
    var sliceEnd = nextProp !== undefined ? this[nextProp] : this.length;
    return this.slice(this[prop], sliceEnd);
  };


  var replaceProperty = function(prop, value) {
    prop = normalizePropName(prop);
    if (this[prop] === undefined) throw new Error('replaceProperty: Test data array does not have ' + prop);

    var result = this.slice();
    if (!Array.isArray(value)) value = [value];
    result.splice.apply(result, [this[prop], this.getPropertyLength(prop)].concat(value));

    var changePoint = this[prop];
    var delta = this.getPropertyLength(prop) - value.length;

    testDataProps.forEach(function(prop) {
      var index = this[prop];
      if (index === undefined) return;

      result[prop] = index - (index <= changePoint ? 0 : delta);
    }, this);

    return decorate(result, this.tag, this.file);
  };


  var applyToAll = function(fn) {
    var result = null;
    testDataProps.forEach(function(prop) {
      if (this[prop] === undefined) return;

      result = (result !== null ? result : this).replaceProperty(prop, fn(this.getPropertyValue(prop), prop));
    }, this);
    return result;
  };


  var decorate = function(arr, tag, file) {
    arr.getNextProperty = getNextProperty;
    arr.getPreviousProperty = getPreviousProperty;
    arr.removeProperty = removeProperty;
    arr.getPropertyLength = getPropertyLength;
    arr.moveBefore = moveBefore;
    arr.moveAfter = moveAfter;
    arr.getPropertyValue = getPropertyValue;
    arr.replaceProperty = replaceProperty;
    arr.applyToAll = applyToAll;

    arr.tag = tag;
    arr.file = file;

    return arr;
  };


  var createTestData = function() {
    var props = [
      {name: 'name', value: 'testFunc'},
      {name: 'category', value: 'Category: funcCategory'},
      {name: 'synonyms', value: 'Synonyms: altName1, altName2'},
      {name: 'parameters', value: 'Parameter: x: number'},
      {name: 'returns', value: 'Returns: string'},
      {name: 'summary', value: ['The summary of the function', '']},
      {name: 'details', value: ['Details Line 1']},
      {name: 'examples', value: ['Examples:', 'var x = foo();']}
    ];

    var returnVal = [];
    props.forEach(function(p) {
      returnVal[p.name] = returnVal.length;
      if (Array.isArray(p.value)) {
        p.value.forEach(function(val) { returnVal.push(val); });
      } else {
        returnVal.push(p.value);
      }
    });

    returnVal = decorate(returnVal, 'apifunction', 'a.js');

    return returnVal;
  };


  return {
    createTestData: createTestData,
    standardProps: testDataProps
  };
})();

},{}],37:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var APIPrototype = require('../../docgen/APIPrototype');
  var APIFunction = require('../../docgen/APIFunction');


  describe('APIFunction constructor', function() {
    it('Constructor returns an object of the correct type', function() {
      expect(new APIFunction('foo', 'a.js', 'Bar', 'baz', {})).to.be.an.instanceOf(APIFunction);
    });


    it('Constructor is new agnostic', function() {
      expect(APIFunction('foo', 'a.js', 'Bar', 'baz', {})).to.be.an.instanceOf(APIFunction);
    });


    it('Returned objects should have APIPrototype in their prototype chain', function() {
      expect(APIPrototype.isPrototypeOf(APIFunction('foo', 'a.js', 'Bar', 'baz', {}))).to.equal(true);
    });


    /*
     * Invalid test generation: The constructor takes five parameters. The first four should be strings, and the
     * last an object. We wish to test that the constructor throws when supplied an argument of invalid type at each
     * position. We generate these tests automatically.
     *
     */

    ['name', 'filename', 'category', 'summary', 'options'].forEach(function(paramName, i, arr) {
      var stringInvalids = [1, true, {}, [], function() {}, undefined, null];
      var objectInvalids = [1, true, 'abc', [], function() {}, undefined, null];

      (i === arr.length - 1 ? objectInvalids: stringInvalids).map(function(invalid, j) {
        it('Constructor throws when ' + paramName + ' is invalid (' + (j + 1) + ')', function() {
          var args = ['foo', 'a.js', 'Bar', 'baz', {}];
          args[i] = invalid;
          var fn = function() {
            APIFunction.apply(null, args);
          };

          expect(fn).to.throw();
        });
      });
    });


    var invalidArrayData = [{value: 1, type: 'number'},
                            {value: true, type: 'boolean'},
                            {value: {}, type: 'object'},
                            {value: null, type: 'null' },
                            {value: [], type: 'array'},
                            {value: [Function], type: 'function'}];

    /*
     * Every optional property except 'parameters' is expected to be an array containing only strings. If the value is
     * not an array, or an array that has a non-string member, then the constructor should throw. Every test for this
     * would have the same shape, regardless of the property, so we shall just generate the tests.
     *
     * Note: we only test the unique properties here: the rest we get for free through APIPrototype being in the
     * prototype chain (tested above).
     *
     */

    ['parameters', 'returnType', 'synonyms'].forEach(function(property) {
      invalidArrayData.concat([{value: '', type: 'string'}]).forEach(function(invalid) {
        if (invalid.type !== 'array') {
          it('Constructor throws when ' + property + ' has type ' + invalid.type, function() {
            var obj = {};
            obj[property] = invalid.value;
            var fn = function() {
              APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
            };

            expect(fn).to.throw();
          });
        }
      });

      invalidArrayData.forEach(function(invalid) {
        if (property !== 'parameters' || invalid.type !== 'object') {
          it('Constructor throws when ' + property + ' contains a value of type ' + invalid.type, function() {
            var obj = {};
            obj[property] = [(property != 'parameters' ? 'line1' : {name: 'p1', type: ['t1']}), invalid.value];
            var fn = function() {
              APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
            };

            expect(fn).to.throw();
          });
        }
      });
    });


    it('Constructor throws when parameters contains a value of type string', function() {
      var obj = {parameters: [{name: 'p1', type: ['t1']}, 'fizz']};
      var fn = function() {
        APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
      };

      expect(fn).to.throw();
    });


    // More test generation: the constructor should throw if the objects describing the parameters have a non-string
    // 'name' property, a non-array 'type' property or non-string values in the 'type' property
    invalidArrayData.forEach(function(invalid) {
      it('Constructor throws when parameters contains a value with a name of type ' + invalid.type, function() {
        var obj = {parameters: [{name: 'p1', type: ['t1']}, {name: invalid.value, type: ['t1']}]};
        var fn = function() {
          APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
        };

        expect(fn).to.throw();
      });


      it('Constructor throws when type array of a parameters entry contains a value of type ' + invalid.type,
         function() {
        var obj = {parameters: [{name: 'p1', type: ['t1']}, {name: 'p2', type: ['t2', invalid.value]}]};
        var fn = function() {
          APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
        };

        expect(fn).to.throw();
      });


      if (invalid.type !== 'array') {
        it('Constructor throws when parameters contains a value with a type of type ' + invalid.type, function() {
          var obj = {parameters: [{name: 'p1', type: ['t1']}, {name: 'p1', type: invalid.value}]};
          var fn = function() {
            APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
          };

          expect(fn).to.throw();
        });
      }
    });


    it('Constructor throws when parameters contains a value with a type of type string', function() {
      var obj = {parameters: [{name: 'p1', type: ['t1']}, {name: 'p1', type: 't1'}]};
      var fn = function() {
        APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
      };

      expect(fn).to.throw();
    });


    it('Constructor throws when a parameter\'s type property is an empty array', function() {
      var obj = {parameters: [{name: 'p1', type: []}]};
      var fn = function() {
        APIFunction('fizz', 'a.js', 'Bar', 'buzz', obj);
      };

      expect(fn).to.throw();
    });
  });


  describe('APIFunction objects', function() {
    it('name property correct', function() {
      var name = 'fizz';
      var obj = APIFunction(name, 'a.js', 'Bar', 'baz', {});
      expect(obj.name).to.equal(name);
    });


    it('filename property correct', function() {
      var filename = 'a.js';
      var obj = APIFunction('fizz', filename, 'Bar', 'baz', {});
      expect(obj.filename).to.equal(filename);
    });


    it('category property correct', function() {
      var category = 'Bar';
      var obj = APIFunction('fizz', 'a.js', category, 'baz', {});
      expect(obj.category).to.equal(category);
    });


    it('summary property correct', function() {
      var summary = 'baz';
      var obj = APIFunction('fizz', 'a.js', 'Bar', summary, {});
      expect(obj.summary).to.equal(summary);
    });


    it('summary property shorn of trailing newlines', function() {
      var summary = 'baz';
      var obj = APIFunction('fizz', 'a.js', 'Bar', summary + '    \n', {});
      expect(obj.summary).to.equal(summary);
    });


    it('Newlines within the summary are preserved', function() {
      var summary = 'baz\nfoo';
      var obj = APIFunction('fizz', 'a.js', 'Bar', summary, {});
      expect(obj.summary).to.equal(summary);
    });


    /*
     * The 'details', 'returnType', 'synonyms' and 'examples' properties all share some common characteristics:
     *   - They are arrays of strings
     *   - They should default to an empty array if not present in the options object
     *   - The array should be a clone of the value supplied to the constructor (not a reference)
     *   - The array should be immutable
     *
     * Given this commonality, we can automatically generate the tests.
     *
     */

    ['details', 'returnType', 'examples', 'synonyms'].forEach(function(property) {
      it(property + ' is an empty array if not provided', function() {
        var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {});
        expect(obj[property]).to.deep.equal([]);
      });


      it(property + ' is correct when provided', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var options = {};
        options[property] = expected;
        var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', options);
        expect(obj[property]).to.deep.equal(expected);
      });


      it(property + ' is a copy of supplied array when provided', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var options = {};
        options[property] = expected;
        var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', options);
        expect(obj[property] === expected).to.equal(false);
      });


      it(property + ' array is immutable (1)', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var options = {};
        options[property] = expected;
        var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', options);

        expect(Object.isFrozen(obj[property])).to.equal(true);
      });


      it(property + ' array is immutable (2)', function() {
        var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {});
        expect(Object.isFrozen(obj[property])).to.equal(true);
      });
    });


    it('parameters property is an empty array if no parameters provided', function() {
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {});
      expect(obj.parameters).to.deep.equal([]);
    });


    it('parameters property is correct if parameters provided', function() {
      var expectedParameters = [{name: 'p1', type: ['t1']}, {name: 'p2', type: ['t2']}];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {parameters: expectedParameters});
      expect(obj.parameters).to.deep.equal(expectedParameters);
    });


    it('parameters property is a copy of supplied array when provided', function() {
      var expectedParameters = [{name: 'p1', type: ['t1']}, {name: 'p2', type: ['t2']}];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {parameters: expectedParameters});
      expect(obj.parameters === expectedParameters).to.equal(false);
    });


    it('Objects in the parameters array have immutable type arrays', function() {
      var parameters = [{name: 'p1', type: ['t1']}, {name: 'p2', type: ['t2']}];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {parameters: parameters});

      var allImmutable = obj.parameters.every(function(param) {
        return Object.isFrozen(param.type);
      });
      expect(allImmutable).to.equal(true);
    });


    it('Objects in the parameters array have type arrays that are copies of the original', function() {
      var types = [['t1'], ['t2']];
      var parameters = [{name: 'p1', type: types[0]}, {name: 'p2', type: types[1]}];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {parameters: parameters});

      var allCopies = obj.parameters.every(function(param, i) {
        return param.type !== types[i];
      });
      expect(allCopies).to.equal(true);
    });


    it('parameters array is immutable (1)', function() {
      var parameters = [{name: 'p1', type: ['t1']}, {name: 'p2', type: ['t2']}];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {parameters: parameters});

      expect(Object.isFrozen(obj.parameters)).to.equal(true);
    });


    it('parameters array is immutable (2)', function() {
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {});

      expect(Object.isFrozen(obj.parameters)).to.equal(true);
    });


    it('parameters array contents are clones of supplied contents', function() {
      var parameters = [{name: 'p1', type: ['t1']}, {name: 'p2', type: ['t2']}];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {parameters: parameters});

      var allDifferent = obj.parameters.every(function(paramObj, i) {
        return paramObj !== parameters[i];
      });
      expect(allDifferent).to.equal(true);
    });


    it('parameters array contents are immutable', function() {
      var parameters = [{name: 'p1', type: ['t1']}, {name: 'p2', type: ['t2']}];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {parameters: parameters});

      var allFrozen = obj.parameters.every(function(paramObj) {
        return Object.isFrozen(paramObj);
      });
      expect(allFrozen).to.equal(true);
    });


    it('Returned objects are immutable (1)', function() {
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', {});

      expect(Object.isFrozen(obj)).to.equal(true);
    });


    it('Returned objects are immutable (2)', function() {
      var options = {
        details: ['line 1', 'line 2'],
        returnType: ['type1', 'type2'],
        parameters: [{name: 'p1', type: ['arg1']}],
        synonyms: ['otherName'],
        examples: ['line 1']
      };
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'baz', options);

      expect(Object.isFrozen(obj)).to.equal(true);
    });


    it('Categories are normalized', function() {
      var obj = APIFunction('fizz', 'a.js', 'foo', 'buzz', {});

      expect(obj.category).to.equal('Foo');
    });


    it('Category normalization preserves camelCasing other than for the first letter', function() {
      var obj = APIFunction('fizz', 'a.js', 'fooBar', 'buzz', {});

      expect(obj.category).to.equal('FooBar');
    });


    it('Paragraph breaks in details are preserved', function() {
      var details = ['Line 1', '', 'Line 2', '  ', 'Line 3'];
      var obj = APIFunction('fizz', 'a.js', 'Bar', 'buzz', {details: details});
      expect(obj.details).to.deep.equal(details.map(function(s) { return s.trim(); }));
    });


    ['details', 'examples'].forEach(function(propName) {
      it('Trailing newlines at the end of ' + propName + ' entries are stripped', function() {
        var values = ['Line 1', 'Line 2'];
        var valuesToSupply = values.map(function(s, i) {
        var whitespace = '';
        for (var j = 0; j < i + 1; j++) whitespace += ' ';
          return s + whitespace + '\n';
        });

        var options = {};
        options[propName] = valuesToSupply;
        var obj = APIFunction('fizz', 'a.js', 'Bar', 'buzz', options);
        expect(obj[propName]).to.deep.equal(values);
      });


      it('Internal newlines are split in ' + propName + ' entries', function() {
        var values = ['Line 1', 'Line 2'];
        var valuesToSupply = [values.join('\n')];
        var options = {};
        options[propName] = valuesToSupply;
        var obj = APIFunction('fizz', 'a.js', 'Bar', 'buzz', options);
        expect(obj[propName]).to.deep.equal(values);
      });
    });
  });
})();

},{"../../docgen/APIFunction":2,"../../docgen/APIPrototype":4,"chai":64}],38:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var APIPrototype = require('../../docgen/APIPrototype');
  var APIObject = require('../../docgen/APIObject');


  describe('APIObject constructor', function() {
    it('Constructor returns an object of the correct type', function() {
      expect(new APIObject('foo', 'a.js', 'Bar', 'baz', {})).to.be.an.instanceOf(APIObject);
    });


    it('Constructor is new agnostic', function() {
      expect(APIObject('foo', 'a.js', 'Bar', 'baz', {})).to.be.an.instanceOf(APIObject);
    });


    it('Returned objects should have APIPrototype in their prototype chain', function() {
      expect(APIPrototype.isPrototypeOf(APIObject('foo', 'a.js', 'Bar', 'baz', {}))).to.equal(true);
    });


    /*
     * Invalid test generation: The constructor takes five parameters. The first four should be strings, and the
     * last an object. We wish to test that the constructor throws when supplied an argument of invalid type at each
     * position. We generate these tests automatically.
     *
     */

    ['name', 'filename', 'category', 'summary', 'options'].forEach(function(paramName, i, arr) {
      var stringInvalids = [1, true, {}, [], function() {}, undefined, null];
      var objectInvalids = [1, true, 'abc', [], function() {}, undefined, null];

      (i === arr.length - 1 ? objectInvalids: stringInvalids).map(function(invalid, j) {
        it('Constructor throws when ' + paramName + ' is invalid (' + (j + 1) + ')', function() {
          var args = ['foo', 'a.js', 'Bar', 'baz', {}];
          args[i] = invalid;
          var fn = function() {
            APIObject.apply(null, args);
          };

          expect(fn).to.throw();
        });
      });
    });
  });


  describe('APIObject objects', function() {
    it('name property correct', function() {
      var name = 'fizz';
      var obj = APIObject(name, 'a.js', 'Bar', 'baz', {});
      expect(obj.name).to.equal(name);
    });


    it('filename property correct', function() {
      var filename = 'a.js';
      var obj = APIObject('fizz', filename, 'Bar', 'baz', {});
      expect(obj.filename).to.equal(filename);
    });


    it('category property correct', function() {
      var category = 'Bar';
      var obj = APIObject('fizz', 'a.js', category, 'baz', {});
      expect(obj.category).to.equal(category);
    });


    it('summary property correct', function() {
      var summary = 'baz';
      var obj = APIObject('fizz', 'a.js', 'Bar', summary, {});
      expect(obj.summary).to.equal(summary);
    });


    it('summary property shorn of trailing newlines', function() {
      var summary = 'baz';
      var obj = APIObject('fizz', 'a.js', 'Bar', summary + '    \n', {});
      expect(obj.summary).to.equal(summary);
    });


    it('Newlines within the summary are preserved', function() {
      var summary = 'baz\nfoo';
      var obj = APIObject('fizz', 'a.js', 'Bar', summary, {});
      expect(obj.summary).to.equal(summary);
    });


    /*
     * The 'details', and 'examples' properties share some common characteristics:
     *   - They are arrays of strings
     *   - They should default to an empty array if not present in the options object
     *   - The array should be a clone of the value supplied to the constructor (not a reference)
     *   - The array should be immutable
     *
     * Given this commonality, we can automatically generate the tests.
     *
     */

    ['details', 'examples'].forEach(function(property) {
      it(property + ' is an empty array if not provided', function() {
        var obj = APIObject('fizz', 'a.js', 'Bar', 'baz', {});
        expect(obj[property]).to.deep.equal([]);
      });


      it(property + ' is correct when provided', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var options = {};
        options[property] = expected;
        var obj = APIObject('fizz', 'a.js', 'Bar', 'baz', options);
        expect(obj[property]).to.deep.equal(expected);
      });


      it(property + ' is a copy of supplied array when provided', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var options = {};
        options[property] = expected;
        var obj = APIObject('fizz', 'a.js', 'Bar', 'baz', options);
        expect(obj[property] === expected).to.equal(false);
      });


      it(property + ' array is immutable (1)', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var options = {};
        options[property] = expected;
        var obj = APIObject('fizz', 'a.js', 'Bar', 'baz', options);

        expect(Object.isFrozen(obj[property])).to.equal(true);
      });


      it(property + ' array is immutable (2)', function() {
        var obj = APIObject('fizz', 'a.js', 'Bar', 'baz', {});
        expect(Object.isFrozen(obj[property])).to.equal(true);
      });
    });


    it('Returned objects are immutable (1)', function() {
      var obj = APIObject('fizz', 'a.js', 'Bar', 'baz', {});

      expect(Object.isFrozen(obj)).to.equal(true);
    });


    it('Returned objects are immutable (2)', function() {
      var options = {
        details: ['line 1', 'line 2'],
        examples: ['line 1']
      };
      var obj = APIObject('fizz', 'a.js', 'Bar', 'baz', options);

      expect(Object.isFrozen(obj)).to.equal(true);
    });


    it('Categories are normalized', function() {
      var obj = APIObject('fizz', 'a.js', 'foo', 'buzz', {});

      expect(obj.category).to.equal('Foo');
    });


    it('Category normalization preserves camelCasing other than for the first letter', function() {
      var obj = APIObject('fizz', 'a.js', 'fooBar', 'buzz', {});

      expect(obj.category).to.equal('FooBar');
    });


    it('Paragraph breaks in details are preserved', function() {
      var details = ['Line 1', '', 'Line 2', '  ', 'Line 3'];
      var obj = APIObject('fizz', 'a.js', 'Bar', 'buzz', {details: details});
      expect(obj.details).to.deep.equal(details.map(function(s) { return s.trim(); }));
    });


    ['details', 'examples'].forEach(function(propName) {
      it('Trailing newlines at the end of ' + propName + ' entries are stripped', function() {
        var values = ['Line 1', 'Line 2'];
        var valuesToSupply = values.map(function(s, i) {
        var whitespace = '';
        for (var j = 0; j < i + 1; j++) whitespace += ' ';
          return s + whitespace + '\n';
        });

        var options = {};
        options[propName] = valuesToSupply;
        var obj = APIObject('fizz', 'a.js', 'Bar', 'buzz', options);
        expect(obj[propName]).to.deep.equal(values);
      });


      it('Internal newlines are split in ' + propName + ' entries', function() {
        var values = ['Line 1', 'Line 2'];
        var valuesToSupply = [values.join('\n')];
        var options = {};
        options[propName] = valuesToSupply;
        var obj = APIObject('fizz', 'a.js', 'Bar', 'buzz', options);
        expect(obj[propName]).to.deep.equal(values);
      });
    });
  });
})();

},{"../../docgen/APIObject":3,"../../docgen/APIPrototype":4,"chai":64}],39:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var APIPrototype = require('../../docgen/APIPrototype');


  describe('APIPrototype objects', function() {

    /*
     * The prototype requires that its properties are a certain type: every test for this will have the same shape,
     * so we take the opportunity to generate the tests on the fly.
     *
     */

    var addInvalidPropTest = function(prop, type, val) {
      it('Throws when setting ' + prop + ' to a value of type ' + type, function() {
        var obj = Object.create(APIPrototype);
        var fn = function() {
          obj[prop] = val;
        };

        expect(fn).to.throw();
      });
    };


    // Note: array should be the last entry to ease creating invalidArrayData later
    var invalidStringData = [
      {name: 'number', value: 42},
      {name: 'boolean', value: false},
      {name: 'undefined', value: undefined},
      {name: 'null', value: null},
      {name: 'object', value: {}},
      {name: 'function', value: function() {}},
      {name: 'array', value: []}
    ];


    ['name', 'category', 'filename', 'summary'].forEach(function(prop) {
      invalidStringData.forEach(function(test) {
        addInvalidPropTest(prop, test.name, test.value);
      });
    });


    var invalidArrayData = invalidStringData.slice(0, -1);
    invalidArrayData.push({name: 'string', value: ''});


    /*
     * The optional properties are expected to be arrays containing only strings. If the value is not an array, or an
     * array that has a non-string member, then setting the property should throw. Again, we are in the position to
     * generate tests.
     *
     */

    var addInvalidArrayTest = function(prop, type, val) {
      it('Throws when setting ' + prop + ' to an array containing a value of type' + type, function() {
        var obj = Object.create(APIPrototype);
        var fn = function() {
          obj[prop] = ['val1', val];
        };

        expect(fn).to.throw();
      });
    };


    ['details', 'examples'].forEach(function(prop) {
      invalidArrayData.forEach(function(test) {
        addInvalidPropTest(prop, test.name, test.value);
      });


      invalidStringData.forEach(function(test) {
        addInvalidArrayTest(prop, test.name, test.value);
      });
    });


    /*
     * Next, we generate tests that show that the string properties are correctly set when supplied valid data.
     *
     */


    var addValidStringPropTest = function(prop) {
      it(prop + ' set correctly', function() {
        var val = 'Foo';
        var obj = Object.create(APIPrototype);
        obj[prop] = val;
        expect(obj[prop]).to.deep.equal(val);
      });
    };


    ['name', 'category', 'filename', 'summary'].forEach(function(prop) {
      addValidStringPropTest(prop);
    });


    it('summary property shorn of trailing newlines', function() {
      var summary = 'baz';
      var obj = Object.create(APIPrototype);
      obj.summary = summary + '    \n';
      expect(obj.summary).to.equal(summary);
    });


    it('Newlines within the summary are preserved', function() {
      var summary = 'baz\nfoo';
      var obj = Object.create(APIPrototype);
      obj.summary = summary + '    \n';
      expect(obj.summary).to.equal(summary);
    });


    /*
     * The 'details', and 'examples' properties share some common characteristics:
     *   - They are arrays of strings
     *   - They should default to an empty array if not present in the options object
     *   - The array should be a clone of the value supplied to the constructor (not a reference)
     *   - The array should be immutable
     *
     * Given this commonality, we can automatically generate the tests.
     *
     */

    ['details', 'examples'].forEach(function(property) {
      it(property + ' is an empty array if not provided', function() {
        var obj = Object.create(APIPrototype);
        expect(obj[property]).to.deep.equal([]);
      });


      it(property + ' is correct when provided', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var obj = Object.create(APIPrototype);
        obj[property] = expected;
        expect(obj[property]).to.deep.equal(expected);
      });


      it(property + ' is a copy of supplied array when provided', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var obj = Object.create(APIPrototype);
        obj[property] = expected;
        expect(obj[property] === expected).to.equal(false);
      });


      it(property + ' array is immutable (1)', function() {
        var expected = ['line 1', 'line 2', 'line 3'];
        var obj = Object.create(APIPrototype);
        obj[property] = expected;
        expect(Object.isFrozen(obj[property])).to.equal(true);
      });


      it(property + ' array is immutable (2)', function() {
        var obj = Object.create(APIPrototype);
        expect(Object.isFrozen(obj[property])).to.equal(true);
      });
    });


    it('Categories are normalized', function() {
      var obj = Object.create(APIPrototype);
      obj.category = 'foo';
      expect(obj.category).to.equal('Foo');
    });


    it('Category normalization preserves camelCasing other than for the first letter', function() {
      var obj = Object.create(APIPrototype);
      obj.category = 'fooBar';
      expect(obj.category).to.equal('FooBar');
    });


    it('Paragraph breaks in details are preserved', function() {
      var details = ['Line 1', '', 'Line 2', '  ', 'Line 3'];
      var obj = Object.create(APIPrototype);
      obj.details = details;
      expect(obj.details).to.deep.equal(details.map(function(s) { return s.trim(); }));
    });


    /*
     * Add tests that show that a function name cannot match a category (regardless of case).
     *
     */

    var addMatchingNameTests = function(description, nameVal, catVal) {
      it('Throw when name and category match ' + description + ' (name set first)', function() {
        var obj = Object.create(APIPrototype);
        obj.name = nameVal;
        var fn = function() {
          obj.category = catVal;
        };

        expect(fn).to.throw();
      });


      it('Throw when name and category match ' + description + ' (category set first)', function() {
        var obj = Object.create(APIPrototype);
        obj.category = catVal;
        var fn = function() {
          obj.name = nameVal;
        };

        expect(fn).to.throw();
      });
    };


    [{name: 'Foo', cat: 'Foo', description: 'exactly'}, {name: 'foo', cat: 'Foo', description: 'approximately (1)'},
     {name: 'Foo', cat: 'foo', description: 'approximately (2)'},
     {name: 'foo', cat: 'foo', description: 'approximately (3)'}].forEach(function(test) {
      addMatchingNameTests(test.description, test.name, test.cat);
    });


    ['details', 'examples'].forEach(function(propName) {
      it('Trailing newlines at the end of ' + propName + ' entries are stripped', function() {
        var values = ['Line 1', 'Line 2'];
        var valuesToSupply = values.map(function(s, i) {
        var whitespace = '';
        for (var j = 0; j < i + 1; j++) whitespace += ' ';
          return s + whitespace + '\n';
        });

        var obj = Object.create(APIPrototype);
        obj[propName] = valuesToSupply;
        expect(obj[propName]).to.deep.equal(values);
      });


      it('Internal newlines are split in ' + propName + ' entries', function() {
        var values = ['Line 1', 'Line 2'];
        var valuesToSupply = [values.join('\n')];

        var obj = Object.create(APIPrototype);
        obj[propName] = valuesToSupply;
        expect(obj[propName]).to.deep.equal(values);
      });
    });
  });
})();

},{"../../docgen/APIPrototype":4,"chai":64}],40:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var CPTestDataHelper = require('./CPTestDataHelper');


  /*
   * Caution: over-engineering at work.
   *
   * The comment processor needs to test various combinations of input with different fields present or not present.
   * The array manipulation gradually became harder and harder to read, making it difficult to understand the intent
   * of the test. Hence, it was time to introduce some abstraction and add an interface for manipulating the test
   * input.
   *
   * Naturally, this test input itself needs tests.
   *
   */

  describe('CommentProcessor test data creator', function() {
    var standardProps = CPTestDataHelper.standardProps;
    var createTestData = CPTestDataHelper.createTestData;
    var testData;


    beforeEach(function() {
      testData = createTestData();
    });


    var expectedFunctions = ['getPreviousProperty', 'getNextProperty', 'getPropertyLength', 'removeProperty',
                             'moveBefore', 'moveAfter', 'getPropertyValue', 'replaceProperty', 'applyToAll'];


    describe('Initial status', function() {
      it('Test data should be an array', function() {
        expect(Array.isArray(testData)).to.equal(true);
      });


      it('Test data initially returned has all required fields', function() {
        var hasAllProps = standardProps.every(function(prop) {
          return testData[prop] !== undefined;
        });

        expect(hasAllProps).to.equal(true);
      });


      it('Test data\'s properties are all numbers', function() {
        var allPropsAreNumbers = standardProps.every(function(prop) {
          return typeof(testData[prop]) === 'number';
        });

        expect(allPropsAreNumbers).to.equal(true);
      });


      it('Test data\'s properties are in range', function() {
        var allPropsInRange = standardProps.every(function(prop) {
          return testData[prop] < testData.length;
        });

        expect(allPropsInRange).to.equal(true);
      });


      it('Test data has standard functions', function() {
        var hasAllFunctions = expectedFunctions.every(function(prop) {
          return testData[prop] !== undefined && typeof(testData[prop]) === 'function';
        });

        expect(hasAllFunctions).to.equal(true);
      });


      it('Test data is tagged as an apifunction', function() {
        expect(testData.tag.toLowerCase()).to.equal('apifunction');
      });


      it('Test data has a file tag', function() {
        expect(testData.file).to.equal('a.js');
      });
    });


    describe('getNextProperty', function() {
      it('Behaves as expected with the initial setup for non-terminal properties', function() {
        var allNonTerminalPropsOK = standardProps.slice(0, -1).every(function(prop, i) {
          // Assumption: standard props are listed in ascending order
          return testData.getNextProperty(prop) === standardProps[i + 1];
        });

        expect(allNonTerminalPropsOK).to.equal(true);
      });


      it('Behaves as expected with the initial setup for the terminal property', function() {
        // Assumption: examples is the last property
        expect(testData.getNextProperty('examples')).to.equal(undefined);
      });


      it('Behaves as expected when a property has been removed (1)', function() {
        var result = testData.removeProperty(standardProps[1]);
        expect(result.getNextProperty(standardProps[0])).to.equal(standardProps[2]);
      });


      it('Behaves as expected when a property has been removed (2)', function() {
        var result = testData.removeProperty(standardProps[standardProps.length - 1]);
        expect(result.getNextProperty(standardProps[standardProps.length - 2])).to.equal(undefined);
      });


      it('Behaves as expected when a property has been moved', function() {
        var propToMove = standardProps[2];
        var nextProp = testData.getNextProperty(propToMove);
        // Assumption: standardProps[2] was not the last property - sanity check
        expect(nextProp).to.not.equal(undefined);

        var result = testData.moveAfter(propToMove, nextProp);

        expect(result.getNextProperty(propToMove)).to.equal(testData.getNextProperty(nextProp));
      });


      it('Throws if the array doesn\'t have the required property', function() {
        var propToRemove = standardProps[1];
        var result = testData.removeProperty(propToRemove);
        var fn = function() {
          result.getNextProperty(propToRemove);
        };

        expect(fn).to.throw();
      });
    });


    describe('getPreviousProperty', function() {
      it('Behaves as expected with the initial setup for non-terminal properties', function() {
        var allNonTerminalPropsOK = standardProps.slice(1).every(function(prop, i) {
          // Assumption: standard props are listed in ascending order
          return testData.getPreviousProperty(prop) === standardProps[i];
        });

        expect(allNonTerminalPropsOK).to.equal(true);
      });


      it('Behaves as expected with the initial setup for the terminal property', function() {
        // Assumption: name is the last property
        expect(testData.getPreviousProperty('name')).to.equal(undefined);
      });


      it('Behaves as expected when a property has been removed (1)', function() {
        var result = testData.removeProperty(standardProps[1]);
        expect(result.getPreviousProperty(standardProps[2])).to.equal(standardProps[0]);
      });


      it('Behaves as expected when a property has been removed (2)', function() {
        var result = testData.removeProperty(standardProps[0]);
        expect(result.getPreviousProperty(standardProps[1])).to.equal(undefined);
      });


      it('Behaves as expected when a property has been moved', function() {
        var propToMove = standardProps[2];
        var previousProp = testData.getPreviousProperty(propToMove);
        // Assumption: standardProps[2] was not the first property - sanity check
        expect(previousProp).to.not.equal(undefined);

        var result = testData.moveBefore(propToMove, previousProp);

        expect(result.getPreviousProperty(propToMove)).to.equal(testData.getPreviousProperty(previousProp));
      });


      it('Throws if the array doesn\'t have the required property', function() {
        var propToRemove = standardProps[1];
        var result = testData.removeProperty(propToRemove);
        var fn = function() {
          result.getPreviousProperty(propToRemove);
        };

        expect(fn).to.throw();
      });
    });


    describe('getPropertyLength', function() {
      standardProps.slice(0, -1).forEach(function(prop, i) {
        it('Non-terminal properties have the correct properties reported', function() {
          // Assumption: the standard properties are in occurrence order
          expect(testData.getPropertyLength(prop)).to.equal(testData[standardProps[i + 1]] - testData[prop]);
        });
      });


      it('Non-terminal properties have the correct length reported after property removal', function() {
        var propToDelete = standardProps[2];
        var prev = testData.getPreviousProperty(propToDelete);

        // Sanity check
        expect(propToDelete).to.not.equal(undefined);
        expect(prev).to.not.equal(undefined);

        var result = testData.removeProperty(propToDelete);
        expect(result.getPropertyLength(prev)).to.equal(testData.getPropertyLength(prev));
      });


      it('Terminal properties have the correct length reported (1)', function() {
        // Assumption: the standard properties are in occurrence order
        var lastProp = standardProps[standardProps.length - 1];
        expect(testData.getPropertyLength(lastProp)).to.equal(testData.length - testData[lastProp]);
      });


      it('Terminal properties have the correct length reported (1)', function() {
        // Assumption: the standard properties are in occurrence order
        var lastProp = standardProps[standardProps.length - 1];
        var newLast = testData.getPreviousProperty(lastProp);

        // Sanity check
        expect(newLast).to.not.equal(undefined);

        var result = testData.removeProperty(lastProp);
        expect(testData.getPropertyLength(newLast)).to.equal(result.length - result[newLast]);
      });


      it('Throws if the array doesn\'t have the required property', function() {
        var propToRemove = standardProps[1];
        var result = testData.removeProperty(propToRemove);
        var fn = function() {
          result.getPropertyLength(propToRemove);
        };

        expect(fn).to.throw();
      });
    });


    describe('removeProperty', function() {
      standardProps.forEach(function(propToRemove, propIndex) {
        it('Returned result has the expected properties', function() {
          var result = testData.removeProperty(propToRemove);

          var hasAllProps = standardProps.every(function(prop) {
            if (prop === propToRemove) return true;

            return result[prop] !== undefined;
          });

          expect(hasAllProps).to.equal(true);
        });


        it('Returned result has standard functions', function() {
          var result = testData.removeProperty(propToRemove);

          var hasAllFunctions = expectedFunctions.every(function(prop) {
            return result[prop] !== undefined && typeof(result[prop]) === 'function';
          });

          expect(hasAllFunctions).to.equal(true);
        });


        it(propToRemove + ' is undefined after removal', function() {
          var result = testData.removeProperty(propToRemove);

          expect(result[propToRemove]).to.equal(undefined);
        });


        it(propToRemove + ' in original is unaffected', function() {
          var result = testData.removeProperty(propToRemove);

          expect(testData[propToRemove]).to.not.equal(undefined);
        });


        standardProps.slice(0, propIndex).forEach(function(beforeProp) {
          it(beforeProp + ' unchanged by removal of property lying after it', function() {
            var result = testData.removeProperty(propToRemove);

            expect(result[beforeProp]).to.equal(testData[beforeProp]);
          });
        });


        standardProps.slice(propIndex + 1).forEach(function(afterProp) {
          it(afterProp + ' correctly offset after removal of property lying after it', function() {
            var delta = testData.getPropertyLength(propToRemove);
            var result = testData.removeProperty(propToRemove);

            expect(result[afterProp]).to.equal(testData[afterProp] - delta);
          });
        });


        standardProps.forEach(function(p) {
          if (propToRemove == p) return;


          it(p + ' is correct after removal of ' + propToRemove, function() {
            var result = testData.removeProperty(propToRemove);

            expect(testData.getPropertyValue(p)).to.deep.equal(result.getPropertyValue(p));
          });
        });


        it('Throws if the array doesn\'t have the ' + propToRemove + ' property', function() {
          var intermediate = testData.removeProperty(propToRemove);
          var fn = function() {
            intermediate.removeProperty(propToRemove);
          };

          expect(fn).to.throw();
        });


        it('Result is an independent array', function() {
          var result = testData.removeProperty(propToRemove);
          expect(result === testData).to.equal(false);
        });
      });


      it('Property removal works correctly on result', function() {
        var intermediate = testData.removeProperty(standardProps[0]);
        var result = intermediate.removeProperty(standardProps[1]);
        var delta = testData[standardProps[2]];

        var allOK = standardProps.slice(2).every(function(prop) {
          return result[prop] === testData[prop] - delta;
        });

        expect(allOK).to.equal(true);
      });


      it('File is correctly transferred', function() {
        var result = testData.removeProperty(standardProps[1]);
        expect(result.file).to.equal(testData.file);
      });


      it('Tag is correctly transferred (1)', function() {
        var result = testData.removeProperty(standardProps[1]);
        expect(result.tag).to.equal(testData.tag);
      });


      it('Tag is correctly transferred (2)', function() {
        testData.tag = 'apiobject';
        var result = testData.removeProperty(standardProps[1]);
        expect(result.tag).to.equal(testData.tag);
      });
    });


    describe('moveBefore', function() {

      /*
       * We want to test the following cases:
       *   - when the new location lies before the original location
       *   - when the new location lies after the original location
       *
       * The following array allows us to generate the relevant tests automatically
       *
       */

      var tests = [
        {desc: 'new location lies before original location',
         getNewLocation: function(prop) { return testData.getPreviousProperty(testData.getPreviousProperty(prop)); }},
        {desc: 'new location lies after original location',
         getNewLocation: function(prop) { return testData.getNextProperty(testData.getNextProperty(prop)); }}
      ];


      tests.forEach(function(test) {
        it('Returned result has the expected properties when ' + test.desc, function() {
          var propToMove = standardProps[3];

          // Sanity check
          expect(test.getNewLocation(propToMove)).to.not.equal(undefined);

          var result = testData.moveBefore(propToMove, test.getNewLocation(propToMove));
          var hasAllProps = standardProps.every(function(prop) {
            if (result[prop] === undefined) {
            }
            return result[prop] !== undefined;
          });

          expect(hasAllProps).to.equal(true);
        });


        it('Items lying before are unperturbed when ' + test.desc, function() {
          var propToMove = standardProps[3];
          var newLocation = test.getNewLocation(propToMove);

          // Sanity check
          expect(newLocation).to.not.equal(undefined);

          var result = testData.moveBefore(propToMove, newLocation);

          var unperturbedLimit = testData[newLocation] < testData[propToMove] ? newLocation : propToMove;
          var prop = testData.getPreviousProperty(unperturbedLimit);

          while (prop !== undefined) {
            expect(result[prop]).to.equal(testData[prop]);
            prop = testData.getPreviousProperty(prop);
          }
        });


        it('Items lying after are unperturbed when ' + test.desc, function() {
          var propToMove = standardProps[3];
          var newLocation = test.getNewLocation(propToMove);

          // Sanity check
          expect(newLocation).to.not.equal(undefined);

          var result = testData.moveBefore(propToMove, newLocation);
          var unperturbedLimit = testData[newLocation] < testData[propToMove] ? propToMove : newLocation;
          var prop = testData.getNextProperty(unperturbedLimit);

          while (prop !== undefined) {
            expect(result[prop]).to.equal(testData[prop]);
            prop = testData.getNextProperty(prop);
          }
        });


        it('Moved properties are correct when ' + test.desc, function() {
          var propToMove = standardProps[3];
          var newLocation = testData.getPreviousProperty(propToMove);

          // Sanity check
          expect(newLocation).to.not.equal(undefined);
          var result = testData.moveBefore(propToMove, newLocation);

          var oldIndex = testData[propToMove];
          var moveIndex = testData[newLocation];

          var first = Math.min(standardProps.indexOf(propToMove), standardProps.indexOf(newLocation));
          var second = Math.max(standardProps.indexOf(testData.getNextProperty(propToMove)),
                                standardProps.indexOf(testData.getNextProperty(newLocation)));

          var propLength = testData.getPropertyLength(propToMove);
          var movedPropDelta = (moveIndex < oldIndex) ? 0 : -propLength;
          var delta = (moveIndex < oldIndex ? 1 : -1) * propLength;
          var newLocationDelta = moveIndex < oldIndex ? propLength : 0;

          var propsOK = standardProps.slice(first, second).every(function(p) {
            var current = testData[p];

            if (p === propToMove)
              return result[p] === moveIndex + movedPropDelta;
            else if (p === newLocation)
              return result[p] === moveIndex + newLocationDelta;
            else
              return result[p] === testData[p] + delta;
          });

          expect(propsOK).to.equal(true);
        });


        standardProps.forEach(function(p) {
          it(p + ' is correct after move', function() {
            var propToMove = standardProps[3];
            var newLocation = testData.getPreviousProperty(propToMove);

            // Sanity check
            expect(newLocation).to.not.equal(undefined);
            var result = testData.moveBefore(propToMove, newLocation);

            expect(testData.getPropertyValue(p)).to.deep.equal(result.getPropertyValue(p));
          });
        });
      });


      it('Works for moving to an earlier adjacent position (ie swapping positions)', function() {
        var propToMove = standardProps[3];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveBefore(propToMove, newLocation);

        expect(result[propToMove]).to.equal(testData[newLocation]);
        expect(result[newLocation]).to.equal(testData[newLocation] + testData.getPropertyLength(propToMove));
      });


      it('Throws if the array doesn\'t have the property to be moved', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var intermediate = testData.removeProperty(propToMove);
        var fn = function() {
          intermediate.moveProperty(propToMove, newLocation);
        };

        expect(fn).to.throw();
      });


      it('Throws if the array doesn\'t have the new location for the property', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var intermediate = testData.removeProperty(newLocation);
        var fn = function() {
          intermediate.moveProperty(propToMove, newLocation);
        };

        expect(fn).to.throw();
      });


      it('Moving to the same location is effectively an identity operation', function() {
        var propToMove = standardProps[1];
        var newLocation = testData.getNextProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveBefore(propToMove, newLocation);
        expect(result).to.deep.equal(testData);
      });


      it('Works when moving before position zero', function() {
        // Assumes that the standard props are in occurrence order
        expect(testData[standardProps[0]]).to.equal(0);

        var newLocation = standardProps[0];
        var propToMove = standardProps[1];
        var result = testData.moveBefore(propToMove, newLocation);

        expect(result[propToMove]).to.equal(0);
        expect(result[newLocation]).to.equal(testData.getPropertyLength(propToMove));
      });


      it('Result has standard functions', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveBefore(propToMove, newLocation);

        var hasAllFunctions = expectedFunctions.every(function(prop) {
          return result[prop] !== undefined && typeof(result[prop]) === 'function';
        });

        expect(hasAllFunctions).to.equal(true);
      });


      it('Result is an independent array', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveBefore(propToMove, newLocation);
        expect(result === testData).to.equal(false);
      });


      it('File is correctly transferred', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveBefore(propToMove, newLocation);
        expect(result.file).to.equal(testData.file);
      });


      it('Tag is correctly transferred (1)', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveBefore(propToMove, newLocation);
        expect(result.tag).to.equal(testData.tag);
      });


      it('Tag is correctly transferred (2)', function() {
        testData.tag = 'apiobject';
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveBefore(propToMove, newLocation);
        expect(result.tag).to.equal(testData.tag);
      });
    });


    describe('moveAfter', function() {

      /*
       * We want to test the following cases:
       *   - when the new location lies before the original location
       *   - when the new location lies after the original location
       *
       * The following array allows us to generate the relevant tests automatically
       *
       */

      var tests = [
        {desc: 'new location lies before original location',
         getNewLocation: function(prop) { return testData.getPreviousProperty(testData.getPreviousProperty(prop)); }},
        {desc: 'new location lies after original location',
         getNewLocation: function(prop) { return testData.getNextProperty(testData.getNextProperty(prop)); }}
      ];


      tests.forEach(function(test) {
        it('Returned result has the expected properties when ' + test.desc, function() {
          var propToMove = standardProps[3];

          // Sanity check
          expect(test.getNewLocation(propToMove)).to.not.equal(undefined);

          var result = testData.moveAfter(propToMove, test.getNewLocation(propToMove));
          var hasAllProps = standardProps.every(function(prop) {
            if (result[prop] === undefined) {
            }
            return result[prop] !== undefined;
          });

          expect(hasAllProps).to.equal(true);
        });


        it('Items lying before are unperturbed when ' + test.desc, function() {
          var propToMove = standardProps[3];
          var newLocation = test.getNewLocation(propToMove);

          // Sanity check
          expect(newLocation).to.not.equal(undefined);

          var result = testData.moveAfter(propToMove, newLocation);

          var unperturbedLimit = testData[newLocation] < testData[propToMove] ? newLocation : propToMove;
          var prop = testData.getPreviousProperty(unperturbedLimit);

          while (prop !== undefined) {
            expect(result[prop]).to.equal(testData[prop]);
            prop = testData.getPreviousProperty(prop);
          }
        });


        it('Items lying after are unperturbed when ' + test.desc, function() {
          var propToMove = standardProps[3];
          var newLocation = test.getNewLocation(propToMove);

          // Sanity check
          expect(newLocation).to.not.equal(undefined);

          var result = testData.moveAfter(propToMove, newLocation);
          var unperturbedLimit = testData[newLocation] < testData[propToMove] ? propToMove : newLocation;
          var prop = testData.getNextProperty(unperturbedLimit);

          while (prop !== undefined) {
            expect(result[prop]).to.equal(testData[prop]);
            prop = testData.getNextProperty(prop);
          }
        });


        it('Moved properties are correct when ' + test.desc, function() {
          var propToMove = standardProps[2];
          var newLocation = test.getNewLocation(propToMove);

          // Sanity check
          expect(newLocation).to.not.equal(undefined);
          var result = testData.moveAfter(propToMove, newLocation);

          var oldIndex = testData[propToMove];
          var moveIndex = testData[newLocation];

          var first = Math.min(standardProps.indexOf(propToMove), standardProps.indexOf(newLocation));
          var second = Math.max(standardProps.indexOf(testData.getNextProperty(propToMove)),
                                standardProps.indexOf(testData.getNextProperty(newLocation)));

          var propLength = testData.getPropertyLength(propToMove);
          var movedPropDelta = testData.getPropertyLength(newLocation) - (moveIndex < oldIndex ? 0 : propLength);
          var delta = (moveIndex < oldIndex ? 1 : -1) * propLength;
          var newLocationDelta = moveIndex < oldIndex ? 0 : -propLength;

          var propsOK = standardProps.slice(first, second).every(function(p) {
            var current = testData[p];

            if (p === propToMove)
              return result[p] === moveIndex + movedPropDelta;
            else if (p === newLocation)
              return result[p] === moveIndex + newLocationDelta;
            else
              return result[p] === testData[p] + delta;
          });

          expect(propsOK).to.equal(true);
        });


        standardProps.forEach(function(p) {
          it(p + ' is correct after move', function() {
            var propToMove = standardProps[3];
            var newLocation = testData.getPreviousProperty(propToMove);

            // Sanity check
            expect(newLocation).to.not.equal(undefined);
            var result = testData.moveAfter(propToMove, newLocation);

            expect(testData.getPropertyValue(p)).to.deep.equal(result.getPropertyValue(p));
          });
        });
      });


      it('Works for moving to a later adjacent position (ie swapping positions)', function() {
        var propToMove = standardProps[3];
        var newLocation = testData.getNextProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveAfter(propToMove, newLocation);

        expect(result[propToMove]).to.equal(testData[propToMove] + testData.getPropertyLength(newLocation));
        expect(result[newLocation]).to.equal(testData[propToMove]);
      });


      it('Throws if the array doesn\'t have the property to be moved', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getNextProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var intermediate = testData.removeProperty(propToMove);
        var fn = function() {
          intermediate.moveProperty(propToMove, newLocation);
        };

        expect(fn).to.throw();
      });


      it('Throws if the array doesn\'t have the new location for the property', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getNextProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var intermediate = testData.removeProperty(newLocation);
        var fn = function() {
          intermediate.moveProperty(propToMove, newLocation);
        };

        expect(fn).to.throw();
      });


      it('Moving to the same location is effectively an identity operation', function() {
        var propToMove = standardProps[1];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveAfter(propToMove, newLocation);
        expect(result).to.deep.equal(testData);
      });


      it('Works when moving after last position', function() {
        // Assumes that the standard props are in occurrence order
        expect(testData.getNextProperty(standardProps[standardProps.length - 1])).to.equal(undefined);

        var newLocation = standardProps[standardProps.length - 1];
        var newLocationLength = testData.getPropertyLength(newLocation);
        var propToMove = standardProps[1];
        var propToMoveLength = testData.getPropertyLength(propToMove);
        var result = testData.moveAfter(propToMove, newLocation);

        expect(result[propToMove]).to.equal(testData.length - propToMoveLength);
        expect(result[newLocation]).to.equal(testData.length - propToMoveLength - newLocationLength);
      });


      it('Result has standard functions', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getNextProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveAfter(propToMove, newLocation);

        var hasAllFunctions = expectedFunctions.every(function(prop) {
          return result[prop] !== undefined && typeof(result[prop]) === 'function';
        });

        expect(hasAllFunctions).to.equal(true);
      });


      it('Result is an independent array', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getNextProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveAfter(propToMove, newLocation);
        expect(result === testData).to.equal(false);
      });


      it('File is correctly transferred', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveAfter(propToMove, newLocation);
        expect(result.file).to.equal(testData.file);
      });


      it('Tag is correctly transferred (1)', function() {
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveAfter(propToMove, newLocation);
        expect(result.tag).to.equal(testData.tag);
      });


      it('Tag is correctly transferred (2)', function() {
        testData.tag = 'apiobject';
        var propToMove = standardProps[2];
        var newLocation = testData.getPreviousProperty(propToMove);

        // Sanity check
        expect(newLocation).to.not.equal(undefined);
        var result = testData.moveAfter(propToMove, newLocation);
        expect(result.tag).to.equal(testData.tag);
      });
    });


    describe('getPropertyValue', function() {
      standardProps.forEach(function(prop) {
        it('Properties have the correct values reported', function() {
          var nextProp = testData.getNextProperty(prop);
          var sliceEnd = nextProp !== undefined ? testData[nextProp] : testData.length;
          expect(testData.getPropertyValue(prop)).to.deep.equal(testData.slice(testData[prop], sliceEnd));
        });
      });


      it('Throws if the array doesn\'t have the required property', function() {
        var propToRemove = standardProps[1];
        var result = testData.removeProperty(propToRemove);
        var fn = function() {
          result.getPropertyValue(propToRemove);
        };

        expect(fn).to.throw();
      });
    });


    describe('replaceProperty', function() {
      it('Has correct value after updating', function() {
        var newSynonyms = ['new synonyms line 1', 'new synonyms line 2'];
        var result = testData.replaceProperty('synonyms', newSynonyms);

        expect(result.getPropertyValue('synonyms')).to.deep.equal(newSynonyms);
      });


      it('Has correct length after updating', function() {
        // Assumption: synonyms does not normally have length 2
        expect(testData.getPropertyLength('synonyms')).to.not.equal(3);

        var newSynonyms = ['new synonyms line 1', 'new synonyms line 2', ''];
        var result = testData.replaceProperty('synonyms', newSynonyms);

        expect(result.getPropertyLength('synonyms')).to.equal(newSynonyms.length);
      });


      it('Unaffected indices unperturbed', function() {
        var lyingBefore = standardProps.filter(function(prop) {
          return testData[prop] <= testData.synonyms;
        });

        var newSynonyms = ['new synonyms line 1', 'new synonyms line 2'];

        var result = testData.replaceProperty('synonyms', newSynonyms);
        var allUnchanged = lyingBefore.every(function(prop) {
          return result[prop] === testData[prop];
        });

        expect(allUnchanged).to.equal(true);
      });


      it('Relevant indices updated after updating', function() {
        var lyingAfter = standardProps.filter(function(prop) {
          return testData[prop] > testData.synonyms;
        });

        var newSynonyms = ['new synonyms line 1', 'new synonyms line 2', 'new synonyms line 3'];
        var delta = newSynonyms.length - testData.getPropertyLength('synonyms');
        // Assumption: synonyms does not normally have length 3
        expect(delta).to.not.equal(0);

        var result = testData.replaceProperty('synonyms', newSynonyms);
        var allMoved = lyingAfter.every(function(prop) {
          return result[prop] === testData[prop] + delta;
        });

        expect(allMoved).to.equal(true);
      });


      it('Throws if the array doesn\'t have the required property', function() {
        var propToRemove = standardProps[1];
        var result = testData.removeProperty(propToRemove);
        var fn = function() {
          result.replaceProperty(propToRemove, ['foo']);
        };

        expect(fn).to.throw();
      });


      it('Accepts strings', function() {
        // Assumption: details is normally longer than one line
        expect(testData.getPropertyLength('details')).to.not.equal(0);
        var newDetails = 'foo';

        var lyingBefore = standardProps.filter(function(prop) {
          return testData[prop] <= testData.details;
        });

        var lyingAfter = standardProps.filter(function(prop) {
          return testData[prop] > testData.details;
        });

        var newSynonyms = ['new synonyms line 1', 'new synonyms line 2'];
        var delta = testData.getPropertyLength('details') - 1;

        var result = testData.replaceProperty('details', newDetails);

        expect(result.getPropertyValue('details')).to.deep.equal([newDetails]);
        expect(result.getPropertyLength('details')).to.equal(1);

        var allMoved = lyingAfter.every(function(prop) {
          return result[prop] === testData[prop] - delta;
        });

        expect(allMoved).to.equal(true);

        var allUnchanged = lyingBefore.every(function(prop) {
          return result[prop] === testData[prop];
        });

        expect(allUnchanged).to.equal(true);
      });


      it('Result is an independent array', function() {
        var result = testData.replaceProperty(standardProps[0], 'foo');
        expect(result === testData).to.equal(false);
      });


      it('File is correctly transferred', function() {
        var result = testData.replaceProperty(standardProps[0], 'foo');
        expect(result.file).to.equal(testData.file);
      });


      it('Tag is correctly transferred (1)', function() {
        var result = testData.replaceProperty(standardProps[0], 'foo');
        expect(result.tag).to.equal(testData.tag);
      });


      it('Tag is correctly transferred (2)', function() {
        testData.tag = 'apiobject';
        var result = testData.replaceProperty(standardProps[0], 'foo');
        expect(result.tag).to.equal(testData.tag);
      });
    });


    describe('applyToAll', function() {
      it('Returned result has the expected properties', function() {
        var result = testData.applyToAll(function(x) { return x; });

        var hasAllProps = standardProps.every(function(prop) {
          return result[prop] !== undefined;
        });

        expect(hasAllProps).to.equal(true);
      });


      it('Returned result has standard functions', function() {
        var result = testData.applyToAll(function(x) { return x; });

        var hasAllFunctions = expectedFunctions.every(function(prop) {
          return result[prop] !== undefined && typeof(result[prop]) === 'function';
        });

        expect(hasAllFunctions).to.equal(true);
      });


      it('Called with all properties (1)', function() {
        var calledWith = {};
        standardProps.forEach(function(p) { calledWith[p] = false; });
        var f = function(x, prop) { calledWith[prop] = true; };
        var result = testData.applyToAll(f);
        var calledForAll = standardProps.every(function(p) { return calledWith[p]; });

        expect(calledForAll).to.equal(true);
      });


      it('Called with all properties (2)', function() {
        var calledWith = {};
        standardProps.forEach(function(p) { calledWith[p] = null; });
        var f = function(x, prop) { calledWith[prop] = x; };
        var result = testData.applyToAll(f);
        var calledWithCorrectData  = standardProps.every(function(p) {
          var val = testData.getPropertyValue(p);
          return Array.isArray(calledWith[p]) && val.every(function(s, i) { return calledWith[p][i] === s; });
        });

        expect(calledWithCorrectData).to.equal(true);
      });


      it('Called with all properties (3)', function() {
        var calledWith = {};
        standardProps.forEach(function(p) { calledWith[p] = false; });
        var f = function(x, prop) { calledWith[prop] = true; };
        var result = testData.removeProperty(standardProps[1]).applyToAll(f);
        var calledForAll = standardProps.every(function(p) {
          return p === standardProps[1] ? !calledWith[p] : calledWith[p];
        });

        expect(calledForAll).to.equal(true);
      });


      it('Result is an independent array', function() {
        var result = testData.applyToAll(function(x) { return x; });
        expect(result === testData).to.equal(false);
      });


      it('File is correctly transferred', function() {
        var result = testData.applyToAll(function(x) { return x; });
        expect(result.file).to.equal(testData.file);
      });


      it('Tag is correctly transferred (1)', function() {
        var result = testData.applyToAll(function(x) { return x; });
        expect(result.tag).to.equal(testData.tag);
      });


      it('Tag is correctly transferred (2)', function() {
        testData.tag = 'apiobject';
        var result = testData.applyToAll(function(x) { return x; });
        expect(result.tag).to.equal(testData.tag);
      });
    });
  });
})();

},{"./CPTestDataHelper":36,"chai":64}],41:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var APIFunction = require('../../docgen/APIFunction');
  var APIObject = require('../../docgen/APIObject');
  var Collator = require('../../docgen/collator');


  describe('Collator', function() {
    describe('Constructor', function() {

      var badData = [
        {name: 'array', value: []},
        {name: 'number', value: 42},
        {name: 'string', value: 'a'},
        {name: 'boolean', value: true},
        {name: 'random object', value: {}},
        {name: 'function', value: function() {}},
        {name: 'undefined', value: undefined},
        {name: 'null', value: null}];


      badData.forEach(function(test, i) {
        if (i > 0) {
          it('Throws when called with ' + test.name, function() {
            var fn = function() {
              new Collator(test.value);
            };

            expect(fn).to.throw();
          });


          it('Throws when called with an array containing ' + test.name, function() {
            var fn = function() {
              new Collator([test.value]);
            };

            expect(fn).to.throw();
          });
        }


        it('Throws when called with an array with a sub-array containing ' + test.name, function() {
          var fn = function() {
            new Collator([[APIFunction('fizz', 'a.js', 'foo', 'bar', {})], [APIObject('a', 'b', 'c', {}), test.value]]);
          };

          expect(fn).to.throw();
        });
      });


      /*
       * Many of the tests have the same form. As usual, we generate them automagically.
       *
       */

      var addDualTest = function(description, makeFirst, makeSecond) {
        it('Throws if ' + description + ' (values occur in same array)', function() {
          var data = [[].concat(makeFirst()).concat(makeSecond())];
          var fn = function() {
            new Collator(data);
          };

          expect(fn).to.throw();
        });


        it('Throws if ' + description + ' (values occur in same array)', function() {
          var data = [[].concat(makeFirst()), [].concat(makeSecond())];
          var fn = function() {
            new Collator(data);
          };

          expect(fn).to.throw();
        });
      };


      addDualTest('two APIFunctions share the same name',
                  function() { return [APIFunction('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIFunction('foo', 'a.js', 'fizz', 'buzz', {})];});


      addDualTest('two APIObjects share the same name',
                  function() { return [APIObject('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIObject('foo', 'a.js', 'fizz', 'buzz', {})];});


      addDualTest('one function has the same name as the synonym of another',
                  function() { return [APIFunction('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIFunction('bar', 'b.js', 'fizz', 'buzz', {synonyms: ['foo']})];});


      addDualTest('an APIObject has the same name as the synonym of an APIFunction',
                  function() { return [APIObject('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIFunction('bar', 'a.js', 'fizz', 'buzz', {synonyms: ['foo']})];});


      addDualTest('two APIFunctions have the same synonym',
                  function() { return [APIFunction('foo', 'a.js', 'fizz', 'buzz', {synonyms: ['a1', 'a2']})];},
                  function() { return [APIFunction('bar', 'b.js', 'fizz', 'buzz', {synonyms: ['a3', 'a1']})];});


      addDualTest('an APIFunction has the same name as a category (1)',
                  function() { return [APIFunction('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIFunction('fizz', 'a.js', 'cat', 'buzz', {})];});


      addDualTest('an APIFunction has the same name as a category (2)',
                  function() { return [APIObject('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIFunction('fizz', 'b.js', 'cat', 'buzz', {})];});


      addDualTest('an APIObject has the same name as a category (1)',
                  function() { return [APIFunction('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIObject('fizz', 'a.js', 'cat', 'buzz', {})];});


      addDualTest('an APIFunction has the same name as a category (2)',
                  function() { return [APIObject('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIObject('fizz', 'a.js', 'cat', 'buzz', {})];});


      addDualTest('a synonym has the same name as a category (1)',
                  function() { return [APIFunction('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIFunction('bar', 'a.js', 'cat', 'buzz', {synonyms: ['fizz']})];});


      addDualTest('a synonym has the same name as a category (2)',
                  function() { return [APIObject('foo', 'a.js', 'fizz', 'buzz', {})];},
                  function() { return [APIFunction('bar', 'a.js', 'cat', 'buzz', {synonyms: ['fizz']})];});



      it('Doesn\'t throw when called with an empty array', function() {
        var fn = function() {
          new Collator([]);
        };

        expect(fn).to.not.throw();
      });


      it('Constructor is new-agnostic', function() {
        expect(Collator([])).to.be.an.instanceOf(Collator);
      });
    });


    describe('Functions', function() {
      var testData, collated;

      beforeEach(function() {
        testData = [
          [
            APIFunction('Cat1Func1', 'a.js', 'Cat1', '', {synonyms: ['Cat1Func2', 'Cat1Func3']}),
            APIFunction('Cat2Func1', 'a.js', 'Cat2', '', {})
          ],
          [
            APIObject('Cat2Obj1', 'b.js', 'Cat2', '', {}),
            APIObject('Cat3Obj1', 'e/c.js', 'Cat3', '', {}),
            APIFunction('Cat1Func4', 'a.js', 'Cat1', '', {})
          ],
          [
            APIFunction('Cat1Func5', 'd.js', 'Cat1', '', {synonyms: ['Cat1Func6']})
          ]
        ];

        collated = Collator(testData);
      });


      describe('getCategories', function() {
        it('Category names returned in alphabetical order', function() {
          var expected = ['Cat1', 'Cat2', 'Cat3'];
          expect(collated.getCategories()).to.deep.equal(expected);
        });
      });


      describe('byCategory', function() {
        it('Returns empty array when category not recognised', function() {
          expect(collated.byCategory('NonExistantCategory')).to.deep.equal([]);
        });


        it('Works as expected (1)', function() {
          var expected = [testData[0][1], testData[1][0]];
          expect(collated.byCategory(testData[0][1].category)).to.deep.equal(expected);
        });


        it('Works as expected (2)', function() {
          var expected = [testData[1][1]];
          expect(collated.byCategory(testData[1][1].category)).to.deep.equal(expected);
        });


        it('Adds objects representing synonyms as required', function() {
          var expected = [testData[0][0], {name: 'Cat1Func2', filename: 'a.js', synonymFor: 'Cat1Func1'},
                          {name: 'Cat1Func3', filename: 'a.js', synonymFor: 'Cat1Func1'}, testData[1][2], testData[2][0],
                          {name: 'Cat1Func6', filename: 'd.js',synonymFor: 'Cat1Func5'} ];
          expect(collated.byCategory(testData[0][0].category)).to.deep.equal(expected);
        });
      });


      describe('byName', function() {
        it('Works as expected', function() {
          var expected = [
            testData[0][0], {name: 'Cat1Func2', filename: 'a.js',synonymFor: 'Cat1Func1'},
            {name: 'Cat1Func3', filename: 'a.js',synonymFor: 'Cat1Func1'}, testData[1][2], testData[2][0],
            {name: 'Cat1Func6', filename: 'd.js',synonymFor: 'Cat1Func5'}, testData[0][1], testData[1][0],
            testData[1][1]
          ];

          expect(collated.byName()).to.deep.equal(expected);
        });
      });


      describe('allNames', function() {
        it('Works as expected', function() {
          var expected = [
            testData[0][0], {name: 'Cat1Func2', filename: 'a.js',synonymFor: 'Cat1Func1'},
            {name: 'Cat1Func3', filename: 'a.js',synonymFor: 'Cat1Func1'}, testData[1][2], testData[2][0],
            {name: 'Cat1Func6', filename: 'd.js',synonymFor: 'Cat1Func5'}, testData[0][1], testData[1][0],
            testData[1][1]
          ].map(function(val) { return val.name; });

          expect(collated.getNames()).to.deep.equal(expected);
        });
      });


      describe('getFileNames', function() {
        it('Works as expected', function() {
          var expected = ['a.js', 'b.js', 'd.js', 'e/c.js'];
          expect(collated.getFileNames()).to.deep.equal(expected);
        });
      });
    });
  });
})();

},{"../../docgen/APIFunction":2,"../../docgen/APIObject":3,"../../docgen/collator":5,"chai":64}],42:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var createTestData = require('./CPTestDataHelper').createTestData;
  var APIFunction = require('../../docgen/APIFunction');
  var APIObject = require('../../docgen/APIObject');
  var commentProcessor = require('../../docgen/commentProcessor');


  var testData;
  beforeEach(function() {
    testData = createTestData();
  });


  /*
   * Helper function for transforming automatically generated test data into the form required for APIObject
   * construction if required.
   *
   */

  var makeType = function(testData, type) {
    type = type.toLowerCase();
    if (type === 'apifunction') return testData;

    testData = testData.removeProperty('parameters').removeProperty('synonyms').removeProperty('returns');
    testData.tag = 'apiobject';
    return testData;
  };



  describe('commentProcessor', function() {
    describe('Behaviour', function() {
      describe('Common behaviours', function() {
        ['APIFunction', 'APIObject'].forEach(function(type) {
          it('Throws if data not tagged when data has shape of ' + type, function() {
            testData = makeType(testData, type);
            delete testData.tag;
            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });



          it('Throws if first non-degenerate line contains more than one word for ' + type, function() {
            var testData = ['  myvar some more text', '', 'A badly written comment'];
            testData.tag = type.toLowerCase();
            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          /*
           * Generate tests that ensure comments where the function name is not first are rejected. We don't explicitly check
           * for the summary line, as we can assume it will be a line containing more than one word; another test detects
           * whether such lines are rejected.
           *
           */

          ['category', 'examples'].forEach(function(field) {
            it('Throws when ' + field + ' appears before the function name for ' + type, function() {
              testData = makeType(testData, type);
              testData = testData.moveBefore(field, 'name');
              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });
          });


          it('Throws if category field contains more than one word for ' + type, function() {
            testData = makeType(testData, type);
            testData = testData.replaceProperty('category', 'Category: foo bar');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if category field missing for ' + type, function() {
            testData = makeType(testData, type);
            testData = testData.removeProperty('category');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if summary missing for ' + type, function() {
            testData = makeType(testData, type);
            // Need to remove both summary and details, or details will be detected as the summary
            testData = testData.removeProperty('summary').removeProperty('details');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          /*
           * Generate tests that ensure comments containing multiple magic fields are rejected. We don't explicitly check
           * cases where the name is duplicated - a second name line would be regarded as a summary line, so this scenario
           * will be exercised by the tests looking for out-of-order fields.
           *
           * Duplicated code examples are tested separately.
           *
           */

          ['category', 'examples'].forEach(function(field) {
            it('Throws if ' + field + ' field is duplicated for ' + type, function() {
              testData = makeType(testData, type);
              var fieldData = testData.getPropertyValue(field);
              testData = testData.replaceProperty(field, fieldData.concat(fieldData));
              var fn = function() {
                 commentProcessor(testData);
              };

              expect(fn).to.throw();
            });
          });


          it('Throws if code examples are duplicated (2) for ' + type, function() {
            testData = makeType(testData, type);
            testData = testData.concat(['Examples: ']);
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if category field appears after the summary and details for ' + type, function() {
            testData = makeType(testData, type);
            testData = testData.moveAfter('category', 'details');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if category field appears after the summary and before details for ' + type, function() {
            testData = makeType(testData, type);
            testData = testData.moveBefore('category', 'details');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if code examples before summary for ' + type, function() {
            testData = makeType(testData, type);
            testData = testData.moveBefore('examples', 'summary');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if code examples are degenerate for ' + type, function() {
            testData = makeType(testData, type);
            testData = testData.replaceProperty('examples', ['Examples:']);
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          ['details', 'examples'].forEach(function(field) {
            it('Does not throw if ' + field + ' not present', function() {
              testData = makeType(testData, type);
              testData = testData.removeProperty(field);
              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.not.throw();
            });
          });


          /*
           * Generate tests that ensure left indentation is consistent.
           *
           */

          ['category', 'summary'].forEach(function(field) {
            it('Throws if ' + field + ' has indentation when name field does not for ' + type, function() {
              testData = makeType(testData, type);
              testData = testData.replaceProperty(field, testData.getPropertyValue(field).map(function(line) {
                return '  ' + line;
              }));

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });


            it('Throws if ' + field + ' has more indentation than name field for ' + type, function() {
              testData = makeType(testData, type);

              // First, we need to apply consistent indentation to everything
              var indentation = '  ';
              testData = testData.applyToAll(function(val) {
                return val.map(function(s) { return indentation + s; });
              });

              // Then add more indentation to the field
              testData = testData.replaceProperty(field, testData.getPropertyValue(field).map(function(line) {
                return '  ' + line;
              }));

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });


            it('Throws if ' + field + ' has less indentation than name field for ' + type, function() {
              testData = makeType(testData, type);

              // First, we need to apply consistent indentation to everything
              var indentation = '  ';
              testData = testData.applyToAll(function(val) {
                return val.map(function(s) { return indentation + s; });
              });

              // Then add remove indentation from the field
              testData = testData.replaceProperty(field, testData.getPropertyValue(field).map(function(line) {
                return line.trim();
              }));

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });
          });


          /*
           * The left indentation requirements on examples and details are slightly different. We expect that the first
           * line has the same amount of indentation as name, but for later lines it is permissible to have more. It is
           * still never permissible to have less.
           *
           */

          ['details', 'examples'].forEach(function(field) {
            it('Throws if if first line of ' + field + ' has indentation when name does not for ' + type, function() {
              testData = makeType(testData, type);
              var newValue = ['  ' + field + ':'].concat(testData.getPropertyValue(field).slice(1));
              testData = testData.replaceProperty(field, newValue);

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });


            it('Throws if first line of ' + field + ' has more indentation than name for ' + type, function() {
              testData = makeType(testData, type);

              // First, we need to apply consistent indentation to everything
              var indentation = '  ';
              testData = testData.applyToAll(function(val) {
                return val.map(function(s) { return indentation + s; });
              });

              // Then add more indentation to the first line of the field. Note that the first "line" of examples
              // is the examples keyword; it is this which must be aligned.
              var existing = testData.getPropertyValue(field);
              testData = testData.replaceProperty(field, ['  ' + existing[0]].concat(existing.slice(1)));

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });


            it('Throws if ' + field + ' has less indentation than name (1) for ' + type, function() {
              // In this test, we blanket deindent all the lines
              testData = makeType(testData, type);

              // First, we need to apply consistent indentation to everything
              var indentation = '  ';
              testData = testData.applyToAll(function(val) {
                return val.map(function(s) { return indentation + s; });
              });

              // Then add remove indentation from the field
              testData = testData.replaceProperty(field, testData.getPropertyValue(field).map(function(line) {
                return line.trim();
              }));

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });


            it('Throws if ' + field + ' has less indentation than name (2) for ' + type, function() {
              // In this test, we test the case where only one line has less indentation
              testData = makeType(testData, type);

              // Ensure the field has multiple lines
              testData = testData.replaceProperty(field, [field + ':', 'Line 2', 'Line 3']);

              // First, we need to apply consistent indentation to everything
              var indentation = '  ';
              testData = testData.applyToAll(function(val) {
                return val.map(function(s) { return indentation + s; });
              });

              // Then add remove indentation from the field
              var existing = testData.getPropertyValue(field);
              testData = testData.replaceProperty(field, [existing[0], existing[1].trim(), existing[2]]);

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.throw();
            });


            it('Does not throw if line of ' + field + ' other than first has more indentation than name for ' + type +
               ' (1)', function() {
              // Ensure the field has multiple lines
              testData = testData.replaceProperty(field, [field + ':', 'Line 2', 'Line 3']);

              // Add more indentation to the third line of the field
              var existing = testData.getPropertyValue(field);
              testData = testData.replaceProperty(field, [existing[0], existing[1], '  ' + existing[2]]);

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.not.throw();
            });


            it('Does not throw if line of ' + field + ' other than first has more indentation than name for ' + type +
               ' (2)', function() {
              // Ensure the field has multiple lines
              testData = testData.replaceProperty(field, [field + ':', 'Line 2', 'Line 3']);

              // First, we need to apply consistent indentation to everything
              var indentation = '  ';
              testData = testData.applyToAll(function(val) {
                return val.map(function(s) { return indentation + s; });
              });

              // Then add more indentation to the third line of the field
              var existing = testData.getPropertyValue(field);
              testData = testData.replaceProperty(field, [existing[0], existing[1], '  ' + existing[2]]);

              var fn = function() {
                commentProcessor(testData);
              };

              expect(fn).to.not.throw();
            });
          });


          it('Throws if later examples lines have less indentation than the first (1) for ' + type, function() {
            // In this test, we test the case where there is other indentation, and the first line is not indented
            testData = makeType(testData, type);

            testData = testData.replaceProperty('examples', ['Examples: ', '  Correct indent', 'Unindented line',
                                                             '  Correct indent']);
            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if later examples lines have less indentation than the first (2) for ' + type, function() {
            // In this test, we test the case where there is no other indentation
            testData = makeType(testData, type);

            // Ensure the field has multiple lines
            testData = testData.replaceProperty('examples', ['Examples:', 'Correct indent', 'Incorrect', 'Correct']);

            var indentation = '  ';
            testData = testData.applyToAll(function(val) {
              return val.map(function(s) { return indentation + s; });
            });

            var existing = testData.getPropertyValue('examples');
            var newExamples = existing.map(function (s) { return s.indexOf('Incorrect') === -1 ? s : s.trim(); });
            testData = testData.replaceProperty('examples', newExamples);
            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          /*
           * Generate tests that show that lines which may prove problematic when generating HTML from Markdown are
           * disallowed from appearing in the text fields.
           *
           */

          var problematicLineTests = [
            {name: 'usage', value: '** Usage: **'},
            {name: 'parameters', value: 'Parameters:'},
            {name: 'synonyms', value: '* Synonyms: * `s1` | `s2`'},
            {name: 'synonym ref', value: 'See foo'},
            {name: 'h1', value: '# foo #'},
            {name: 'h2', value: '## foo ##'},
            {name: 'h3', value: '### foo ###'},
            {name: 'h4', value: '#### foo ####'},
            {name: 'horizontal rule 1', value: '---'},
            {name: 'horizontal rule 2', value: '* * * * * *'},
            {name: 'horizontal rule 3', value: '***'},
            {name: 'horizontal rule 4', value: '- - - -'},
          ];

          ['summary', 'details', 'examples'].forEach(function(field) {
            problematicLineTests.forEach(function(test) {
              it('Problematic ' + test.name + ' line allowed if no options supplied', function() {
                testData = testData.replaceProperty(field, [field + ':', test.value, 'Line 3']);
                var fn = function() {
                  commentProcessor(testData);
                };

                expect(fn).to.not.throw();
              });


              it('Problematic ' + test.name + ' line allowed if options explicitly allow', function() {
                testData = testData.replaceProperty(field, [field + ':', test.value, 'Line 3']);
                var fn = function() {
                  commentProcessor(testData, {allowProblematicForHTMLGeneration: true});
                };

                expect(fn).to.not.throw();
              });


              it('Problematic ' + test.name + ' line disallowed when options disallow', function() {
                testData = testData.replaceProperty(field, [field + ':', test.value, 'Line 3']);
                var fn = function() {
                  commentProcessor(testData, {allowProblematicForHTMLGeneration: false});
                };

                expect(fn).to.throw();
              });
            });
          });
        });
      });


      describe('APIFunction specific', function() {

        /*
         * Generate tests that ensure comments where the function name is not first are rejected. We don't explicitly check
         * for the summary line, as we can assume it will be a line containing more than one word; another test detects
         * whether such lines are rejected.
         *
         */

        ['parameter', 'return type', 'synonyms'].forEach(function(field) {
          it('Throws when ' + field + ' appears before the function name', function() {
            testData = testData.moveBefore(field, 'name');
            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });
        });


        /*
         * Generate tests that ensure comments containing multiple magic fields are rejected. We don't explicitly check
         * cases where the name is duplicated - a second name line would be regarded as a summary line, so this scenario
         * will be exercised by the tests looking for out-of-order fields.
         *
         * Note that for the parameter field, we precisely test that two lines containing the exact same parameter
         * information is repeated. Another test checks to ensure that lines containing the same parameter name but
         * conflicting information is rejected.
         *
         * Duplicated code examples are tested separately.
         *
         */

        ['parameter', 'return type', 'synonyms'].forEach(function(field) {
          it('Throws if ' + field + ' field is duplicated', function() {
            var fieldData = testData.getPropertyValue(field);
            testData = testData.replaceProperty(field, fieldData.concat(fieldData));
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });
        });


        it('Throws if parameter testData contain conflicting information', function() {
          var badParams = ['Parameter: x: number', 'Parameter: x: string'];
          testData = testData.replaceProperty('parameter', badParams);
          var fn = function() {
             commentProcessor(testData);
          };

          expect(fn).to.throw();
        });


        /*
         * Generate tests that ensure comments where information fields appear after the summary are rejected.
         *
         */

        ['parameter', 'return type', 'synonyms'].forEach(function(field) {
          it('Throws if ' + field + ' field appears after the summary and details', function() {
            testData = testData.moveAfter(field, 'details');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if ' + field + ' field appears after the summary and before details', function() {
            testData = testData.moveBefore(field, 'details');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });
        });


        /*
         * Generate tests that ensure comments containing certain fields between parameter and return type fields are rejected.
         *
         */

        ['category', 'synonyms', 'examples'].forEach(function(field) {
          it('Throws if ' + field + ' field appears between the parameters and return type', function() {
            testData = testData.moveAfter(field, 'parameter');
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if ' + field + ' field appears between parameters fields', function() {
            var fieldData = testData.getPropertyValue(field);
            var params = ['Parameter: x: number', 'Parameter: y: string'];
            params.splice.apply(params, [1, 0].concat(fieldData));
            testData = testData.replaceProperty('parameter', params);
            var fn = function() {
               commentProcessor(testData);
            };

            expect(fn).to.throw();
          });
        });


        it('More than one parameter OK', function() {
          testData = testData.replaceProperty('parameter', ['Parameter: x: string', 'Parameter: y: number']);
          var fn = function() {
             commentProcessor(testData);
          };

          expect(fn).to.not.throw();
        });


        it('Fields are case insensitive', function() {
          var tag = testData.tag;
          testData = testData.map(function(s) { return s.toUpperCase(); });
          testData.tag = tag;
          testData.file = 'a.js';
          var fn = function() {
            commentProcessor(testData);
          };

          expect(fn).to.not.throw();
        });


        it('Does not throw if no parameters or return type present', function() {
          testData = testData.removeProperty('parameter').removeProperty('return type');
          var fn = function() {
            commentProcessor(testData);
          };

          expect(fn).to.not.throw();
        });


        /*
         * Generate tests that ensure left indentation is consistent.
         *
         */

        ['parameter', 'return type', 'synonyms'].forEach(function(field) {
          it('Does not throw if ' + field + ' not present', function() {
            testData = testData.removeProperty(field);
            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.not.throw();
          });


          it('Throws if ' + field + ' has indentation when name field does not', function() {
            testData = testData.replaceProperty(field, testData.getPropertyValue(field).map(function(line) {
              return '  ' + line;
            }));

            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if ' + field + ' has more indentation than name field', function() {
            // First, we need to apply consistent indentation to everything
            var indentation = '  ';
            testData = testData.applyToAll(function(val) {
              return val.map(function(s) { return indentation + s; });
            });

            // Then add more indentation to the field
            testData = testData.replaceProperty(field, testData.getPropertyValue(field).map(function(line) {
              return '  ' + line;
            }));

            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });


          it('Throws if ' + field + ' has less indentation than name field', function() {
            // First, we need to apply consistent indentation to everything
            var indentation = '  ';
            testData = testData.applyToAll(function(val) {
              return val.map(function(s) { return indentation + s; });
            });

            // Then add remove indentation from the field
            testData = testData.replaceProperty(field, testData.getPropertyValue(field).map(function(line) {
              return line.trim();
            }));

            var fn = function() {
              commentProcessor(testData);
            };

            expect(fn).to.throw();
          });
        });
      });


      describe('APIObject specific behaviours', function() {
        it('Throws if data is tagged as apiobject, and parameters present', function() {
          testData.tag = 'apiobject';
          testData = testData.removeProperty('returns').removeProperty('synonyms');
          var fn = function() {
            commentProcessor(testData);
          };

          expect(fn).to.throw();
        });


        it('Throws if data is tagged as apiobject, and return type present', function() {
          testData.tag = 'apiobject';
          testData = testData.removeProperty('parameters').removeProperty('synonyms');
          var fn = function() {
            commentProcessor(testData);
          };

          expect(fn).to.throw();
        });


        it('Throws if data is tagged as apiobject, and synonyms present', function() {
          testData.tag = 'apiobject';
          testData = testData.removeProperty('parameters').removeProperty('synonyms');
          var fn = function() {
            commentProcessor(testData);
          };

          expect(fn).to.throw();
        });


        it('Fields are case insensitive', function() {
          testData = makeType(testData, 'apiobject');
          testData = testData.map(function(s) { return s.toUpperCase(); });
          testData.tag = 'apiobject';
          testData.file = 'a.js';
          var fn = function() {
            commentProcessor(testData);
          };

          expect(fn).to.not.throw();
        });
      });
    });


    describe('Results', function() {
      var props;

      beforeEach(function() {
        // We reset everything each time to confirm there is no state being transmitted between tests through
        // these variables. We assume mocha runs the global beforeEach first setting resetting testData.

        // Helper function that transforms a line of the form <keyword>: data, returning only the data portion
        var afterColon = function(line) {
          if (Array.isArray(line)) line = line.join('');
          return line.split(':')[1].trim();
        };

        // Note that category is recaptalised by APIFunction
        var category = afterColon(testData.getPropertyValue('category'));
        category = category[0].toUpperCase() + category.slice(1);

        // TODO: There are some implicit assumptions here about the test data: document them
        props = {
          name:  testData.getPropertyValue('name')[0].trim(''),
          category:  category,
          parameterName:  afterColon(testData.getPropertyValue('parameter')),
          parameterType:  testData.getPropertyValue('parameter').join('').split(':')[2].trim(),
          returnType:  [afterColon(testData.getPropertyValue('return type'))],
          synonyms:  afterColon(testData.getPropertyValue('synonyms')).split(',').map(function(s) {return s.trim();}),
          summary:  testData.getPropertyValue('summary').slice(0, -1).join('\n'),
          details:  testData.getPropertyValue('details'),
          examples:  testData.getPropertyValue('examples').slice(1),
          filename: testData.file
        };
      });


      describe('Common results', function() {
        ['apifunction', 'apiobject'].forEach(function(dataType) {
          ['name', 'filename', 'category', 'summary'].forEach(function(property) {
            it(property + ' is correct for ' + dataType, function() {
              testData = makeType(testData, dataType);

              expect(commentProcessor(testData)[property]).to.equal(props[property]);
            });


            it(property + ' has common indentation stripped for ' + dataType, function() {
              testData = makeType(testData, dataType);
              var indented = testData.applyToAll(function(arr) {
                return arr.map(function(s) { return '  ' + s; });
              });

              expect(commentProcessor(indented)[property]).to.deep.equal(commentProcessor(testData)[property]);
            });
          });


          it('Multiple details correct for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var details = ['details line 1', 'details line 2', 'details line 3', 'details line 4'];
            testData = testData.replaceProperty('details', details);
            expect(commentProcessor(testData).details).to.deep.equal(details);
          });


          it('Multiple examples correct for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var examples = ['var x = foo();', '// blah blah', '', 'var g = 1;'];
            testData = testData.replaceProperty('examples', ['Examples:'].concat(examples));
            expect(commentProcessor(testData).examples).to.deep.equal(examples);
          });


          it('Multiple summary lines are merged into one for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var summary = ['Summary line 1.', 'Summary line 2.', 'Summary line 3.', ''];
            testData = testData.replaceProperty('summary', summary);
            expect(commentProcessor(testData).summary).to.deep.equal(summary.slice(0, -1).join('\n'));
          });


          it('Merging of multiple summary lines accounts for indentation for ' + dataType, function() {
            testData = makeType(testData, dataType);
            var summary = ['Summary line 1.', 'Summary line 2.', 'Summary line 3.', ''];
            testData = testData.replaceProperty('summary', summary);
            var indented = testData.applyToAll(function(arr) {
              return arr.map(function(s) { return '  ' + s; });
            });

            expect(commentProcessor(indented).summary).to.deep.equal(summary.slice(0, -1).join('\n'));
          });


          it('Multiple summary lines merging doesn\'t add unneccesary newlines for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var summary = ['Summary line 1.\n', 'Summary line 2.', 'Summary line 3.', ''];
            testData = testData.replaceProperty('summary', summary);
            expect(commentProcessor(testData).summary).to.deep.equal(summary[0] + summary.slice(1, -1).join('\n'));
          });


          it('Trailing empty lines after examples are ignored for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var examples = ['var x = foo();'];
            testData = testData.replaceProperty('examples', ['Examples:'].concat(examples).concat([' ', '']));
            expect(commentProcessor(testData).examples).to.deep.equal(examples);
          });


          it('Trailing empty lines between examples marker and first examples lines are ignored ' + dataType,
             function() {
            testData = makeType(testData, dataType);

            var examples = ['var x = foo();', '', 'var y = foo();'];
            testData = testData.replaceProperty('examples', ['Examples:', '', ' '].concat(examples));
            expect(commentProcessor(testData).examples).to.deep.equal(examples);
          });


          it('Trailing empty lines between details and examples marker are ignored ' + dataType, function() {
            testData = makeType(testData, dataType);

            var details = ['details line 1', '', 'details line 2'];
            var examples = ['var x = foo();', '', 'var y = foo();'];
            testData = testData.replaceProperty('details', details.concat([' ', '']));
            testData = testData.replaceProperty('examples', ['Examples:'].concat(examples));
            expect(commentProcessor(testData).details).to.deep.equal(details);
            expect(commentProcessor(testData).examples).to.deep.equal(examples);
          });


          it('Ignores multiple empty lines between summary and details ' + dataType, function() {
            testData = makeType(testData, dataType);

            var summary = 'Summary';
            testData = testData.replaceProperty('summary', [summary, '', '', ' ']);
            var result = commentProcessor(testData);
            expect(result.summary).to.equal(summary);
            expect(result.details).to.deep.equal(props.details);
          });


          it('Ignores multiple empty lines between summary and examples for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var summary = 'Summary';
            testData = testData.removeProperty('details').replaceProperty('summary', [summary, '', '', ' ']);
            var result = commentProcessor(testData);
            expect(result.summary).to.equal(summary);
            expect(result.examples).to.deep.equal(props.examples);
          });


          it('Ignores multiple empty lines at end of summary when no examples or details present for ' + dataType,
             function() {
            testData = makeType(testData, dataType);

            var summary = 'Summary';
            testData = testData.removeProperty('details').removeProperty('examples');
            testData = testData.replaceProperty('summary', [summary, '', '', ' ']);
            var result = commentProcessor(testData);
            expect(result.summary).to.equal(summary);
          });


          it('A line consisting only of whitespace can demarcate the summary and details for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var summary = 'Summary';
            testData = testData.replaceProperty('summary', [summary, '  ']);
            var result = commentProcessor(testData);
            expect(result.summary).to.deep.equal(summary);
            expect(result.details).to.deep.equal(props.details);
          });


          ['details', 'examples'].forEach(function(propName) {
            it(propName + ' correct for ' + dataType, function() {
              testData = makeType(testData, dataType);

              expect(commentProcessor(testData)[propName]).to.deep.equal(props[propName]);
            });


            it(propName + ' correct when not supplied for ' + dataType, function() {
              testData = makeType(testData, dataType);

              var prop = (propName !== 'return type' ? propName : 'returnType');
              testData = testData.removeProperty(propName);
              expect(commentProcessor(testData)[propName]).to.deep.equal([]);
            });


            it(propName + ' has common indentation stripped for ' + dataType, function() {
              testData = makeType(testData, dataType);
              var indented = testData.applyToAll(function(arr) {
                return arr.map(function(s) { return '  ' + s; });
              });

              expect(commentProcessor(indented)[propName]).to.deep.equal(commentProcessor(testData)[propName]);
            });
          });


          it('category is case insensitive for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var existing = testData.getPropertyValue('category');
            var newData = testData.replaceProperty('category', existing.map(function(s) {
              return s.replace('Category', 'CATEGORY');
            }));

            expect(commentProcessor(newData).category).to.deep.equal(commentProcessor(testData).category);
          });


          it('category is whitespace insensitive for ' + dataType, function() {
            testData = makeType(testData, dataType);

            var existing = testData.getPropertyValue('category');
            var newData = testData.replaceProperty('category', existing.map(function(s) {
              return s.replace(':', '  :  ');
            }));

            expect(commentProcessor(newData).category).to.deep.equal(commentProcessor(testData).category);
          });


          it('Details have indentation in lines other than first preserved for ' + dataType, function() {
            testData = makeType(testData, dataType);

            // Ensure we have a multi-line field. Note that all lines other than the first have indentation
            // additional to the common indentation that will be applied below
            var expected = ['Details line 1', '  line 2 with indent', '  line 3 with indent', 'line 4'];
            testData = testData.replaceProperty('details', expected);
            var indented = testData.applyToAll(function(arr) {
              return arr.map(function(s) { return '  ' + s; });
            });

            expect(commentProcessor(indented).details).to.deep.equal(expected);
          });


          it('Examples have indentation in lines other than first preserved for ' + dataType, function() {
            testData = makeType(testData, dataType);

            // Ensure we have a multi-line field. Note that all lines other than the first have indentation
            // additional to the common indentation that will be applied below
            var expected = ['Examples:', 'Examples line 1', '  line 2 with indent', '  line 3 with indent', 'line 4'];
            testData = testData.replaceProperty('examples', expected);
            var indented = testData.applyToAll(function(arr) {
              return arr.map(function(s) { return '  ' + s; });
            });

            expect(commentProcessor(indented).examples).to.deep.equal(expected.slice(1));
          });


          it('Examples have indentation level set by first line of examples stripped (1) for ' + dataType, function() {
            // First we test the case where the rest of the data has no indent
            testData = makeType(testData, dataType);

            // Ensure we have a multi-line field. Note that all lines other than the first have indentation
            // additional to the common indentation that will be applied below
            var expected = ['Examples line 1', '  line 2 with even more indent', '  line 3 with indent', 'line 4'];
            // Let's indent all the example lines
            var toReplace = ['Examples:'].concat(expected.map(function(s) { return '  ' + s; }));
            testData = testData.replaceProperty('examples', toReplace);

            expect(commentProcessor(testData).examples).to.deep.equal(expected);
          });


          it('Examples have indentation level set by first line of examples stripped (2) for ' + dataType, function() {
            // This time round, we also have a common indent in play. Thus the examples should have the common indent
            // and the example specific indent removed
            testData = makeType(testData, dataType);

            // Ensure we have a multi-line field. Note that all lines other than the first have indentation
            // additional to the common indentation that will be applied below
            var expected = ['Examples line 1', '  line 2 with even more indent', '  line 3 with indent', 'line 4'];
            // Let's indent all the example lines
            var toReplace = ['Examples:'].concat(expected.map(function(s) { return '  ' + s; }));
            testData = testData.replaceProperty('examples', toReplace);

            var indented = testData.applyToAll(function(arr) {
              return arr.map(function(s) { return '  ' + s; });
            });

            expect(commentProcessor(indented).examples).to.deep.equal(expected);
          });


          it('Correct constructor used for ' + dataType, function() {
            var expectedConstructor = {
              apifunction: APIFunction,
              apiobject: APIObject
            };

            testData = makeType(testData, dataType);
            expect(commentProcessor(testData)).to.be.an.instanceof(expectedConstructor[testData.tag]);
          });
        });
      });


      describe('APIFunction specific results', function() {
        it('Parameters correct', function() {
          var expected = [{name: props.parameterName, type: [props.parameterType]}];
          expect(commentProcessor(testData).parameters).to.deep.equal(expected);
        });


        [' | ', ', ', ' or '].forEach(function(separator, _, separators) {
          it('Parameter with multiple types correct when separated by "' + separator + '"', function() {
            var params = ['string', 'number', 'object'];
            var expected = [{name: 'x', type: params}];
            var paramString = 'Parameter: ' + expected[0].name + ': ' + expected[0].type.join(separator);
            testData = testData.replaceProperty('parameters', paramString);
            expect(commentProcessor(testData).parameters).to.deep.equal(expected);
          });


          it('Synonyms with multiple variants correct when separated by "' + separator + '"', function() {
            var synonyms = ['doIt', 'doOther', 'funcName'];
            testData = testData.replaceProperty('synonyms', 'Synonyms: ' + synonyms.join(separator));
            expect(commentProcessor(testData).synonyms).to.deep.equal(synonyms);
          });


          it('Multiple return types correct when separated by "' + separator + '"', function() {
            var returnTypes = ['string', 'number', 'object'];
            testData = testData.replaceProperty('return type', 'Returns: ' + returnTypes.join(separator));
            expect(commentProcessor(testData).returnType).to.deep.equal(returnTypes);
          });


          separators.forEach(function(separator2) {
            if (separator2 === separator) return;

            it('Parameter with multiple types correct with mixed separators "' + separator + '" and "' +
               separator2 + '"', function() {
              var paramTypes = ['string', 'number', 'object'];
              var params = paramTypes.slice(0, 2).join(separator) + separator2 + paramTypes[2];
              testData = testData.replaceProperty('parameters', 'Parameter: ' + props.parameterName + ': ' + params);
              var expected = [{name: props.parameterName, type: paramTypes}];
              expect(commentProcessor(testData).parameters).to.deep.equal(expected);
            });


            it('Synonyms with multiple variants correct when separated by "' + separator + '"', function() {
              var synonyms = ['doIt', 'doOther', 'funcName'];
              var synString = synonyms.slice(0, 2).join(separator) + separator2 + synonyms[2];
              testData = testData.replaceProperty('synonyms', 'Synonyms: ' + synString);
              expect(commentProcessor(testData).synonyms).to.deep.equal(synonyms);
            });


            it('Multiple return types correct when separated by "' + separator + '"', function() {
              var returnTypes = ['string', 'number', 'object'];
              var rtnString = returnTypes.slice(0, 2).join(separator) + separator2 + returnTypes[2];
              testData = testData.replaceProperty('return type', 'Returns: ' + rtnString);
              expect(commentProcessor(testData).returnType).to.deep.equal(returnTypes);
            });
          });
        });


        it('Multiple parameters correct', function() {
          var expected = [{name: 'x', type: ['number']}, {name: 'y', type: ['string']}];
          var params = expected.reduce(function (soFar, current) {
            return soFar.concat(['Parameter: ' + current.name + ': ' + current.type.join(' | ')]);
          }, []);
          testData = testData.replaceProperty('parameters', params);
          expect(commentProcessor(testData).parameters).to.deep.equal(expected);
        });


        ['synonyms', 'parameters', 'return type'].forEach(function(propName) {
          if (propName !== 'parameters') {
            it(propName + ' correct', function() {
              var prop = (propName !== 'return type' ? propName : 'returnType');
              expect(commentProcessor(testData)[prop]).to.deep.equal(props[prop]);
            });


            it(propName + ' correct when not supplied', function() {
              var prop = (propName !== 'return type' ? propName : 'returnType');
              testData = testData.removeProperty(prop);
              expect(commentProcessor(testData)[prop]).to.deep.equal([]);
            });
          }


          it(propName + ' is case insensitive', function() {
            var prop = (propName !== 'return type' ? propName : 'returns');
            var existing = testData.getPropertyValue(propName);
            var newData = testData.replaceProperty(prop, existing.map(function(s) {
              return s.replace(prop[0].toUpperCase() + prop.slice(1), prop.toUpperCase());
            }));

            expect(commentProcessor(newData)[prop]).to.deep.equal(commentProcessor(testData)[prop]);
          });


          it(propName + ' is whitespace insensitive', function() {
            var prop = (propName !== 'return type' ? propName : 'returns');
            var existing = testData.getPropertyValue(propName);
            var newData = testData.replaceProperty(propName, existing.map(function(s) {
                return s.replace(':', '  :  ');
            }));

            expect(commentProcessor(newData)[prop]).to.deep.equal(commentProcessor(testData)[prop]);
          });


          it(propName + ' is indentation insensitive', function() {
            var prop = (propName !== 'return type' ? propName : 'returns');
            var indented = testData.applyToAll(function(arr) {
              return arr.map(function(s) { return '  ' + s; });
            });

            expect(commentProcessor(indented)[prop]).to.deep.equal(commentProcessor(testData)[prop]);
          });
        });


        ['', ' '].forEach(function(empty, i) {
          it('Empty lines between fields are ignored (' + (i + 1) + ')', function() {
            ['name', 'category', 'synonyms', 'parameters', 'returns'].forEach(function(prop) {
              var existing = testData.getPropertyValue(prop);
              testData = testData.replaceProperty(prop, existing.concat([empty]));
            });

            var result = commentProcessor(testData);
            var allProps = ['name', 'category', 'synonyms', 'returnType', 'summary', 'details', 'examples'];
            allProps.forEach(function(propName) {
              expect(result[propName]).to.deep.equal(props[propName]);
            });

            expect(result.parameters).to.deep.equal([{name: props.parameterName, type: [props.parameterType]}]);
          });
        });
      });


      describe('APIObject specific results', function() {
        ['', ' '].forEach(function(empty, i) {
          it('Empty lines between fields are ignored (' + (i + 1) + ')', function() {
            ['name', 'category'].forEach(function(prop) {
              var existing = testData.getPropertyValue(prop);
              testData = testData.replaceProperty(prop, existing.concat([empty]));
            });

            ['returns', 'parameters', 'synonyms'].forEach(function(p) {
              testData = testData.removeProperty(p);
            });
            testData.tag = 'apiobject';

            var result = commentProcessor(testData);
            var allProps = ['name', 'category', 'summary', 'details', 'examples'];
            allProps.forEach(function(propName) {
              expect(result[propName]).to.deep.equal(props[propName]);
            });
          });
        });
      });
    });
  });
})();

},{"../../docgen/APIFunction":2,"../../docgen/APIObject":3,"../../docgen/commentProcessor":6,"./CPTestDataHelper":36,"chai":64}],43:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var LineProcessor = require('../../docgen/lineProcessor');


  /*
   * LineProcessor requires each array of comment contents to be tagged with the file it was found in. This convenience
   * function applies a fake tag to test data.
   *
   */

  var tagTestData = function(testData) {
    testData.forEach(function(arr) {
      arr.file = 'a.js';
    });

    return testData;
  };


  describe('LineProcessor', function() {
    ['apifunction', 'apiobject'].forEach(function(tag) {
      it('LineProcessor recognises a line with an <' + tag + '> opening tag', function() {
        var recognised = ['<' + tag + '>'];
        var testData = tagTestData([['foo'], ['* bar'], recognised]);
        var result = LineProcessor(testData);

        expect(result.length).to.equal(1);
      });


      it('LineProcessor recognises <' + tag + '> lines with whitespace or preceding asterisk', function() {
        var precedingWhiteSpace = ['  <' + tag + '>'];
        var trailingWhiteSpace = ['<' + tag + '>    '];
        var surroundingWhiteSpace = ['   <' + tag + '>    '];
        var commentFragment1 = ['  *  <' + tag + '>    '];
        var commentFragment2 = ['*  <' + tag + '>    '];
        var commentFragment3 = ['<' + tag + '>    *'];
        var commentFragment4 = [' * <' + tag + '>    *'];
        var testData = tagTestData([['foo'], ['bar'], precedingWhiteSpace, ['fizz'], trailingWhiteSpace, ['buzz'],
                        surroundingWhiteSpace, ['baz'], commentFragment1, commentFragment2, commentFragment3,
                        commentFragment4]);
        var result = LineProcessor(testData);

        expect(result.length).to.equal(7);
      });


      it('LineProcessor throws if <' + tag + '> is not the only item on the line', function() {
        var testData = tagTestData([['foo'], ['* bar'], ['*    <' + tag + '>    1 2 3 *']]);
        var fn = function() {
          LineProcessor(testData);
        };

        expect(fn).to.throw();
      });


      it('LineProcessor strips ' + tag + ' tag', function() {
        var precedingWhiteSpace = ['  <' + tag + '>'];
        var trailingWhiteSpace = ['<' + tag + '>    '];
        var surroundingWhiteSpace = ['   <' + tag + '>    '];
        var commentFragment1 = ['  *  <' + tag + '>    '];
        var commentFragment2 = ['*  <' + tag + '>    '];
        var commentFragment3 = ['<' + tag + '>    *'];
        var commentFragment4 = [' * <' + tag + '>    *'];
        var testData = tagTestData([precedingWhiteSpace, trailingWhiteSpace, surroundingWhiteSpace, commentFragment1,
                        commentFragment2, commentFragment3, commentFragment4].map(function(arr) {
          return arr.concat(['abc']);
        }));

        var result = LineProcessor(testData);

        expect(result.every(function(apiLines) {
          return apiLines[0].indexOf('<' + tag + '>') === -1;
        })).to.equal(true);
      });


      it('LineProcessor consumes rest of comment if no closing <' + tag + '> tag', function() {
        var testData = tagTestData([['foo'], ['* bar'], ['*     <' + tag + '>', 'abc', '', 'def', 'fizz', 'buzz']]);
        var result = LineProcessor(testData);

        expect(result[0].length).to.equal(5);
      });


      it('LineProcessor consumes to </' + tag + '> if present', function() {
        var apiLines = ['abc', '', 'def'];
        apiLines.tag = tag;
        apiLines.file = 'a.js';
        var recognised = ['  *  <' + tag + '>'].concat(apiLines).concat(['</' + tag + '>']);
        var testData = tagTestData([recognised]);
        var result = LineProcessor(testData);

        expect(result[0]).to.deep.equal(apiLines);
      });


      it('LineProcessor recognises </' + tag + '> lines with whitespace or comment asterisks', function() {
        var apiLines = ['abc', '', 'def'];
        apiLines.tag = tag;
        apiLines.file = 'a.js';
        var forms = ['  </' + tag + '>', '</' + tag + '>   ', '  </' + tag + '>', '* </' + tag + '>', ' * </' + tag + '>',
                     '</' + tag + '>   *', ' *</' + tag + '> *'];
        var testData = forms.map(function(form) {
          return ['  *<' + tag + '>  *'].concat(apiLines).concat(form);
        });
        var result = LineProcessor(tagTestData(testData));

        result.forEach(function(lines) {
          expect(lines).to.deep.equal(apiLines);
        });
      });


      it('LineProcessor throws if more than one <' + tag + '> tag in one comment', function() {
        var badForms = [[' <' + tag + '>'],
                        [' </' + tag + '>', '* <' + tag + '>'],
                        [' </' + tag + '>', '* </' + tag + '>'],
                        [' </' + tag + '>', 'baz', ' * <' + tag + '>  * ', '* </' + tag + '>']];
        badForms.forEach(function(bad) {
          var testData = tagTestData([[' <' + tag + '>'].concat(['foo']).concat(bad)]);
          var fn = function() {
            LineProcessor(testData);
          };

          expect(fn).to.throw();
        });
      });


      it('LineProcessor trims surrounding comment asterisks for ' + tag, function() {
        var testData = [['foo'], ['* bar']];
        var toBeTrimmed = ['*     <' + tag + '>', '*abc', '', '      *def * ', ' efgh     *', '* </' + tag + '>'];
        var expected = toBeTrimmed.slice(1, -1).map(function(line) {
          return line.replace(/^(\s*\*)?(.*)/, '$2');
        }).map(function(line) {
          return line.replace(/\s*(\*\s*)?$/, '');
        });

        expected.tag = tag;
        expected.file = 'a.js';
        testData[testData.length] = toBeTrimmed;
        testData = tagTestData(testData);
        var result = LineProcessor(testData);

        expect(result[0]).to.deep.equal(expected);
      });


      it('LineProcessor throws if </' + tag + '> is not the only item on the line', function() {
        var testData = tagTestData([['foo'], ['* bar'], ['* <' + tag + '>', 'abc', '*    </' + tag + '>    1 2 3 *']]);
        var fn = function() {
          LineProcessor(testData);
        };

        expect(fn).to.throw();
      });


      it('LineProcessor trims first space after a comment asterisk for ' + tag, function() {
        var testData = [['foo'], ['* bar']];
        var toBeTrimmed = ['*     <' + tag + '>', '* abc', '', '      * def * ', ' efgh     *', '* </' + tag + '>'];
        var expected = toBeTrimmed.slice(1, -1).map(function(line) {
          return line.replace(/^(\s*\*\s?)?(.*)/, '$2');
        }).map(function(line) {
          return line.replace(/\s*(\*\s*)?$/, '');
        });
        expected.tag = tag;
        expected.file = 'a.js';

        testData[testData.length] = toBeTrimmed;
        testData = tagTestData(testData);
        var result = LineProcessor(testData);

        expect(result[0]).to.deep.equal(expected);
      });


      it('LineProcessor attaches tag type to result for ' + tag, function() {
        var testData = tagTestData([['<' + tag + '>', 'foo', '</' + tag + '>']]);
        var result = LineProcessor(testData);

        expect(result[0].tag).to.equal(tag);
      });
    });


    it('LineProcessor throws if inconsistent tags in one comment', function() {
      var badForms = [[' <apifunction>', 'foo', '</apiobject>'],
                      [' <apiobject>', 'foo', '</apifunction>'],
                      [' <apifunction>', '<apiobject>', 'foo', '</apifunction>'],
                      [' <apifunction>', '<apiobject>', 'foo', '</apiobject>'],
                      [' <apiobject>', '<apifunction>', 'foo', '</apifunction>'],
                      [' <apiobject>', '<apifunction>', 'foo', '</apiobject>'],
                      [' <apifunction>', 'foo', '</apiobject>', '</apifunction>'],
                      [' <apifunction>', 'foo', '</apiobject>', '</apiobject>'],
                      [' <apiobject>', 'foo', '</apifunction>', '</apifunction>'],
                      [' <apiobject>', 'foo', '</apifunction>', '</apiobject>']];
      badForms.forEach(function(bad) {
        var fn = function() {
          LineProcessor(tagTestData([bad]));
        };

        expect(fn).to.throw();
      });
    });


    it('LineProcessor throws if multiple tags in one comment', function() {
      var badForms = [[' <apifunction>', 'foo', '</apifunction>', '<apiobject>', 'bar', '</apiobject>'],
                      [' <apiobject>', 'foo', '</apiobject>', '<apifunction>', 'bar', '</apifunction>']];
      badForms.forEach(function(bad) {
        var fn = function() {
          LineProcessor(tagTestData([bad]));
        };

        expect(fn).to.throw();
      });
    });


    it('LineProcessor throws if supplied lines do not have a filename tag (1)', function() {
      var untagged = [' <apifunction>', 'foo', '</apifunction>'];
      var fn = function() {
        LineProcessor([untagged]);
      };

      expect(fn).to.throw();
    });


    it('LineProcessor throws if supplied lines do not have a filename tag (2)', function() {
      var untagged = [' <apiobject>', 'foo', '</apiobject>'];
      var fn = function() {
        LineProcessor([untagged]);
      };

      expect(fn).to.throw();
    });


    it('LineProcessor preserves filename tag', function() {
      var tagged = [' <apifunction>', 'foo', '</apifunction>'];
      tagged.file = 'b.js';
      var result = LineProcessor([tagged]);

      expect(result[0].file).to.equal(tagged.file);
    });
  });
})();

},{"../../docgen/lineProcessor":7,"chai":64}],44:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var APIFunction = require('../../docgen/APIFunction');
  var APIObject = require('../../docgen/APIObject');
  var MarkdownCreator = require('../../docgen/markdownCreator');


  describe('Markdown creator', function() {
    // This array is used for test generation, and this requires that details and examples are the first two entries
    var options = {
      'details':    ['Line 1', '', 'Line 2'],
      'examples':   ['var x = foo();', '', 'var y = foo();'],
      'synonyms':   ['doIt', 'alternateName'],
      'parameters': [{name: 'x', type: ['Array']}, {name: 'y', type: ['string', 'number']}],
      'returnType': ['number'],
    };
    var optionalFields = Object.keys(options);


    /*
     * Most of the tests in this file will have to advance through the output, ensuring the lines at each position
     * match their expectations. To avoid repeating verification routines ad-nauseum, we provide some "global"
     * variables and routines to assist. The test should place the output into the 'result' variable, and the position
     * within the result into the 'pos' variable (result is assumed to be an array of strings). The test can then use
     * the verifyLine routine to check that the current line matches whilst advancing the position.
     *
     * The 'result' and 'pos' variables will be reset to generic values before each test; it is the result of each
     * individual test to set them to appropriate values before the first call to verifyLine.
     *
     */

    var pos, result;


    var verifyLine = function(line) {
      expect(result[pos]).to.equal(line);
      pos += 1;
    };


    beforeEach(function() {
      pos = 0;
      result = [];
    });


    /*
     * Helper functions for verifying portions of the expected output.
     *
     */

    var verifyName = function(name) {
      pos = 0;
      verifyLine('### ' + name + ' ###');
    };


    var verifyCategory = function(category) {
      verifyLine('Category: ' + category);
      verifyLine('');
    };


    var verifySynonyms = function(synonyms) {
      synonyms = synonyms.map(function (s, i, arr) { return '`' + s + '`' + (i !== arr.length - 1 ? ' | ' : ''); });
      synonyms = synonyms.join('');
      verifyLine('*Synonyms:* ' + synonyms);
      verifyLine('');
    };


    var verifyUsage = function(name, parameters, returnType) {
      parameters = parameters || [];
      returnType = returnType || [];

      var params = parameters.map(function(p) { return p.name; }).join(', ');
      var rtn = returnType.length > 0 ? '`var result = ' : '`';
      verifyLine('**Usage:** ' + rtn + name + '(' + params + ');`');
      verifyLine('');
    };


    var verifyParameters = function(parameters) {
      verifyLine('Parameters:  ');
      parameters.forEach(function(param, i, arr) {
        var types = param.type.map(function (s, i, arr) {
          return '`' + s + '`' + (i !== arr.length - 1 ? ' | ' : '');
        });
        types = types.join('');
        verifyLine(param.name + ' ' + types + (i !== arr.length - 1 ? '  ' : ''));
      });
      verifyLine('');
    };


    var verifyReturnType = function(returnType) {
      var types = returnType.map(function(s, i, arr) { return '`' + s + '`' + (i !== arr.length - 1 ? ' | ' : ''); });
      verifyLine('Returns: ' + types.join(''));
      verifyLine('');
    };


    var verifyDetails = function(details) {
      verifyLine('');
      details.forEach(function(line) {
        verifyLine(line);
      });
    };


    var verifyExamples = function(examples) {
      verifyLine('');
      verifyLine('#### Examples ####');
      examples.forEach(function(line) {
        verifyLine('    ' + line);
      });
    };


    var testDescription = function(testNumber, testType, testOptions) {
      var catText = ('includeCategory' in testOptions && testOptions.includeCategory ? '' : 'out') + ' category';
      if (testNumber === 0)
        return 'Markdown correct when ' + testType + ' contains no optional parameters with' + catText;

      var asBin = testNumber.toString(2);
      var contents = (testType === 'APIFunction' ? optionalFields : optionalFields.slice(0, 2)).filter(function(_, i) {
        return asBin[i] === '1';
      });

      var fieldDesc;
      if (contents.length === 1)
        fieldDesc = contents[0];
      else
        fieldDesc = contents.slice(0, -1).join(', ') + ' and ' + contents[contents.length - 1];

      return 'Markdown correct when ' + testType + ' contains ' + fieldDesc + ' options with' + catText;
    };


    var makeMarkdownTest = function(testNumber, testType, testOptions) {
      return function() {
        // Build the APIFunction object
        var asBin = testNumber.toString(2);
        var apiOptions = {};
        [].forEach.call(asBin, function(elem, i) {
          if (elem === '1') {
            var prop = optionalFields[i];
            apiOptions[prop] = options[prop];
          }
        });

        var name = 'test'+testNumber;
        var category = 'Category' + testNumber;
        var summary = 'summary' + testNumber;

        var constructor = testType === 'APIFunction' ? APIFunction : APIObject;
        result = MarkdownCreator(constructor(name, 'a.js', category, summary, apiOptions), testOptions).split('\n');

        verifyName(name);

        if ('includeCategory' in testOptions && testOptions.includeCategory)
          verifyCategory(category);

        if ('synonyms' in apiOptions)
          verifySynonyms(apiOptions.synonyms);

        if (testType !== 'APIObject')
          verifyUsage(name, apiOptions.parameters, apiOptions.returnType);

        if ('parameters' in apiOptions)
          verifyParameters(apiOptions.parameters);

        if ('returnType' in apiOptions)
          verifyReturnType(apiOptions.returnType);

        verifyLine(summary);

        if ('details' in apiOptions)
          verifyDetails(apiOptions.details);

        if ('examples' in apiOptions)
          verifyExamples(apiOptions.examples);

        verifyLine('***');
      };
    };


    /*
     * We want to check the output is correct for every combination of optional fields, so we generate these tests
     * automatically.
     *
     */

    for (var i = 0, l = Math.pow(2, optionalFields.length); i < l; i++) {
      it(testDescription(i, 'APIFunction', {includeCategory: true}),
         makeMarkdownTest(i, 'APIFunction', {includeCategory: true}));
      it(testDescription(i, 'APIFunction', {includeCategory: false}),
         makeMarkdownTest(i, 'APIFunction', {includeCategory: false}));
    }


    for (i = 0, l = Math.pow(2, optionalFields.slice(0, 2).length); i < l; i++) {
      it(testDescription(i, 'APIObject', {includeCategory: true}),
         makeMarkdownTest(i, 'APIObject', {includeCategory: true}));
      it(testDescription(i, 'APIObject', {includeCategory: false}),
         makeMarkdownTest(i, 'APIObject', {includeCategory: false}));
    }


    it('Markdown correct for an object representing a synonym', function() {
      var synonymObj = {name: 'bar', synonymFor: 'foo'};
      result = MarkdownCreator(synonymObj, {}).split('\n');

      pos = 0;
      verifyName('bar');
      verifyLine('See `foo`');
      verifyLine('***');
    });


    /*
     * Generate tests that prove that MarkdownCreator throws when supplied invalid objects.
     *
     */

    var invalidArrayData = [{value: 1, type: 'number'},
                            {value: true, type: 'boolean'},
                            {value: {}, type: 'random object'},
                            {value: undefined, type: 'undefined'},
                            {value: null, type: 'null' },
                            {value: [], type: 'array'},
                            {value: 'foo', type: 'string'},
                            {value: [Function], type: 'function'}];

    invalidArrayData.forEach(function(invalid) {
      it('Throws if supplied value is of type ' + invalid.type, function() {
        var fn = function() {
          MarkdownCreator(invalid.value, {includeCategory: false});
        };

        expect(fn).to.throw();
      });


      if (invalid.type !== 'random object') {
        it('Throws if options is of type ' + invalid.type, function() {
          var fn = function() {
            MarkdownCreator(APIFunction('name', 'Cat', 'summary', {}), invalid.value);
          };

          expect(fn).to.throw();
        });
      }
    });
  });
})();

},{"../../docgen/APIFunction":2,"../../docgen/APIObject":3,"../../docgen/markdownCreator":8,"chai":64}],45:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var marked = require('marked');
  var makeMarkdownRenderer = require('../../docgen/markdownRenderer');


  describe('Markdown renderer', function() {
    var renderer;

    beforeEach(function() {
      renderer = makeMarkdownRenderer([]);
    });


    it('Encountering a <h2> produces a section tag containing the <h2>', function() {
      var text = '## foo ##';
      var expected = '<section class="categoryRef" id="foo">\n<h2 class="categoryName">foo</h2>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Encountering a <h3> produces a section tag containing the <h3>', function() {
      var text = '### foo ###';
      var expected = '<section class="functionRef" id="foo">\n<h3 class="functionName">foo</h3>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Synonym reference lines should be returned essentially unchanged', function() {
      var text = 'See <code>bar</code>';
      var expected = '<p class="see">See <a class="synonymLink" href="#bar"><code class="synonymCode">bar</code>' +
                     '</a></p>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Renderer throws if no options given and category encountered', function() {
      var text = 'Category: Foo';
      var fn = function() {
        marked(text, {renderer: renderer});
      };

      expect(fn).to.throw();
    });


    it('Renderer throws if options do not contain a category filename and no isCategory flag', function() {
      var renderer = makeMarkdownRenderer([], {});
      var text = 'Category: Foo';
      var fn = function() {
        marked(text, {renderer: renderer});
      };

      expect(fn).to.throw();
    });


    it('Renderer throws if options do not contain a category filename and explicit false isCategory flag', function() {
      var renderer = makeMarkdownRenderer([], {isCategory: false});
      var text = 'Category: Foo';
      var fn = function() {
        marked(text, {renderer: renderer});
      };

      expect(fn).to.throw();
    });


    it('Renderer produces correct output when category encountered with category filename and no isCategory flag', function() {
      var renderer = makeMarkdownRenderer([], {categoryFile: 'a.html'});
      var text = 'Category: Foo';
      var expected = '<p class="category">Category: <a class="categoryLink" href="a.html#Foo">Foo</a></p>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Renderer output correct when category encountered with category filename and explicit false isCategory flag',
      function() {
      var renderer = makeMarkdownRenderer([], {categoryFile: 'a.html', isCategory: false});
      var text = 'Category: Foo';
      var expected = '<p class="category">Category: <a class="categoryLink" href="a.html#Foo">Foo</a></p>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Renderer output correct when category encountered with category filename and explicit true isCategory flag',
      function() {
      var renderer = makeMarkdownRenderer([], {categoryFile: 'a.html', isCategory: true});
      var text = 'Category: Foo';
      var expected = '<p class="category">Category: <a class="categoryLink" href="#Foo">Foo</a></p>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Renderer output correct when category encountered with no category filename and explicit true isCategory flag',
      function() {
      var renderer = makeMarkdownRenderer([], {isCategory: true});
      var text = 'Category: Foo';
      var expected = '<p class="category">Category: <a class="categoryLink" href="#Foo">Foo</a></p>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Renderer output correct when category encountered with no category filename and explicit true isCategory flag',
      function() {
      var renderer = makeMarkdownRenderer([], {isCategory: true});
      var text = 'Category: Foo';
      var expected = '<p class="category">Category: <a class="categoryLink" href="#Foo">Foo</a></p>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Usage line rendered correctly', function() {
      var text = '**Usage:** `var result = arity(f);`';
      var expected = '<p class="usage"><strong>Usage:</strong> ' +
                     '<code class="usageCode">var result = arity(f);</code></p>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Synonyms lines rendered correctly (1)', function() {
      var text = '*Synonyms:* `foo`';
      var expected = '<div class="synonyms"><em>Synonyms:</em> <ul class="synonymsList"><li class="synonym">' +
                     '<code class="synonymName">foo</code></li></ul></div>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Synonyms lines rendered correctly (2)', function() {
      var text = '*Synonyms:* `foo` | `bar`';
      var expected = '<div class="synonyms"><em>Synonyms:</em> <ul class="synonymsList"><li class="synonym">' +
                     '<code class="synonymName">foo</code></li>' +
                     '<li class="synonym"><code class="synonymName">bar</code></li></ul></div>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Return type rendered correctly when nothing linkable provided', function() {
      var text = 'Returns: `number`';
      var expected = '<div class="returns">Returns: <ul class="returnTypes"><li class="returnItem">' +
                     '<code class="returnType type">number</code></li></ul></div>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Return type rendered correctly when linkables provided but don\'t match', function() {
      var renderer = makeMarkdownRenderer([], {toLink: ['string']});
      var text = 'Returns: `number`';
      var expected = '<div class="returns">Returns: <ul class="returnTypes"><li class="returnItem">' +
                     '<code class="returnType type">number</code></li></ul></div>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Return type rendered correctly when linkables provided and match', function() {
      var renderer = makeMarkdownRenderer([], {toLink: ['number']});
      var text = 'Returns: `number`';
      var expected = '<div class="returns">Returns: <ul class="returnTypes"><li class="returnItem">' +
                     '<a class="typeLink" href="#number">' +
                     '<code class="returnType type">number</code></a></li></ul></div>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Return type rendered correctly when linkables provided and some match', function() {
      var renderer = makeMarkdownRenderer([], {toLink: ['string', 'Foo']});
      var text = 'Returns: `number` | `string` | `Foo`';
      var expected = '<div class="returns">Returns: ' +
                     '<ul class="returnTypes"><li class="returnItem"><code class="returnType type">number</code>' +
                     '</li><li class="returnItem"><a class="typeLink" href="#string">' +
                     '<code class="returnType type">string</code></a></li><li class="returnItem">' +
                     '<a class="typeLink" href="#foo"><code class="returnType type">Foo</code></a></li></ul></div>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Parameters rendered correctly when no linkables provided (1)', function() {
      var text = 'Parameters:  \nf `function`';
      var expected = '<section class="parameters"><h4 class="parametersHeader">Parameters</h4>' +
                     '<ol class="parameterList"><li class="param">f: <ul class="paramTypes"><li class="paramsItem">' +
                     '<code class="paramType type">function</code></li></ul>' +
                     '</li></ol></section>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Parameters rendered correctly when no linkables provided (2)', function() {
      var text = 'Parameters:  \nf `function`  \ng `number`';
      var expected = '<section class="parameters"><h4 class="parametersHeader">Parameters</h4>' +
                     '<ol class="parameterList"><li class="param">f: <ul class="paramTypes"><li class="paramsItem">' +
                     '<code class="paramType type">function</code></li></ul>' +
                     '</li><li class="param">g: <ul class="paramTypes"><li class="paramsItem">' +
                     '<code class="paramType type">number</code></li></ul>' +
                     '</li></ol></section>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Parameters rendered correctly when linkables provided but none match', function() {
      var renderer = makeMarkdownRenderer([], {toLink: ['string']});
      var text = 'Parameters:  \nf `function`';
      var expected = '<section class="parameters"><h4 class="parametersHeader">Parameters</h4>' +
                     '<ol class="parameterList"><li class="param">f: <ul class="paramTypes"><li class="paramsItem">' +
                     '<code class="paramType type">function</code></li></ul>' +
                     '</li></ol></section>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Parameters rendered correctly when linkables provided and match', function() {
      var renderer = makeMarkdownRenderer([], {toLink: ['string']});
      var text = 'Parameters:  \nf `string`';
      var expected = '<section class="parameters"><h4 class="parametersHeader">Parameters</h4>' +
                     '<ol class="parameterList"><li class="param">f: <ul class="paramTypes"><li class="paramsItem">' +
                     '<a class="typeLink" href="#string">' +
                     '<code class="paramType type">string</code></a></li></ul></li></ol></section>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Parameters rendered correctly when linkables provided and some match', function() {
      var renderer = makeMarkdownRenderer([], {toLink: ['Bar']});
      var text = 'Parameters:  \nf `function`  \ng `Bar`';
      var expected = '<section class="parameters"><h4 class="parametersHeader">Parameters</h4>' +
                     '<ol class="parameterList"><li class="param">f: <ul class="paramTypes"><li class="paramsItem">' +
                     '<code class="paramType type">function</code></li></ul>' +
                     '</li><li class="param">g: <ul class="paramTypes"><li class="paramsItem">' +
                     '<a class="typeLink" href="#bar"><code class="paramType type">Bar' +
                     '</code></a></li></ul></li></ol></section>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Arbitrary paragraph rendered correctly', function() {
      var text = 'foo. bar. Whoopy doo.\nTum te tum';
      var expected = new marked.Renderer().paragraph(text);
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Examples rendered correctly', function() {
      var text = '#### Examples ####';
      var expected = '<section class="examples"><h4>Examples</h4>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Example code rendered correctly', function() {
      var text = '    var a = foo();';
      var expected = new marked.Renderer().code(text.slice(4)) + '</section>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });


    it('Horizontal rules rendered correctly', function() {
      var text = '***';
      var expected = '</section>\n';
      var rendered = marked(text, {renderer: renderer});
      expect(rendered).to.equal(expected);
    });
  });
})();

},{"../../docgen/markdownRenderer":9,"chai":64,"marked":35}],46:[function(require,module,exports){
(function() {
  "use strict";


  /* NOTE: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT MANUALLY */


  var expect = require('chai').expect;
  var funkier = require('../../lib/funkier');


  describe('Documented values', function() {
    describe('Err', function() {
      it('Err exists', function() {
        expect(funkier).to.have.a.property('Err');
      });


      it('funkierJS\'s Err is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.Err).to.equal(module.Err);
      });


      it('Err is a function', function() {
        expect(funkier.Err).to.be.a('function');
      });


      it('Err has documented arity', function() {
        expect(funkier.arityOf(funkier.Err)).to.equal(1);
      });


    });


    describe('Just', function() {
      it('Just exists', function() {
        expect(funkier).to.have.a.property('Just');
      });


      it('funkierJS\'s Just is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.Just).to.equal(module.Just);
      });


      it('Just is a function', function() {
        expect(funkier.Just).to.be.a('function');
      });


      it('Just has documented arity', function() {
        expect(funkier.arityOf(funkier.Just)).to.equal(1);
      });


    });


    describe('Maybe', function() {
      it('Maybe exists', function() {
        expect(funkier).to.have.a.property('Maybe');
      });


      it('funkierJS\'s Maybe is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.Maybe).to.equal(module.Maybe);
      });


      it('Maybe is a function', function() {
        expect(funkier.Maybe).to.be.a('function');
      });


      it('Maybe has documented arity', function() {
        expect(funkier.arityOf(funkier.Maybe)).to.equal(0);
      });


    });


    describe('Nothing', function() {
      it('Nothing exists', function() {
        expect(funkier).to.have.a.property('Nothing');
      });


      it('funkierJS\'s Nothing is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.Nothing).to.equal(module.Nothing);
      });


      it('Nothing is an object', function() {
        expect(funkier.Nothing).to.be.an('object');
      });
    });


    describe('Ok', function() {
      it('Ok exists', function() {
        expect(funkier).to.have.a.property('Ok');
      });


      it('funkierJS\'s Ok is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.Ok).to.equal(module.Ok);
      });


      it('Ok is a function', function() {
        expect(funkier.Ok).to.be.a('function');
      });


      it('Ok has documented arity', function() {
        expect(funkier.arityOf(funkier.Ok)).to.equal(1);
      });


    });


    describe('Pair', function() {
      it('Pair exists', function() {
        expect(funkier).to.have.a.property('Pair');
      });


      it('funkierJS\'s Pair is indeed the documented value', function() {
        var module = require('../../lib/components/pair');
        expect(funkier.Pair).to.equal(module.Pair);
      });


      it('Pair is a function', function() {
        expect(funkier.Pair).to.be.a('function');
      });


      it('Pair has documented arity', function() {
        expect(funkier.arityOf(funkier.Pair)).to.equal(2);
      });


    });


    describe('Result', function() {
      it('Result exists', function() {
        expect(funkier).to.have.a.property('Result');
      });


      it('funkierJS\'s Result is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.Result).to.equal(module.Result);
      });


      it('Result is a function', function() {
        expect(funkier.Result).to.be.a('function');
      });


      it('Result has documented arity', function() {
        expect(funkier.arityOf(funkier.Result)).to.equal(0);
      });


    });


    describe('add', function() {
      it('add exists', function() {
        expect(funkier).to.have.a.property('add');
      });


      it('funkierJS\'s add is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.add).to.equal(module.add);
      });


      it('add is a function', function() {
        expect(funkier.add).to.be.a('function');
      });


      it('add has documented arity', function() {
        expect(funkier.arityOf(funkier.add)).to.equal(2);
      });


      it('add is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.add)).to.equal(true);
      });
    });


    describe('all', function() {
      it('all exists', function() {
        expect(funkier).to.have.a.property('all');
      });


      it('all is a synonym for every', function() {
        expect(funkier.all).to.equal(funkier.every);
      });
    });


    describe('and', function() {
      it('and exists', function() {
        expect(funkier).to.have.a.property('and');
      });


      it('funkierJS\'s and is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.and).to.equal(module.and);
      });


      it('and is a function', function() {
        expect(funkier.and).to.be.a('function');
      });


      it('and has documented arity', function() {
        expect(funkier.arityOf(funkier.and)).to.equal(2);
      });


      it('and is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.and)).to.equal(true);
      });
    });


    describe('andPred', function() {
      it('andPred exists', function() {
        expect(funkier).to.have.a.property('andPred');
      });


      it('funkierJS\'s andPred is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.andPred).to.equal(module.andPred);
      });


      it('andPred is a function', function() {
        expect(funkier.andPred).to.be.a('function');
      });


      it('andPred has documented arity', function() {
        expect(funkier.arityOf(funkier.andPred)).to.equal(2);
      });


      it('andPred is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.andPred)).to.equal(true);
      });
    });


    describe('any', function() {
      it('any exists', function() {
        expect(funkier).to.have.a.property('any');
      });


      it('any is a synonym for some', function() {
        expect(funkier.any).to.equal(funkier.some);
      });
    });


    describe('append', function() {
      it('append exists', function() {
        expect(funkier).to.have.a.property('append');
      });


      it('funkierJS\'s append is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.append).to.equal(module.append);
      });


      it('append is a function', function() {
        expect(funkier.append).to.be.a('function');
      });


      it('append has documented arity', function() {
        expect(funkier.arityOf(funkier.append)).to.equal(2);
      });


      it('append is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.append)).to.equal(true);
      });
    });


    describe('apply', function() {
      it('apply exists', function() {
        expect(funkier).to.have.a.property('apply');
      });


      it('funkierJS\'s apply is indeed the documented value', function() {
        var module = require('../../lib/components/fn');
        expect(funkier.apply).to.equal(module.apply);
      });


      it('apply is a function', function() {
        expect(funkier.apply).to.be.a('function');
      });


      it('apply has documented arity', function() {
        expect(funkier.arityOf(funkier.apply)).to.equal(2);
      });


      it('apply is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.apply)).to.equal(true);
      });
    });


    describe('arity', function() {
      it('arity exists', function() {
        expect(funkier).to.have.a.property('arity');
      });


      it('arity is a synonym for arityOf', function() {
        expect(funkier.arity).to.equal(funkier.arityOf);
      });
    });


    describe('arityOf', function() {
      it('arityOf exists', function() {
        expect(funkier).to.have.a.property('arityOf');
      });


      it('funkierJS\'s arityOf is indeed the documented value', function() {
        var module = require('../../lib/components/curry');
        expect(funkier.arityOf).to.equal(module.arityOf);
      });


      it('arityOf is a function', function() {
        expect(funkier.arityOf).to.be.a('function');
      });


      it('arityOf has documented arity', function() {
        expect(funkier.arityOf(funkier.arityOf)).to.equal(1);
      });


      it('arityOf is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.arityOf)).to.equal(true);
      });
    });


    describe('asArray', function() {
      it('asArray exists', function() {
        expect(funkier).to.have.a.property('asArray');
      });


      it('funkierJS\'s asArray is indeed the documented value', function() {
        var module = require('../../lib/components/pair');
        expect(funkier.asArray).to.equal(module.asArray);
      });


      it('asArray is a function', function() {
        expect(funkier.asArray).to.be.a('function');
      });


      it('asArray has documented arity', function() {
        expect(funkier.arityOf(funkier.asArray)).to.equal(1);
      });


      it('asArray is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.asArray)).to.equal(true);
      });
    });


    describe('bind', function() {
      it('bind exists', function() {
        expect(funkier).to.have.a.property('bind');
      });


      it('funkierJS\'s bind is indeed the documented value', function() {
        var module = require('../../lib/components/curry');
        expect(funkier.bind).to.equal(module.bind);
      });


      it('bind is a function', function() {
        expect(funkier.bind).to.be.a('function');
      });


      it('bind has documented arity', function() {
        expect(funkier.arityOf(funkier.bind)).to.equal(2);
      });


      it('bind is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.bind)).to.equal(true);
      });
    });


    describe('bindWithContext', function() {
      it('bindWithContext exists', function() {
        expect(funkier).to.have.a.property('bindWithContext');
      });


      it('bindWithContext is a synonym for bind', function() {
        expect(funkier.bindWithContext).to.equal(funkier.bind);
      });
    });


    describe('bindWithContextAndArity', function() {
      it('bindWithContextAndArity exists', function() {
        expect(funkier).to.have.a.property('bindWithContextAndArity');
      });


      it('funkierJS\'s bindWithContextAndArity is indeed the documented value', function() {
        var module = require('../../lib/components/curry');
        expect(funkier.bindWithContextAndArity).to.equal(module.bindWithContextAndArity);
      });


      it('bindWithContextAndArity is a function', function() {
        expect(funkier.bindWithContextAndArity).to.be.a('function');
      });


      it('bindWithContextAndArity has documented arity', function() {
        expect(funkier.arityOf(funkier.bindWithContextAndArity)).to.equal(3);
      });


      it('bindWithContextAndArity is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.bindWithContextAndArity)).to.equal(true);
      });
    });


    describe('bitwiseAnd', function() {
      it('bitwiseAnd exists', function() {
        expect(funkier).to.have.a.property('bitwiseAnd');
      });


      it('funkierJS\'s bitwiseAnd is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.bitwiseAnd).to.equal(module.bitwiseAnd);
      });


      it('bitwiseAnd is a function', function() {
        expect(funkier.bitwiseAnd).to.be.a('function');
      });


      it('bitwiseAnd has documented arity', function() {
        expect(funkier.arityOf(funkier.bitwiseAnd)).to.equal(2);
      });


      it('bitwiseAnd is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.bitwiseAnd)).to.equal(true);
      });
    });


    describe('bitwiseNot', function() {
      it('bitwiseNot exists', function() {
        expect(funkier).to.have.a.property('bitwiseNot');
      });


      it('funkierJS\'s bitwiseNot is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.bitwiseNot).to.equal(module.bitwiseNot);
      });


      it('bitwiseNot is a function', function() {
        expect(funkier.bitwiseNot).to.be.a('function');
      });


      it('bitwiseNot has documented arity', function() {
        expect(funkier.arityOf(funkier.bitwiseNot)).to.equal(1);
      });


      it('bitwiseNot is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.bitwiseNot)).to.equal(true);
      });
    });


    describe('bitwiseOr', function() {
      it('bitwiseOr exists', function() {
        expect(funkier).to.have.a.property('bitwiseOr');
      });


      it('funkierJS\'s bitwiseOr is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.bitwiseOr).to.equal(module.bitwiseOr);
      });


      it('bitwiseOr is a function', function() {
        expect(funkier.bitwiseOr).to.be.a('function');
      });


      it('bitwiseOr has documented arity', function() {
        expect(funkier.arityOf(funkier.bitwiseOr)).to.equal(2);
      });


      it('bitwiseOr is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.bitwiseOr)).to.equal(true);
      });
    });


    describe('bitwiseXor', function() {
      it('bitwiseXor exists', function() {
        expect(funkier).to.have.a.property('bitwiseXor');
      });


      it('funkierJS\'s bitwiseXor is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.bitwiseXor).to.equal(module.bitwiseXor);
      });


      it('bitwiseXor is a function', function() {
        expect(funkier.bitwiseXor).to.be.a('function');
      });


      it('bitwiseXor has documented arity', function() {
        expect(funkier.arityOf(funkier.bitwiseXor)).to.equal(2);
      });


      it('bitwiseXor is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.bitwiseXor)).to.equal(true);
      });
    });


    describe('callProp', function() {
      it('callProp exists', function() {
        expect(funkier).to.have.a.property('callProp');
      });


      it('funkierJS\'s callProp is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.callProp).to.equal(module.callProp);
      });


      it('callProp is a function', function() {
        expect(funkier.callProp).to.be.a('function');
      });


      it('callProp has documented arity', function() {
        expect(funkier.arityOf(funkier.callProp)).to.equal(1);
      });


      it('callProp is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.callProp)).to.equal(true);
      });
    });


    describe('callPropWithArity', function() {
      it('callPropWithArity exists', function() {
        expect(funkier).to.have.a.property('callPropWithArity');
      });


      it('funkierJS\'s callPropWithArity is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.callPropWithArity).to.equal(module.callPropWithArity);
      });


      it('callPropWithArity is a function', function() {
        expect(funkier.callPropWithArity).to.be.a('function');
      });


      it('callPropWithArity has documented arity', function() {
        expect(funkier.arityOf(funkier.callPropWithArity)).to.equal(2);
      });


      it('callPropWithArity is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.callPropWithArity)).to.equal(true);
      });
    });


    describe('chr', function() {
      it('chr exists', function() {
        expect(funkier).to.have.a.property('chr');
      });


      it('funkierJS\'s chr is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.chr).to.equal(module.chr);
      });


      it('chr is a function', function() {
        expect(funkier.chr).to.be.a('function');
      });


      it('chr has documented arity', function() {
        expect(funkier.arityOf(funkier.chr)).to.equal(1);
      });


      it('chr is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.chr)).to.equal(true);
      });
    });


    describe('clone', function() {
      it('clone exists', function() {
        expect(funkier).to.have.a.property('clone');
      });


      it('funkierJS\'s clone is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.clone).to.equal(module.clone);
      });


      it('clone is a function', function() {
        expect(funkier.clone).to.be.a('function');
      });


      it('clone has documented arity', function() {
        expect(funkier.arityOf(funkier.clone)).to.equal(1);
      });


      it('clone is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.clone)).to.equal(true);
      });
    });


    describe('compose', function() {
      it('compose exists', function() {
        expect(funkier).to.have.a.property('compose');
      });


      it('funkierJS\'s compose is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.compose).to.equal(module.compose);
      });


      it('compose is a function', function() {
        expect(funkier.compose).to.be.a('function');
      });


      it('compose has documented arity', function() {
        expect(funkier.arityOf(funkier.compose)).to.equal(2);
      });


      it('compose is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.compose)).to.equal(true);
      });
    });


    describe('composeMany', function() {
      it('composeMany exists', function() {
        expect(funkier).to.have.a.property('composeMany');
      });


      it('funkierJS\'s composeMany is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.composeMany).to.equal(module.composeMany);
      });


      it('composeMany is a function', function() {
        expect(funkier.composeMany).to.be.a('function');
      });


      it('composeMany has documented arity', function() {
        expect(funkier.arityOf(funkier.composeMany)).to.equal(1);
      });


      it('composeMany is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.composeMany)).to.equal(true);
      });
    });


    describe('composeOn', function() {
      it('composeOn exists', function() {
        expect(funkier).to.have.a.property('composeOn');
      });


      it('funkierJS\'s composeOn is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.composeOn).to.equal(module.composeOn);
      });


      it('composeOn is a function', function() {
        expect(funkier.composeOn).to.be.a('function');
      });


      it('composeOn has documented arity', function() {
        expect(funkier.arityOf(funkier.composeOn)).to.equal(3);
      });


      it('composeOn is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.composeOn)).to.equal(true);
      });
    });


    describe('concat', function() {
      it('concat exists', function() {
        expect(funkier).to.have.a.property('concat');
      });


      it('funkierJS\'s concat is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.concat).to.equal(module.concat);
      });


      it('concat is a function', function() {
        expect(funkier.concat).to.be.a('function');
      });


      it('concat has documented arity', function() {
        expect(funkier.arityOf(funkier.concat)).to.equal(2);
      });


      it('concat is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.concat)).to.equal(true);
      });
    });


    describe('constant', function() {
      it('constant exists', function() {
        expect(funkier).to.have.a.property('constant');
      });


      it('funkierJS\'s constant is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.constant).to.equal(module.constant);
      });


      it('constant is a function', function() {
        expect(funkier.constant).to.be.a('function');
      });


      it('constant has documented arity', function() {
        expect(funkier.arityOf(funkier.constant)).to.equal(2);
      });


      it('constant is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.constant)).to.equal(true);
      });
    });


    describe('constant0', function() {
      it('constant0 exists', function() {
        expect(funkier).to.have.a.property('constant0');
      });


      it('funkierJS\'s constant0 is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.constant0).to.equal(module.constant0);
      });


      it('constant0 is a function', function() {
        expect(funkier.constant0).to.be.a('function');
      });


      it('constant0 has documented arity', function() {
        expect(funkier.arityOf(funkier.constant0)).to.equal(1);
      });


      it('constant0 is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.constant0)).to.equal(true);
      });
    });


    describe('copy', function() {
      it('copy exists', function() {
        expect(funkier).to.have.a.property('copy');
      });


      it('funkierJS\'s copy is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.copy).to.equal(module.copy);
      });


      it('copy is a function', function() {
        expect(funkier.copy).to.be.a('function');
      });


      it('copy has documented arity', function() {
        expect(funkier.arityOf(funkier.copy)).to.equal(1);
      });


      it('copy is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.copy)).to.equal(true);
      });
    });


    describe('createObject', function() {
      it('createObject exists', function() {
        expect(funkier).to.have.a.property('createObject');
      });


      it('funkierJS\'s createObject is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.createObject).to.equal(module.createObject);
      });


      it('createObject is a function', function() {
        expect(funkier.createObject).to.be.a('function');
      });


      it('createObject has documented arity', function() {
        expect(funkier.arityOf(funkier.createObject)).to.equal(1);
      });


      it('createObject is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.createObject)).to.equal(true);
      });
    });


    describe('createObjectWithProps', function() {
      it('createObjectWithProps exists', function() {
        expect(funkier).to.have.a.property('createObjectWithProps');
      });


      it('funkierJS\'s createObjectWithProps is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.createObjectWithProps).to.equal(module.createObjectWithProps);
      });


      it('createObjectWithProps is a function', function() {
        expect(funkier.createObjectWithProps).to.be.a('function');
      });


      it('createObjectWithProps has documented arity', function() {
        expect(funkier.arityOf(funkier.createObjectWithProps)).to.equal(2);
      });


      it('createObjectWithProps is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.createObjectWithProps)).to.equal(true);
      });
    });


    describe('createProp', function() {
      it('createProp exists', function() {
        expect(funkier).to.have.a.property('createProp');
      });


      it('funkierJS\'s createProp is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.createProp).to.equal(module.createProp);
      });


      it('createProp is a function', function() {
        expect(funkier.createProp).to.be.a('function');
      });


      it('createProp has documented arity', function() {
        expect(funkier.arityOf(funkier.createProp)).to.equal(3);
      });


      it('createProp is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.createProp)).to.equal(true);
      });
    });


    describe('curry', function() {
      it('curry exists', function() {
        expect(funkier).to.have.a.property('curry');
      });


      it('funkierJS\'s curry is indeed the documented value', function() {
        var module = require('../../lib/components/curry');
        expect(funkier.curry).to.equal(module.curry);
      });


      it('curry is a function', function() {
        expect(funkier.curry).to.be.a('function');
      });


      it('curry has documented arity', function() {
        expect(funkier.arityOf(funkier.curry)).to.equal(1);
      });


      it('curry is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.curry)).to.equal(true);
      });
    });


    describe('curryOwn', function() {
      it('curryOwn exists', function() {
        expect(funkier).to.have.a.property('curryOwn');
      });


      it('funkierJS\'s curryOwn is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.curryOwn).to.equal(module.curryOwn);
      });


      it('curryOwn is a function', function() {
        expect(funkier.curryOwn).to.be.a('function');
      });


      it('curryOwn has documented arity', function() {
        expect(funkier.arityOf(funkier.curryOwn)).to.equal(1);
      });


      it('curryOwn is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.curryOwn)).to.equal(true);
      });
    });


    describe('curryWithArity', function() {
      it('curryWithArity exists', function() {
        expect(funkier).to.have.a.property('curryWithArity');
      });


      it('funkierJS\'s curryWithArity is indeed the documented value', function() {
        var module = require('../../lib/components/curry');
        expect(funkier.curryWithArity).to.equal(module.curryWithArity);
      });


      it('curryWithArity is a function', function() {
        expect(funkier.curryWithArity).to.be.a('function');
      });


      it('curryWithArity has documented arity', function() {
        expect(funkier.arityOf(funkier.curryWithArity)).to.equal(2);
      });


      it('curryWithArity is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.curryWithArity)).to.equal(true);
      });
    });


    describe('deepEqual', function() {
      it('deepEqual exists', function() {
        expect(funkier).to.have.a.property('deepEqual');
      });


      it('funkierJS\'s deepEqual is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.deepEqual).to.equal(module.deepEqual);
      });


      it('deepEqual is a function', function() {
        expect(funkier.deepEqual).to.be.a('function');
      });


      it('deepEqual has documented arity', function() {
        expect(funkier.arityOf(funkier.deepEqual)).to.equal(2);
      });


      it('deepEqual is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.deepEqual)).to.equal(true);
      });
    });


    describe('deepEquals', function() {
      it('deepEquals exists', function() {
        expect(funkier).to.have.a.property('deepEquals');
      });


      it('deepEquals is a synonym for deepEqual', function() {
        expect(funkier.deepEquals).to.equal(funkier.deepEqual);
      });
    });


    describe('defaultTap', function() {
      it('defaultTap exists', function() {
        expect(funkier).to.have.a.property('defaultTap');
      });


      it('defaultTap is a synonym for extractOrDefault', function() {
        expect(funkier.defaultTap).to.equal(funkier.extractOrDefault);
      });
    });


    describe('defineProperties', function() {
      it('defineProperties exists', function() {
        expect(funkier).to.have.a.property('defineProperties');
      });


      it('funkierJS\'s defineProperties is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.defineProperties).to.equal(module.defineProperties);
      });


      it('defineProperties is a function', function() {
        expect(funkier.defineProperties).to.be.a('function');
      });


      it('defineProperties has documented arity', function() {
        expect(funkier.arityOf(funkier.defineProperties)).to.equal(2);
      });


      it('defineProperties is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.defineProperties)).to.equal(true);
      });
    });


    describe('defineProperty', function() {
      it('defineProperty exists', function() {
        expect(funkier).to.have.a.property('defineProperty');
      });


      it('funkierJS\'s defineProperty is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.defineProperty).to.equal(module.defineProperty);
      });


      it('defineProperty is a function', function() {
        expect(funkier.defineProperty).to.be.a('function');
      });


      it('defineProperty has documented arity', function() {
        expect(funkier.arityOf(funkier.defineProperty)).to.equal(3);
      });


      it('defineProperty is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.defineProperty)).to.equal(true);
      });
    });


    describe('deleteProp', function() {
      it('deleteProp exists', function() {
        expect(funkier).to.have.a.property('deleteProp');
      });


      it('funkierJS\'s deleteProp is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.deleteProp).to.equal(module.deleteProp);
      });


      it('deleteProp is a function', function() {
        expect(funkier.deleteProp).to.be.a('function');
      });


      it('deleteProp has documented arity', function() {
        expect(funkier.arityOf(funkier.deleteProp)).to.equal(2);
      });


      it('deleteProp is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.deleteProp)).to.equal(true);
      });
    });


    describe('descriptors', function() {
      it('descriptors exists', function() {
        expect(funkier).to.have.a.property('descriptors');
      });


      it('funkierJS\'s descriptors is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.descriptors).to.equal(module.descriptors);
      });


      it('descriptors is a function', function() {
        expect(funkier.descriptors).to.be.a('function');
      });


      it('descriptors has documented arity', function() {
        expect(funkier.arityOf(funkier.descriptors)).to.equal(1);
      });


      it('descriptors is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.descriptors)).to.equal(true);
      });
    });


    describe('div', function() {
      it('div exists', function() {
        expect(funkier).to.have.a.property('div');
      });


      it('funkierJS\'s div is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.div).to.equal(module.div);
      });


      it('div is a function', function() {
        expect(funkier.div).to.be.a('function');
      });


      it('div has documented arity', function() {
        expect(funkier.arityOf(funkier.div)).to.equal(2);
      });


      it('div is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.div)).to.equal(true);
      });
    });


    describe('divide', function() {
      it('divide exists', function() {
        expect(funkier).to.have.a.property('divide');
      });


      it('funkierJS\'s divide is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.divide).to.equal(module.divide);
      });


      it('divide is a function', function() {
        expect(funkier.divide).to.be.a('function');
      });


      it('divide has documented arity', function() {
        expect(funkier.arityOf(funkier.divide)).to.equal(2);
      });


      it('divide is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.divide)).to.equal(true);
      });
    });


    describe('drop', function() {
      it('drop exists', function() {
        expect(funkier).to.have.a.property('drop');
      });


      it('funkierJS\'s drop is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.drop).to.equal(module.drop);
      });


      it('drop is a function', function() {
        expect(funkier.drop).to.be.a('function');
      });


      it('drop has documented arity', function() {
        expect(funkier.arityOf(funkier.drop)).to.equal(2);
      });


      it('drop is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.drop)).to.equal(true);
      });
    });


    describe('dropWhile', function() {
      it('dropWhile exists', function() {
        expect(funkier).to.have.a.property('dropWhile');
      });


      it('funkierJS\'s dropWhile is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.dropWhile).to.equal(module.dropWhile);
      });


      it('dropWhile is a function', function() {
        expect(funkier.dropWhile).to.be.a('function');
      });


      it('dropWhile has documented arity', function() {
        expect(funkier.arityOf(funkier.dropWhile)).to.equal(2);
      });


      it('dropWhile is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.dropWhile)).to.equal(true);
      });
    });


    describe('each', function() {
      it('each exists', function() {
        expect(funkier).to.have.a.property('each');
      });


      it('funkierJS\'s each is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.each).to.equal(module.each);
      });


      it('each is a function', function() {
        expect(funkier.each).to.be.a('function');
      });


      it('each has documented arity', function() {
        expect(funkier.arityOf(funkier.each)).to.equal(2);
      });


      it('each is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.each)).to.equal(true);
      });
    });


    describe('either', function() {
      it('either exists', function() {
        expect(funkier).to.have.a.property('either');
      });


      it('funkierJS\'s either is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.either).to.equal(module.either);
      });


      it('either is a function', function() {
        expect(funkier.either).to.be.a('function');
      });


      it('either has documented arity', function() {
        expect(funkier.arityOf(funkier.either)).to.equal(3);
      });


      it('either is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.either)).to.equal(true);
      });
    });


    describe('element', function() {
      it('element exists', function() {
        expect(funkier).to.have.a.property('element');
      });


      it('funkierJS\'s element is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.element).to.equal(module.element);
      });


      it('element is a function', function() {
        expect(funkier.element).to.be.a('function');
      });


      it('element has documented arity', function() {
        expect(funkier.arityOf(funkier.element)).to.equal(2);
      });


      it('element is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.element)).to.equal(true);
      });
    });


    describe('elementWith', function() {
      it('elementWith exists', function() {
        expect(funkier).to.have.a.property('elementWith');
      });


      it('funkierJS\'s elementWith is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.elementWith).to.equal(module.elementWith);
      });


      it('elementWith is a function', function() {
        expect(funkier.elementWith).to.be.a('function');
      });


      it('elementWith has documented arity', function() {
        expect(funkier.arityOf(funkier.elementWith)).to.equal(2);
      });


      it('elementWith is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.elementWith)).to.equal(true);
      });
    });


    describe('equals', function() {
      it('equals exists', function() {
        expect(funkier).to.have.a.property('equals');
      });


      it('funkierJS\'s equals is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.equals).to.equal(module.equals);
      });


      it('equals is a function', function() {
        expect(funkier.equals).to.be.a('function');
      });


      it('equals has documented arity', function() {
        expect(funkier.arityOf(funkier.equals)).to.equal(2);
      });


      it('equals is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.equals)).to.equal(true);
      });
    });


    describe('even', function() {
      it('even exists', function() {
        expect(funkier).to.have.a.property('even');
      });


      it('funkierJS\'s even is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.even).to.equal(module.even);
      });


      it('even is a function', function() {
        expect(funkier.even).to.be.a('function');
      });


      it('even has documented arity', function() {
        expect(funkier.arityOf(funkier.even)).to.equal(1);
      });


      it('even is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.even)).to.equal(true);
      });
    });


    describe('every', function() {
      it('every exists', function() {
        expect(funkier).to.have.a.property('every');
      });


      it('funkierJS\'s every is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.every).to.equal(module.every);
      });


      it('every is a function', function() {
        expect(funkier.every).to.be.a('function');
      });


      it('every has documented arity', function() {
        expect(funkier.arityOf(funkier.every)).to.equal(2);
      });


      it('every is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.every)).to.equal(true);
      });
    });


    describe('exp', function() {
      it('exp exists', function() {
        expect(funkier).to.have.a.property('exp');
      });


      it('funkierJS\'s exp is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.exp).to.equal(module.exp);
      });


      it('exp is a function', function() {
        expect(funkier.exp).to.be.a('function');
      });


      it('exp has documented arity', function() {
        expect(funkier.arityOf(funkier.exp)).to.equal(2);
      });


      it('exp is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.exp)).to.equal(true);
      });
    });


    describe('extend', function() {
      it('extend exists', function() {
        expect(funkier).to.have.a.property('extend');
      });


      it('funkierJS\'s extend is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.extend).to.equal(module.extend);
      });


      it('extend is a function', function() {
        expect(funkier.extend).to.be.a('function');
      });


      it('extend has documented arity', function() {
        expect(funkier.arityOf(funkier.extend)).to.equal(2);
      });


      it('extend is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.extend)).to.equal(true);
      });
    });


    describe('extendOwn', function() {
      it('extendOwn exists', function() {
        expect(funkier).to.have.a.property('extendOwn');
      });


      it('funkierJS\'s extendOwn is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.extendOwn).to.equal(module.extendOwn);
      });


      it('extendOwn is a function', function() {
        expect(funkier.extendOwn).to.be.a('function');
      });


      it('extendOwn has documented arity', function() {
        expect(funkier.arityOf(funkier.extendOwn)).to.equal(2);
      });


      it('extendOwn is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.extendOwn)).to.equal(true);
      });
    });


    describe('extract', function() {
      it('extract exists', function() {
        expect(funkier).to.have.a.property('extract');
      });


      it('funkierJS\'s extract is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.extract).to.equal(module.extract);
      });


      it('extract is a function', function() {
        expect(funkier.extract).to.be.a('function');
      });


      it('extract has documented arity', function() {
        expect(funkier.arityOf(funkier.extract)).to.equal(2);
      });


      it('extract is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.extract)).to.equal(true);
      });
    });


    describe('extractOrDefault', function() {
      it('extractOrDefault exists', function() {
        expect(funkier).to.have.a.property('extractOrDefault');
      });


      it('funkierJS\'s extractOrDefault is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.extractOrDefault).to.equal(module.extractOrDefault);
      });


      it('extractOrDefault is a function', function() {
        expect(funkier.extractOrDefault).to.be.a('function');
      });


      it('extractOrDefault has documented arity', function() {
        expect(funkier.arityOf(funkier.extractOrDefault)).to.equal(3);
      });


      it('extractOrDefault is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.extractOrDefault)).to.equal(true);
      });
    });


    describe('fMap', function() {
      it('fMap exists', function() {
        expect(funkier).to.have.a.property('fMap');
      });


      it('fMap is a synonym for fmap', function() {
        expect(funkier.fMap).to.equal(funkier.fmap);
      });
    });


    describe('filter', function() {
      it('filter exists', function() {
        expect(funkier).to.have.a.property('filter');
      });


      it('funkierJS\'s filter is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.filter).to.equal(module.filter);
      });


      it('filter is a function', function() {
        expect(funkier.filter).to.be.a('function');
      });


      it('filter has documented arity', function() {
        expect(funkier.arityOf(funkier.filter)).to.equal(2);
      });


      it('filter is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.filter)).to.equal(true);
      });
    });


    describe('first', function() {
      it('first exists', function() {
        expect(funkier).to.have.a.property('first');
      });


      it('first is a synonym for fst', function() {
        expect(funkier.first).to.equal(funkier.fst);
      });
    });


    describe('firstMatch', function() {
      it('firstMatch exists', function() {
        expect(funkier).to.have.a.property('firstMatch');
      });


      it('funkierJS\'s firstMatch is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.firstMatch).to.equal(module.firstMatch);
      });


      it('firstMatch is a function', function() {
        expect(funkier.firstMatch).to.be.a('function');
      });


      it('firstMatch has documented arity', function() {
        expect(funkier.arityOf(funkier.firstMatch)).to.equal(2);
      });


      it('firstMatch is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.firstMatch)).to.equal(true);
      });
    });


    describe('firstMatchFrom', function() {
      it('firstMatchFrom exists', function() {
        expect(funkier).to.have.a.property('firstMatchFrom');
      });


      it('funkierJS\'s firstMatchFrom is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.firstMatchFrom).to.equal(module.firstMatchFrom);
      });


      it('firstMatchFrom is a function', function() {
        expect(funkier.firstMatchFrom).to.be.a('function');
      });


      it('firstMatchFrom has documented arity', function() {
        expect(funkier.arityOf(funkier.firstMatchFrom)).to.equal(3);
      });


      it('firstMatchFrom is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.firstMatchFrom)).to.equal(true);
      });
    });


    describe('flatten', function() {
      it('flatten exists', function() {
        expect(funkier).to.have.a.property('flatten');
      });


      it('funkierJS\'s flatten is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.flatten).to.equal(module.flatten);
      });


      it('flatten is a function', function() {
        expect(funkier.flatten).to.be.a('function');
      });


      it('flatten has documented arity', function() {
        expect(funkier.arityOf(funkier.flatten)).to.equal(1);
      });


      it('flatten is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.flatten)).to.equal(true);
      });
    });


    describe('flattenMap', function() {
      it('flattenMap exists', function() {
        expect(funkier).to.have.a.property('flattenMap');
      });


      it('funkierJS\'s flattenMap is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.flattenMap).to.equal(module.flattenMap);
      });


      it('flattenMap is a function', function() {
        expect(funkier.flattenMap).to.be.a('function');
      });


      it('flattenMap has documented arity', function() {
        expect(funkier.arityOf(funkier.flattenMap)).to.equal(2);
      });


      it('flattenMap is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.flattenMap)).to.equal(true);
      });
    });


    describe('flip', function() {
      it('flip exists', function() {
        expect(funkier).to.have.a.property('flip');
      });


      it('funkierJS\'s flip is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.flip).to.equal(module.flip);
      });


      it('flip is a function', function() {
        expect(funkier.flip).to.be.a('function');
      });


      it('flip has documented arity', function() {
        expect(funkier.arityOf(funkier.flip)).to.equal(1);
      });


      it('flip is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.flip)).to.equal(true);
      });
    });


    describe('fmap', function() {
      it('fmap exists', function() {
        expect(funkier).to.have.a.property('fmap');
      });


      it('funkierJS\'s fmap is indeed the documented value', function() {
        var module = require('../../lib/components/categories');
        expect(funkier.fmap).to.equal(module.fmap);
      });


      it('fmap is a function', function() {
        expect(funkier.fmap).to.be.a('function');
      });


      it('fmap has documented arity', function() {
        expect(funkier.arityOf(funkier.fmap)).to.equal(2);
      });


      it('fmap is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.fmap)).to.equal(true);
      });
    });


    describe('foldl', function() {
      it('foldl exists', function() {
        expect(funkier).to.have.a.property('foldl');
      });


      it('funkierJS\'s foldl is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.foldl).to.equal(module.foldl);
      });


      it('foldl is a function', function() {
        expect(funkier.foldl).to.be.a('function');
      });


      it('foldl has documented arity', function() {
        expect(funkier.arityOf(funkier.foldl)).to.equal(3);
      });


      it('foldl is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.foldl)).to.equal(true);
      });
    });


    describe('foldl1', function() {
      it('foldl1 exists', function() {
        expect(funkier).to.have.a.property('foldl1');
      });


      it('funkierJS\'s foldl1 is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.foldl1).to.equal(module.foldl1);
      });


      it('foldl1 is a function', function() {
        expect(funkier.foldl1).to.be.a('function');
      });


      it('foldl1 has documented arity', function() {
        expect(funkier.arityOf(funkier.foldl1)).to.equal(2);
      });


      it('foldl1 is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.foldl1)).to.equal(true);
      });
    });


    describe('foldr', function() {
      it('foldr exists', function() {
        expect(funkier).to.have.a.property('foldr');
      });


      it('funkierJS\'s foldr is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.foldr).to.equal(module.foldr);
      });


      it('foldr is a function', function() {
        expect(funkier.foldr).to.be.a('function');
      });


      it('foldr has documented arity', function() {
        expect(funkier.arityOf(funkier.foldr)).to.equal(3);
      });


      it('foldr is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.foldr)).to.equal(true);
      });
    });


    describe('foldr1', function() {
      it('foldr1 exists', function() {
        expect(funkier).to.have.a.property('foldr1');
      });


      it('funkierJS\'s foldr1 is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.foldr1).to.equal(module.foldr1);
      });


      it('foldr1 is a function', function() {
        expect(funkier.foldr1).to.be.a('function');
      });


      it('foldr1 has documented arity', function() {
        expect(funkier.arityOf(funkier.foldr1)).to.equal(2);
      });


      it('foldr1 is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.foldr1)).to.equal(true);
      });
    });


    describe('fst', function() {
      it('fst exists', function() {
        expect(funkier).to.have.a.property('fst');
      });


      it('funkierJS\'s fst is indeed the documented value', function() {
        var module = require('../../lib/components/pair');
        expect(funkier.fst).to.equal(module.fst);
      });


      it('fst is a function', function() {
        expect(funkier.fst).to.be.a('function');
      });


      it('fst has documented arity', function() {
        expect(funkier.arityOf(funkier.fst)).to.equal(1);
      });


      it('fst is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.fst)).to.equal(true);
      });
    });


    describe('getCurrentTimeString', function() {
      it('getCurrentTimeString exists', function() {
        expect(funkier).to.have.a.property('getCurrentTimeString');
      });


      it('funkierJS\'s getCurrentTimeString is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getCurrentTimeString).to.equal(module.getCurrentTimeString);
      });


      it('getCurrentTimeString is a function', function() {
        expect(funkier.getCurrentTimeString).to.be.a('function');
      });


      it('getCurrentTimeString has documented arity', function() {
        expect(funkier.arityOf(funkier.getCurrentTimeString)).to.equal(0);
      });


      it('getCurrentTimeString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getCurrentTimeString)).to.equal(true);
      });
    });


    describe('getDayOfMonth', function() {
      it('getDayOfMonth exists', function() {
        expect(funkier).to.have.a.property('getDayOfMonth');
      });


      it('funkierJS\'s getDayOfMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getDayOfMonth).to.equal(module.getDayOfMonth);
      });


      it('getDayOfMonth is a function', function() {
        expect(funkier.getDayOfMonth).to.be.a('function');
      });


      it('getDayOfMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.getDayOfMonth)).to.equal(1);
      });


      it('getDayOfMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getDayOfMonth)).to.equal(true);
      });
    });


    describe('getDayOfWeek', function() {
      it('getDayOfWeek exists', function() {
        expect(funkier).to.have.a.property('getDayOfWeek');
      });


      it('funkierJS\'s getDayOfWeek is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getDayOfWeek).to.equal(module.getDayOfWeek);
      });


      it('getDayOfWeek is a function', function() {
        expect(funkier.getDayOfWeek).to.be.a('function');
      });


      it('getDayOfWeek has documented arity', function() {
        expect(funkier.arityOf(funkier.getDayOfWeek)).to.equal(1);
      });


      it('getDayOfWeek is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getDayOfWeek)).to.equal(true);
      });
    });


    describe('getErrValue', function() {
      it('getErrValue exists', function() {
        expect(funkier).to.have.a.property('getErrValue');
      });


      it('funkierJS\'s getErrValue is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.getErrValue).to.equal(module.getErrValue);
      });


      it('getErrValue is a function', function() {
        expect(funkier.getErrValue).to.be.a('function');
      });


      it('getErrValue has documented arity', function() {
        expect(funkier.arityOf(funkier.getErrValue)).to.equal(1);
      });


      it('getErrValue is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getErrValue)).to.equal(true);
      });
    });


    describe('getFullYear', function() {
      it('getFullYear exists', function() {
        expect(funkier).to.have.a.property('getFullYear');
      });


      it('funkierJS\'s getFullYear is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getFullYear).to.equal(module.getFullYear);
      });


      it('getFullYear is a function', function() {
        expect(funkier.getFullYear).to.be.a('function');
      });


      it('getFullYear has documented arity', function() {
        expect(funkier.arityOf(funkier.getFullYear)).to.equal(1);
      });


      it('getFullYear is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getFullYear)).to.equal(true);
      });
    });


    describe('getHours', function() {
      it('getHours exists', function() {
        expect(funkier).to.have.a.property('getHours');
      });


      it('funkierJS\'s getHours is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getHours).to.equal(module.getHours);
      });


      it('getHours is a function', function() {
        expect(funkier.getHours).to.be.a('function');
      });


      it('getHours has documented arity', function() {
        expect(funkier.arityOf(funkier.getHours)).to.equal(1);
      });


      it('getHours is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getHours)).to.equal(true);
      });
    });


    describe('getIndex', function() {
      it('getIndex exists', function() {
        expect(funkier).to.have.a.property('getIndex');
      });


      it('funkierJS\'s getIndex is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.getIndex).to.equal(module.getIndex);
      });


      it('getIndex is a function', function() {
        expect(funkier.getIndex).to.be.a('function');
      });


      it('getIndex has documented arity', function() {
        expect(funkier.arityOf(funkier.getIndex)).to.equal(2);
      });


      it('getIndex is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getIndex)).to.equal(true);
      });
    });


    describe('getJustValue', function() {
      it('getJustValue exists', function() {
        expect(funkier).to.have.a.property('getJustValue');
      });


      it('funkierJS\'s getJustValue is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.getJustValue).to.equal(module.getJustValue);
      });


      it('getJustValue is a function', function() {
        expect(funkier.getJustValue).to.be.a('function');
      });


      it('getJustValue has documented arity', function() {
        expect(funkier.arityOf(funkier.getJustValue)).to.equal(1);
      });


      it('getJustValue is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getJustValue)).to.equal(true);
      });
    });


    describe('getMilliseconds', function() {
      it('getMilliseconds exists', function() {
        expect(funkier).to.have.a.property('getMilliseconds');
      });


      it('funkierJS\'s getMilliseconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getMilliseconds).to.equal(module.getMilliseconds);
      });


      it('getMilliseconds is a function', function() {
        expect(funkier.getMilliseconds).to.be.a('function');
      });


      it('getMilliseconds has documented arity', function() {
        expect(funkier.arityOf(funkier.getMilliseconds)).to.equal(1);
      });


      it('getMilliseconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getMilliseconds)).to.equal(true);
      });
    });


    describe('getMinutes', function() {
      it('getMinutes exists', function() {
        expect(funkier).to.have.a.property('getMinutes');
      });


      it('funkierJS\'s getMinutes is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getMinutes).to.equal(module.getMinutes);
      });


      it('getMinutes is a function', function() {
        expect(funkier.getMinutes).to.be.a('function');
      });


      it('getMinutes has documented arity', function() {
        expect(funkier.arityOf(funkier.getMinutes)).to.equal(1);
      });


      it('getMinutes is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getMinutes)).to.equal(true);
      });
    });


    describe('getMonth', function() {
      it('getMonth exists', function() {
        expect(funkier).to.have.a.property('getMonth');
      });


      it('funkierJS\'s getMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getMonth).to.equal(module.getMonth);
      });


      it('getMonth is a function', function() {
        expect(funkier.getMonth).to.be.a('function');
      });


      it('getMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.getMonth)).to.equal(1);
      });


      it('getMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getMonth)).to.equal(true);
      });
    });


    describe('getOkValue', function() {
      it('getOkValue exists', function() {
        expect(funkier).to.have.a.property('getOkValue');
      });


      it('funkierJS\'s getOkValue is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.getOkValue).to.equal(module.getOkValue);
      });


      it('getOkValue is a function', function() {
        expect(funkier.getOkValue).to.be.a('function');
      });


      it('getOkValue has documented arity', function() {
        expect(funkier.arityOf(funkier.getOkValue)).to.equal(1);
      });


      it('getOkValue is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getOkValue)).to.equal(true);
      });
    });


    describe('getOwnPropertyDescriptor', function() {
      it('getOwnPropertyDescriptor exists', function() {
        expect(funkier).to.have.a.property('getOwnPropertyDescriptor');
      });


      it('funkierJS\'s getOwnPropertyDescriptor is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.getOwnPropertyDescriptor).to.equal(module.getOwnPropertyDescriptor);
      });


      it('getOwnPropertyDescriptor is a function', function() {
        expect(funkier.getOwnPropertyDescriptor).to.be.a('function');
      });


      it('getOwnPropertyDescriptor has documented arity', function() {
        expect(funkier.arityOf(funkier.getOwnPropertyDescriptor)).to.equal(2);
      });


      it('getOwnPropertyDescriptor is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getOwnPropertyDescriptor)).to.equal(true);
      });
    });


    describe('getOwnPropertyNames', function() {
      it('getOwnPropertyNames exists', function() {
        expect(funkier).to.have.a.property('getOwnPropertyNames');
      });


      it('funkierJS\'s getOwnPropertyNames is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.getOwnPropertyNames).to.equal(module.getOwnPropertyNames);
      });


      it('getOwnPropertyNames is a function', function() {
        expect(funkier.getOwnPropertyNames).to.be.a('function');
      });


      it('getOwnPropertyNames has documented arity', function() {
        expect(funkier.arityOf(funkier.getOwnPropertyNames)).to.equal(1);
      });


      it('getOwnPropertyNames is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getOwnPropertyNames)).to.equal(true);
      });
    });


    describe('getSeconds', function() {
      it('getSeconds exists', function() {
        expect(funkier).to.have.a.property('getSeconds');
      });


      it('funkierJS\'s getSeconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getSeconds).to.equal(module.getSeconds);
      });


      it('getSeconds is a function', function() {
        expect(funkier.getSeconds).to.be.a('function');
      });


      it('getSeconds has documented arity', function() {
        expect(funkier.arityOf(funkier.getSeconds)).to.equal(1);
      });


      it('getSeconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getSeconds)).to.equal(true);
      });
    });


    describe('getTimezoneOffset', function() {
      it('getTimezoneOffset exists', function() {
        expect(funkier).to.have.a.property('getTimezoneOffset');
      });


      it('funkierJS\'s getTimezoneOffset is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getTimezoneOffset).to.equal(module.getTimezoneOffset);
      });


      it('getTimezoneOffset is a function', function() {
        expect(funkier.getTimezoneOffset).to.be.a('function');
      });


      it('getTimezoneOffset has documented arity', function() {
        expect(funkier.arityOf(funkier.getTimezoneOffset)).to.equal(1);
      });


      it('getTimezoneOffset is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getTimezoneOffset)).to.equal(true);
      });
    });


    describe('getType', function() {
      it('getType exists', function() {
        expect(funkier).to.have.a.property('getType');
      });


      it('funkierJS\'s getType is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.getType).to.equal(module.getType);
      });


      it('getType is a function', function() {
        expect(funkier.getType).to.be.a('function');
      });


      it('getType has documented arity', function() {
        expect(funkier.arityOf(funkier.getType)).to.equal(1);
      });


      it('getType is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getType)).to.equal(true);
      });
    });


    describe('getUTCDayOfMonth', function() {
      it('getUTCDayOfMonth exists', function() {
        expect(funkier).to.have.a.property('getUTCDayOfMonth');
      });


      it('funkierJS\'s getUTCDayOfMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCDayOfMonth).to.equal(module.getUTCDayOfMonth);
      });


      it('getUTCDayOfMonth is a function', function() {
        expect(funkier.getUTCDayOfMonth).to.be.a('function');
      });


      it('getUTCDayOfMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCDayOfMonth)).to.equal(1);
      });


      it('getUTCDayOfMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCDayOfMonth)).to.equal(true);
      });
    });


    describe('getUTCDayOfWeek', function() {
      it('getUTCDayOfWeek exists', function() {
        expect(funkier).to.have.a.property('getUTCDayOfWeek');
      });


      it('funkierJS\'s getUTCDayOfWeek is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCDayOfWeek).to.equal(module.getUTCDayOfWeek);
      });


      it('getUTCDayOfWeek is a function', function() {
        expect(funkier.getUTCDayOfWeek).to.be.a('function');
      });


      it('getUTCDayOfWeek has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCDayOfWeek)).to.equal(1);
      });


      it('getUTCDayOfWeek is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCDayOfWeek)).to.equal(true);
      });
    });


    describe('getUTCFullYear', function() {
      it('getUTCFullYear exists', function() {
        expect(funkier).to.have.a.property('getUTCFullYear');
      });


      it('funkierJS\'s getUTCFullYear is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCFullYear).to.equal(module.getUTCFullYear);
      });


      it('getUTCFullYear is a function', function() {
        expect(funkier.getUTCFullYear).to.be.a('function');
      });


      it('getUTCFullYear has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCFullYear)).to.equal(1);
      });


      it('getUTCFullYear is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCFullYear)).to.equal(true);
      });
    });


    describe('getUTCHours', function() {
      it('getUTCHours exists', function() {
        expect(funkier).to.have.a.property('getUTCHours');
      });


      it('funkierJS\'s getUTCHours is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCHours).to.equal(module.getUTCHours);
      });


      it('getUTCHours is a function', function() {
        expect(funkier.getUTCHours).to.be.a('function');
      });


      it('getUTCHours has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCHours)).to.equal(1);
      });


      it('getUTCHours is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCHours)).to.equal(true);
      });
    });


    describe('getUTCMilliseconds', function() {
      it('getUTCMilliseconds exists', function() {
        expect(funkier).to.have.a.property('getUTCMilliseconds');
      });


      it('funkierJS\'s getUTCMilliseconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCMilliseconds).to.equal(module.getUTCMilliseconds);
      });


      it('getUTCMilliseconds is a function', function() {
        expect(funkier.getUTCMilliseconds).to.be.a('function');
      });


      it('getUTCMilliseconds has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCMilliseconds)).to.equal(1);
      });


      it('getUTCMilliseconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCMilliseconds)).to.equal(true);
      });
    });


    describe('getUTCMinutes', function() {
      it('getUTCMinutes exists', function() {
        expect(funkier).to.have.a.property('getUTCMinutes');
      });


      it('funkierJS\'s getUTCMinutes is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCMinutes).to.equal(module.getUTCMinutes);
      });


      it('getUTCMinutes is a function', function() {
        expect(funkier.getUTCMinutes).to.be.a('function');
      });


      it('getUTCMinutes has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCMinutes)).to.equal(1);
      });


      it('getUTCMinutes is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCMinutes)).to.equal(true);
      });
    });


    describe('getUTCMonth', function() {
      it('getUTCMonth exists', function() {
        expect(funkier).to.have.a.property('getUTCMonth');
      });


      it('funkierJS\'s getUTCMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCMonth).to.equal(module.getUTCMonth);
      });


      it('getUTCMonth is a function', function() {
        expect(funkier.getUTCMonth).to.be.a('function');
      });


      it('getUTCMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCMonth)).to.equal(1);
      });


      it('getUTCMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCMonth)).to.equal(true);
      });
    });


    describe('getUTCSeconds', function() {
      it('getUTCSeconds exists', function() {
        expect(funkier).to.have.a.property('getUTCSeconds');
      });


      it('funkierJS\'s getUTCSeconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.getUTCSeconds).to.equal(module.getUTCSeconds);
      });


      it('getUTCSeconds is a function', function() {
        expect(funkier.getUTCSeconds).to.be.a('function');
      });


      it('getUTCSeconds has documented arity', function() {
        expect(funkier.arityOf(funkier.getUTCSeconds)).to.equal(1);
      });


      it('getUTCSeconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.getUTCSeconds)).to.equal(true);
      });
    });


    describe('greaterThan', function() {
      it('greaterThan exists', function() {
        expect(funkier).to.have.a.property('greaterThan');
      });


      it('funkierJS\'s greaterThan is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.greaterThan).to.equal(module.greaterThan);
      });


      it('greaterThan is a function', function() {
        expect(funkier.greaterThan).to.be.a('function');
      });


      it('greaterThan has documented arity', function() {
        expect(funkier.arityOf(funkier.greaterThan)).to.equal(2);
      });


      it('greaterThan is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.greaterThan)).to.equal(true);
      });
    });


    describe('greaterThanEqual', function() {
      it('greaterThanEqual exists', function() {
        expect(funkier).to.have.a.property('greaterThanEqual');
      });


      it('funkierJS\'s greaterThanEqual is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.greaterThanEqual).to.equal(module.greaterThanEqual);
      });


      it('greaterThanEqual is a function', function() {
        expect(funkier.greaterThanEqual).to.be.a('function');
      });


      it('greaterThanEqual has documented arity', function() {
        expect(funkier.arityOf(funkier.greaterThanEqual)).to.equal(2);
      });


      it('greaterThanEqual is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.greaterThanEqual)).to.equal(true);
      });
    });


    describe('gt', function() {
      it('gt exists', function() {
        expect(funkier).to.have.a.property('gt');
      });


      it('gt is a synonym for greaterThan', function() {
        expect(funkier.gt).to.equal(funkier.greaterThan);
      });
    });


    describe('gte', function() {
      it('gte exists', function() {
        expect(funkier).to.have.a.property('gte');
      });


      it('gte is a synonym for greaterThanEqual', function() {
        expect(funkier.gte).to.equal(funkier.greaterThanEqual);
      });
    });


    describe('hasOwnProperty', function() {
      it('hasOwnProperty exists', function() {
        expect(funkier).to.have.a.property('hasOwnProperty');
      });


      it('funkierJS\'s hasOwnProperty is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.hasOwnProperty).to.equal(module.hasOwnProperty);
      });


      it('hasOwnProperty is a function', function() {
        expect(funkier.hasOwnProperty).to.be.a('function');
      });


      it('hasOwnProperty has documented arity', function() {
        expect(funkier.arityOf(funkier.hasOwnProperty)).to.equal(2);
      });


      it('hasOwnProperty is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.hasOwnProperty)).to.equal(true);
      });
    });


    describe('hasProperty', function() {
      it('hasProperty exists', function() {
        expect(funkier).to.have.a.property('hasProperty');
      });


      it('funkierJS\'s hasProperty is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.hasProperty).to.equal(module.hasProperty);
      });


      it('hasProperty is a function', function() {
        expect(funkier.hasProperty).to.be.a('function');
      });


      it('hasProperty has documented arity', function() {
        expect(funkier.arityOf(funkier.hasProperty)).to.equal(2);
      });


      it('hasProperty is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.hasProperty)).to.equal(true);
      });
    });


    describe('hasType', function() {
      it('hasType exists', function() {
        expect(funkier).to.have.a.property('hasType');
      });


      it('hasType is a synonym for is', function() {
        expect(funkier.hasType).to.equal(funkier.is);
      });
    });


    describe('head', function() {
      it('head exists', function() {
        expect(funkier).to.have.a.property('head');
      });


      it('funkierJS\'s head is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.head).to.equal(module.head);
      });


      it('head is a function', function() {
        expect(funkier.head).to.be.a('function');
      });


      it('head has documented arity', function() {
        expect(funkier.arityOf(funkier.head)).to.equal(1);
      });


      it('head is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.head)).to.equal(true);
      });
    });


    describe('id', function() {
      it('id exists', function() {
        expect(funkier).to.have.a.property('id');
      });


      it('funkierJS\'s id is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.id).to.equal(module.id);
      });


      it('id is a function', function() {
        expect(funkier.id).to.be.a('function');
      });


      it('id has documented arity', function() {
        expect(funkier.arityOf(funkier.id)).to.equal(1);
      });


      it('id is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.id)).to.equal(true);
      });
    });


    describe('init', function() {
      it('init exists', function() {
        expect(funkier).to.have.a.property('init');
      });


      it('funkierJS\'s init is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.init).to.equal(module.init);
      });


      it('init is a function', function() {
        expect(funkier.init).to.be.a('function');
      });


      it('init has documented arity', function() {
        expect(funkier.arityOf(funkier.init)).to.equal(1);
      });


      it('init is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.init)).to.equal(true);
      });
    });


    describe('inits', function() {
      it('inits exists', function() {
        expect(funkier).to.have.a.property('inits');
      });


      it('funkierJS\'s inits is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.inits).to.equal(module.inits);
      });


      it('inits is a function', function() {
        expect(funkier.inits).to.be.a('function');
      });


      it('inits has documented arity', function() {
        expect(funkier.arityOf(funkier.inits)).to.equal(1);
      });


      it('inits is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.inits)).to.equal(true);
      });
    });


    describe('instanceOf', function() {
      it('instanceOf exists', function() {
        expect(funkier).to.have.a.property('instanceOf');
      });


      it('funkierJS\'s instanceOf is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.instanceOf).to.equal(module.instanceOf);
      });


      it('instanceOf is a function', function() {
        expect(funkier.instanceOf).to.be.a('function');
      });


      it('instanceOf has documented arity', function() {
        expect(funkier.arityOf(funkier.instanceOf)).to.equal(2);
      });


      it('instanceOf is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.instanceOf)).to.equal(true);
      });
    });


    describe('intersperse', function() {
      it('intersperse exists', function() {
        expect(funkier).to.have.a.property('intersperse');
      });


      it('funkierJS\'s intersperse is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.intersperse).to.equal(module.intersperse);
      });


      it('intersperse is a function', function() {
        expect(funkier.intersperse).to.be.a('function');
      });


      it('intersperse has documented arity', function() {
        expect(funkier.arityOf(funkier.intersperse)).to.equal(2);
      });


      it('intersperse is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.intersperse)).to.equal(true);
      });
    });


    describe('is', function() {
      it('is exists', function() {
        expect(funkier).to.have.a.property('is');
      });


      it('funkierJS\'s is is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.is).to.equal(module.is);
      });


      it('is is a function', function() {
        expect(funkier.is).to.be.a('function');
      });


      it('is has documented arity', function() {
        expect(funkier.arityOf(funkier.is)).to.equal(2);
      });


      it('is is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.is)).to.equal(true);
      });
    });


    describe('isArray', function() {
      it('isArray exists', function() {
        expect(funkier).to.have.a.property('isArray');
      });


      it('funkierJS\'s isArray is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isArray).to.equal(module.isArray);
      });


      it('isArray is a function', function() {
        expect(funkier.isArray).to.be.a('function');
      });


      it('isArray has documented arity', function() {
        expect(funkier.arityOf(funkier.isArray)).to.equal(1);
      });


      it('isArray is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isArray)).to.equal(true);
      });
    });


    describe('isBoolean', function() {
      it('isBoolean exists', function() {
        expect(funkier).to.have.a.property('isBoolean');
      });


      it('funkierJS\'s isBoolean is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isBoolean).to.equal(module.isBoolean);
      });


      it('isBoolean is a function', function() {
        expect(funkier.isBoolean).to.be.a('function');
      });


      it('isBoolean has documented arity', function() {
        expect(funkier.arityOf(funkier.isBoolean)).to.equal(1);
      });


      it('isBoolean is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isBoolean)).to.equal(true);
      });
    });


    describe('isEmpty', function() {
      it('isEmpty exists', function() {
        expect(funkier).to.have.a.property('isEmpty');
      });


      it('funkierJS\'s isEmpty is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.isEmpty).to.equal(module.isEmpty);
      });


      it('isEmpty is a function', function() {
        expect(funkier.isEmpty).to.be.a('function');
      });


      it('isEmpty has documented arity', function() {
        expect(funkier.arityOf(funkier.isEmpty)).to.equal(1);
      });


      it('isEmpty is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isEmpty)).to.equal(true);
      });
    });


    describe('isErr', function() {
      it('isErr exists', function() {
        expect(funkier).to.have.a.property('isErr');
      });


      it('funkierJS\'s isErr is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.isErr).to.equal(module.isErr);
      });


      it('isErr is a function', function() {
        expect(funkier.isErr).to.be.a('function');
      });


      it('isErr has documented arity', function() {
        expect(funkier.arityOf(funkier.isErr)).to.equal(1);
      });


      it('isErr is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isErr)).to.equal(true);
      });
    });


    describe('isJust', function() {
      it('isJust exists', function() {
        expect(funkier).to.have.a.property('isJust');
      });


      it('funkierJS\'s isJust is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.isJust).to.equal(module.isJust);
      });


      it('isJust is a function', function() {
        expect(funkier.isJust).to.be.a('function');
      });


      it('isJust has documented arity', function() {
        expect(funkier.arityOf(funkier.isJust)).to.equal(1);
      });


      it('isJust is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isJust)).to.equal(true);
      });
    });


    describe('isMaybe', function() {
      it('isMaybe exists', function() {
        expect(funkier).to.have.a.property('isMaybe');
      });


      it('funkierJS\'s isMaybe is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.isMaybe).to.equal(module.isMaybe);
      });


      it('isMaybe is a function', function() {
        expect(funkier.isMaybe).to.be.a('function');
      });


      it('isMaybe has documented arity', function() {
        expect(funkier.arityOf(funkier.isMaybe)).to.equal(1);
      });


      it('isMaybe is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isMaybe)).to.equal(true);
      });
    });


    describe('isNothing', function() {
      it('isNothing exists', function() {
        expect(funkier).to.have.a.property('isNothing');
      });


      it('funkierJS\'s isNothing is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.isNothing).to.equal(module.isNothing);
      });


      it('isNothing is a function', function() {
        expect(funkier.isNothing).to.be.a('function');
      });


      it('isNothing has documented arity', function() {
        expect(funkier.arityOf(funkier.isNothing)).to.equal(1);
      });


      it('isNothing is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isNothing)).to.equal(true);
      });
    });


    describe('isNull', function() {
      it('isNull exists', function() {
        expect(funkier).to.have.a.property('isNull');
      });


      it('funkierJS\'s isNull is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isNull).to.equal(module.isNull);
      });


      it('isNull is a function', function() {
        expect(funkier.isNull).to.be.a('function');
      });


      it('isNull has documented arity', function() {
        expect(funkier.arityOf(funkier.isNull)).to.equal(1);
      });


      it('isNull is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isNull)).to.equal(true);
      });
    });


    describe('isNumber', function() {
      it('isNumber exists', function() {
        expect(funkier).to.have.a.property('isNumber');
      });


      it('funkierJS\'s isNumber is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isNumber).to.equal(module.isNumber);
      });


      it('isNumber is a function', function() {
        expect(funkier.isNumber).to.be.a('function');
      });


      it('isNumber has documented arity', function() {
        expect(funkier.arityOf(funkier.isNumber)).to.equal(1);
      });


      it('isNumber is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isNumber)).to.equal(true);
      });
    });


    describe('isObject', function() {
      it('isObject exists', function() {
        expect(funkier).to.have.a.property('isObject');
      });


      it('funkierJS\'s isObject is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isObject).to.equal(module.isObject);
      });


      it('isObject is a function', function() {
        expect(funkier.isObject).to.be.a('function');
      });


      it('isObject has documented arity', function() {
        expect(funkier.arityOf(funkier.isObject)).to.equal(1);
      });


      it('isObject is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isObject)).to.equal(true);
      });
    });


    describe('isOk', function() {
      it('isOk exists', function() {
        expect(funkier).to.have.a.property('isOk');
      });


      it('funkierJS\'s isOk is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.isOk).to.equal(module.isOk);
      });


      it('isOk is a function', function() {
        expect(funkier.isOk).to.be.a('function');
      });


      it('isOk has documented arity', function() {
        expect(funkier.arityOf(funkier.isOk)).to.equal(1);
      });


      it('isOk is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isOk)).to.equal(true);
      });
    });


    describe('isPair', function() {
      it('isPair exists', function() {
        expect(funkier).to.have.a.property('isPair');
      });


      it('funkierJS\'s isPair is indeed the documented value', function() {
        var module = require('../../lib/components/pair');
        expect(funkier.isPair).to.equal(module.isPair);
      });


      it('isPair is a function', function() {
        expect(funkier.isPair).to.be.a('function');
      });


      it('isPair has documented arity', function() {
        expect(funkier.arityOf(funkier.isPair)).to.equal(1);
      });


      it('isPair is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isPair)).to.equal(true);
      });
    });


    describe('isPrototypeOf', function() {
      it('isPrototypeOf exists', function() {
        expect(funkier).to.have.a.property('isPrototypeOf');
      });


      it('funkierJS\'s isPrototypeOf is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.isPrototypeOf).to.equal(module.isPrototypeOf);
      });


      it('isPrototypeOf is a function', function() {
        expect(funkier.isPrototypeOf).to.be.a('function');
      });


      it('isPrototypeOf has documented arity', function() {
        expect(funkier.arityOf(funkier.isPrototypeOf)).to.equal(2);
      });


      it('isPrototypeOf is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isPrototypeOf)).to.equal(true);
      });
    });


    describe('isRealObject', function() {
      it('isRealObject exists', function() {
        expect(funkier).to.have.a.property('isRealObject');
      });


      it('funkierJS\'s isRealObject is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isRealObject).to.equal(module.isRealObject);
      });


      it('isRealObject is a function', function() {
        expect(funkier.isRealObject).to.be.a('function');
      });


      it('isRealObject has documented arity', function() {
        expect(funkier.arityOf(funkier.isRealObject)).to.equal(1);
      });


      it('isRealObject is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isRealObject)).to.equal(true);
      });
    });


    describe('isResult', function() {
      it('isResult exists', function() {
        expect(funkier).to.have.a.property('isResult');
      });


      it('funkierJS\'s isResult is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.isResult).to.equal(module.isResult);
      });


      it('isResult is a function', function() {
        expect(funkier.isResult).to.be.a('function');
      });


      it('isResult has documented arity', function() {
        expect(funkier.arityOf(funkier.isResult)).to.equal(1);
      });


      it('isResult is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isResult)).to.equal(true);
      });
    });


    describe('isString', function() {
      it('isString exists', function() {
        expect(funkier).to.have.a.property('isString');
      });


      it('funkierJS\'s isString is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isString).to.equal(module.isString);
      });


      it('isString is a function', function() {
        expect(funkier.isString).to.be.a('function');
      });


      it('isString has documented arity', function() {
        expect(funkier.arityOf(funkier.isString)).to.equal(1);
      });


      it('isString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isString)).to.equal(true);
      });
    });


    describe('isUndefined', function() {
      it('isUndefined exists', function() {
        expect(funkier).to.have.a.property('isUndefined');
      });


      it('funkierJS\'s isUndefined is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.isUndefined).to.equal(module.isUndefined);
      });


      it('isUndefined is a function', function() {
        expect(funkier.isUndefined).to.be.a('function');
      });


      it('isUndefined has documented arity', function() {
        expect(funkier.arityOf(funkier.isUndefined)).to.equal(1);
      });


      it('isUndefined is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.isUndefined)).to.equal(true);
      });
    });


    describe('join', function() {
      it('join exists', function() {
        expect(funkier).to.have.a.property('join');
      });


      it('funkierJS\'s join is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.join).to.equal(module.join);
      });


      it('join is a function', function() {
        expect(funkier.join).to.be.a('function');
      });


      it('join has documented arity', function() {
        expect(funkier.arityOf(funkier.join)).to.equal(2);
      });


      it('join is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.join)).to.equal(true);
      });
    });


    describe('keyValues', function() {
      it('keyValues exists', function() {
        expect(funkier).to.have.a.property('keyValues');
      });


      it('funkierJS\'s keyValues is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.keyValues).to.equal(module.keyValues);
      });


      it('keyValues is a function', function() {
        expect(funkier.keyValues).to.be.a('function');
      });


      it('keyValues has documented arity', function() {
        expect(funkier.arityOf(funkier.keyValues)).to.equal(1);
      });


      it('keyValues is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.keyValues)).to.equal(true);
      });
    });


    describe('keys', function() {
      it('keys exists', function() {
        expect(funkier).to.have.a.property('keys');
      });


      it('funkierJS\'s keys is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.keys).to.equal(module.keys);
      });


      it('keys is a function', function() {
        expect(funkier.keys).to.be.a('function');
      });


      it('keys has documented arity', function() {
        expect(funkier.arityOf(funkier.keys)).to.equal(1);
      });


      it('keys is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.keys)).to.equal(true);
      });
    });


    describe('last', function() {
      it('last exists', function() {
        expect(funkier).to.have.a.property('last');
      });


      it('funkierJS\'s last is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.last).to.equal(module.last);
      });


      it('last is a function', function() {
        expect(funkier.last).to.be.a('function');
      });


      it('last has documented arity', function() {
        expect(funkier.arityOf(funkier.last)).to.equal(1);
      });


      it('last is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.last)).to.equal(true);
      });
    });


    describe('leftShift', function() {
      it('leftShift exists', function() {
        expect(funkier).to.have.a.property('leftShift');
      });


      it('funkierJS\'s leftShift is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.leftShift).to.equal(module.leftShift);
      });


      it('leftShift is a function', function() {
        expect(funkier.leftShift).to.be.a('function');
      });


      it('leftShift has documented arity', function() {
        expect(funkier.arityOf(funkier.leftShift)).to.equal(2);
      });


      it('leftShift is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.leftShift)).to.equal(true);
      });
    });


    describe('length', function() {
      it('length exists', function() {
        expect(funkier).to.have.a.property('length');
      });


      it('funkierJS\'s length is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.length).to.equal(module.length);
      });


      it('length is a function', function() {
        expect(funkier.length).to.be.a('function');
      });


      it('length has documented arity', function() {
        expect(funkier.arityOf(funkier.length)).to.equal(1);
      });


      it('length is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.length)).to.equal(true);
      });
    });


    describe('lessThan', function() {
      it('lessThan exists', function() {
        expect(funkier).to.have.a.property('lessThan');
      });


      it('funkierJS\'s lessThan is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.lessThan).to.equal(module.lessThan);
      });


      it('lessThan is a function', function() {
        expect(funkier.lessThan).to.be.a('function');
      });


      it('lessThan has documented arity', function() {
        expect(funkier.arityOf(funkier.lessThan)).to.equal(2);
      });


      it('lessThan is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.lessThan)).to.equal(true);
      });
    });


    describe('lessThanEqual', function() {
      it('lessThanEqual exists', function() {
        expect(funkier).to.have.a.property('lessThanEqual');
      });


      it('funkierJS\'s lessThanEqual is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.lessThanEqual).to.equal(module.lessThanEqual);
      });


      it('lessThanEqual is a function', function() {
        expect(funkier.lessThanEqual).to.be.a('function');
      });


      it('lessThanEqual has documented arity', function() {
        expect(funkier.arityOf(funkier.lessThanEqual)).to.equal(2);
      });


      it('lessThanEqual is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.lessThanEqual)).to.equal(true);
      });
    });


    describe('log', function() {
      it('log exists', function() {
        expect(funkier).to.have.a.property('log');
      });


      it('funkierJS\'s log is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.log).to.equal(module.log);
      });


      it('log is a function', function() {
        expect(funkier.log).to.be.a('function');
      });


      it('log has documented arity', function() {
        expect(funkier.arityOf(funkier.log)).to.equal(2);
      });


      it('log is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.log)).to.equal(true);
      });
    });


    describe('lt', function() {
      it('lt exists', function() {
        expect(funkier).to.have.a.property('lt');
      });


      it('lt is a synonym for lessThan', function() {
        expect(funkier.lt).to.equal(funkier.lessThan);
      });
    });


    describe('lte', function() {
      it('lte exists', function() {
        expect(funkier).to.have.a.property('lte');
      });


      it('lte is a synonym for lessThanEqual', function() {
        expect(funkier.lte).to.equal(funkier.lessThanEqual);
      });
    });


    describe('makeDateFromMilliseconds', function() {
      it('makeDateFromMilliseconds exists', function() {
        expect(funkier).to.have.a.property('makeDateFromMilliseconds');
      });


      it('funkierJS\'s makeDateFromMilliseconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeDateFromMilliseconds).to.equal(module.makeDateFromMilliseconds);
      });


      it('makeDateFromMilliseconds is a function', function() {
        expect(funkier.makeDateFromMilliseconds).to.be.a('function');
      });


      it('makeDateFromMilliseconds has documented arity', function() {
        expect(funkier.arityOf(funkier.makeDateFromMilliseconds)).to.equal(1);
      });


      it('makeDateFromMilliseconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeDateFromMilliseconds)).to.equal(true);
      });
    });


    describe('makeDateFromString', function() {
      it('makeDateFromString exists', function() {
        expect(funkier).to.have.a.property('makeDateFromString');
      });


      it('funkierJS\'s makeDateFromString is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeDateFromString).to.equal(module.makeDateFromString);
      });


      it('makeDateFromString is a function', function() {
        expect(funkier.makeDateFromString).to.be.a('function');
      });


      it('makeDateFromString has documented arity', function() {
        expect(funkier.arityOf(funkier.makeDateFromString)).to.equal(1);
      });


      it('makeDateFromString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeDateFromString)).to.equal(true);
      });
    });


    describe('makeDayDate', function() {
      it('makeDayDate exists', function() {
        expect(funkier).to.have.a.property('makeDayDate');
      });


      it('funkierJS\'s makeDayDate is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeDayDate).to.equal(module.makeDayDate);
      });


      it('makeDayDate is a function', function() {
        expect(funkier.makeDayDate).to.be.a('function');
      });


      it('makeDayDate has documented arity', function() {
        expect(funkier.arityOf(funkier.makeDayDate)).to.equal(3);
      });


      it('makeDayDate is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeDayDate)).to.equal(true);
      });
    });


    describe('makeHourDate', function() {
      it('makeHourDate exists', function() {
        expect(funkier).to.have.a.property('makeHourDate');
      });


      it('funkierJS\'s makeHourDate is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeHourDate).to.equal(module.makeHourDate);
      });


      it('makeHourDate is a function', function() {
        expect(funkier.makeHourDate).to.be.a('function');
      });


      it('makeHourDate has documented arity', function() {
        expect(funkier.arityOf(funkier.makeHourDate)).to.equal(4);
      });


      it('makeHourDate is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeHourDate)).to.equal(true);
      });
    });


    describe('makeMaybeReturner', function() {
      it('makeMaybeReturner exists', function() {
        expect(funkier).to.have.a.property('makeMaybeReturner');
      });


      it('funkierJS\'s makeMaybeReturner is indeed the documented value', function() {
        var module = require('../../lib/components/maybe');
        expect(funkier.makeMaybeReturner).to.equal(module.makeMaybeReturner);
      });


      it('makeMaybeReturner is a function', function() {
        expect(funkier.makeMaybeReturner).to.be.a('function');
      });


      it('makeMaybeReturner has documented arity', function() {
        expect(funkier.arityOf(funkier.makeMaybeReturner)).to.equal(1);
      });


      it('makeMaybeReturner is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeMaybeReturner)).to.equal(true);
      });
    });


    describe('makeMillisecondDate', function() {
      it('makeMillisecondDate exists', function() {
        expect(funkier).to.have.a.property('makeMillisecondDate');
      });


      it('funkierJS\'s makeMillisecondDate is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeMillisecondDate).to.equal(module.makeMillisecondDate);
      });


      it('makeMillisecondDate is a function', function() {
        expect(funkier.makeMillisecondDate).to.be.a('function');
      });


      it('makeMillisecondDate has documented arity', function() {
        expect(funkier.arityOf(funkier.makeMillisecondDate)).to.equal(7);
      });


      it('makeMillisecondDate is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeMillisecondDate)).to.equal(true);
      });
    });


    describe('makeMinuteDate', function() {
      it('makeMinuteDate exists', function() {
        expect(funkier).to.have.a.property('makeMinuteDate');
      });


      it('funkierJS\'s makeMinuteDate is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeMinuteDate).to.equal(module.makeMinuteDate);
      });


      it('makeMinuteDate is a function', function() {
        expect(funkier.makeMinuteDate).to.be.a('function');
      });


      it('makeMinuteDate has documented arity', function() {
        expect(funkier.arityOf(funkier.makeMinuteDate)).to.equal(5);
      });


      it('makeMinuteDate is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeMinuteDate)).to.equal(true);
      });
    });


    describe('makeMonthDate', function() {
      it('makeMonthDate exists', function() {
        expect(funkier).to.have.a.property('makeMonthDate');
      });


      it('funkierJS\'s makeMonthDate is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeMonthDate).to.equal(module.makeMonthDate);
      });


      it('makeMonthDate is a function', function() {
        expect(funkier.makeMonthDate).to.be.a('function');
      });


      it('makeMonthDate has documented arity', function() {
        expect(funkier.arityOf(funkier.makeMonthDate)).to.equal(2);
      });


      it('makeMonthDate is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeMonthDate)).to.equal(true);
      });
    });


    describe('makeResultReturner', function() {
      it('makeResultReturner exists', function() {
        expect(funkier).to.have.a.property('makeResultReturner');
      });


      it('funkierJS\'s makeResultReturner is indeed the documented value', function() {
        var module = require('../../lib/components/result');
        expect(funkier.makeResultReturner).to.equal(module.makeResultReturner);
      });


      it('makeResultReturner is a function', function() {
        expect(funkier.makeResultReturner).to.be.a('function');
      });


      it('makeResultReturner has documented arity', function() {
        expect(funkier.arityOf(funkier.makeResultReturner)).to.equal(1);
      });


      it('makeResultReturner is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeResultReturner)).to.equal(true);
      });
    });


    describe('makeSecondDate', function() {
      it('makeSecondDate exists', function() {
        expect(funkier).to.have.a.property('makeSecondDate');
      });


      it('funkierJS\'s makeSecondDate is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.makeSecondDate).to.equal(module.makeSecondDate);
      });


      it('makeSecondDate is a function', function() {
        expect(funkier.makeSecondDate).to.be.a('function');
      });


      it('makeSecondDate has documented arity', function() {
        expect(funkier.arityOf(funkier.makeSecondDate)).to.equal(6);
      });


      it('makeSecondDate is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.makeSecondDate)).to.equal(true);
      });
    });


    describe('map', function() {
      it('map exists', function() {
        expect(funkier).to.have.a.property('map');
      });


      it('funkierJS\'s map is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.map).to.equal(module.map);
      });


      it('map is a function', function() {
        expect(funkier.map).to.be.a('function');
      });


      it('map has documented arity', function() {
        expect(funkier.arityOf(funkier.map)).to.equal(2);
      });


      it('map is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.map)).to.equal(true);
      });
    });


    describe('matches', function() {
      it('matches exists', function() {
        expect(funkier).to.have.a.property('matches');
      });


      it('funkierJS\'s matches is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.matches).to.equal(module.matches);
      });


      it('matches is a function', function() {
        expect(funkier.matches).to.be.a('function');
      });


      it('matches has documented arity', function() {
        expect(funkier.arityOf(funkier.matches)).to.equal(2);
      });


      it('matches is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.matches)).to.equal(true);
      });
    });


    describe('matchesFrom', function() {
      it('matchesFrom exists', function() {
        expect(funkier).to.have.a.property('matchesFrom');
      });


      it('funkierJS\'s matchesFrom is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.matchesFrom).to.equal(module.matchesFrom);
      });


      it('matchesFrom is a function', function() {
        expect(funkier.matchesFrom).to.be.a('function');
      });


      it('matchesFrom has documented arity', function() {
        expect(funkier.arityOf(funkier.matchesFrom)).to.equal(3);
      });


      it('matchesFrom is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.matchesFrom)).to.equal(true);
      });
    });


    describe('max', function() {
      it('max exists', function() {
        expect(funkier).to.have.a.property('max');
      });


      it('funkierJS\'s max is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.max).to.equal(module.max);
      });


      it('max is a function', function() {
        expect(funkier.max).to.be.a('function');
      });


      it('max has documented arity', function() {
        expect(funkier.arityOf(funkier.max)).to.equal(2);
      });


      it('max is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.max)).to.equal(true);
      });
    });


    describe('maximum', function() {
      it('maximum exists', function() {
        expect(funkier).to.have.a.property('maximum');
      });


      it('funkierJS\'s maximum is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.maximum).to.equal(module.maximum);
      });


      it('maximum is a function', function() {
        expect(funkier.maximum).to.be.a('function');
      });


      it('maximum has documented arity', function() {
        expect(funkier.arityOf(funkier.maximum)).to.equal(1);
      });


      it('maximum is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.maximum)).to.equal(true);
      });
    });


    describe('maybeCreate', function() {
      it('maybeCreate exists', function() {
        expect(funkier).to.have.a.property('maybeCreate');
      });


      it('maybeCreate is a synonym for safeCreateProp', function() {
        expect(funkier.maybeCreate).to.equal(funkier.safeCreateProp);
      });
    });


    describe('maybeDelete', function() {
      it('maybeDelete exists', function() {
        expect(funkier).to.have.a.property('maybeDelete');
      });


      it('maybeDelete is a synonym for safeDeleteProp', function() {
        expect(funkier.maybeDelete).to.equal(funkier.safeDeleteProp);
      });
    });


    describe('maybeExtract', function() {
      it('maybeExtract exists', function() {
        expect(funkier).to.have.a.property('maybeExtract');
      });


      it('funkierJS\'s maybeExtract is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.maybeExtract).to.equal(module.maybeExtract);
      });


      it('maybeExtract is a function', function() {
        expect(funkier.maybeExtract).to.be.a('function');
      });


      it('maybeExtract has documented arity', function() {
        expect(funkier.arityOf(funkier.maybeExtract)).to.equal(2);
      });


      it('maybeExtract is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.maybeExtract)).to.equal(true);
      });
    });


    describe('maybeModify', function() {
      it('maybeModify exists', function() {
        expect(funkier).to.have.a.property('maybeModify');
      });


      it('maybeModify is a synonym for safeModify', function() {
        expect(funkier.maybeModify).to.equal(funkier.safeModify);
      });
    });


    describe('maybeModifyProp', function() {
      it('maybeModifyProp exists', function() {
        expect(funkier).to.have.a.property('maybeModifyProp');
      });


      it('maybeModifyProp is a synonym for safeModify', function() {
        expect(funkier.maybeModifyProp).to.equal(funkier.safeModify);
      });
    });


    describe('maybeSet', function() {
      it('maybeSet exists', function() {
        expect(funkier).to.have.a.property('maybeSet');
      });


      it('maybeSet is a synonym for safeSet', function() {
        expect(funkier.maybeSet).to.equal(funkier.safeSet);
      });
    });


    describe('maybeSetProp', function() {
      it('maybeSetProp exists', function() {
        expect(funkier).to.have.a.property('maybeSetProp');
      });


      it('maybeSetProp is a synonym for safeSet', function() {
        expect(funkier.maybeSetProp).to.equal(funkier.safeSet);
      });
    });


    describe('maybeTap', function() {
      it('maybeTap exists', function() {
        expect(funkier).to.have.a.property('maybeTap');
      });


      it('maybeTap is a synonym for maybeExtract', function() {
        expect(funkier.maybeTap).to.equal(funkier.maybeExtract);
      });
    });


    describe('min', function() {
      it('min exists', function() {
        expect(funkier).to.have.a.property('min');
      });


      it('funkierJS\'s min is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.min).to.equal(module.min);
      });


      it('min is a function', function() {
        expect(funkier.min).to.be.a('function');
      });


      it('min has documented arity', function() {
        expect(funkier.arityOf(funkier.min)).to.equal(2);
      });


      it('min is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.min)).to.equal(true);
      });
    });


    describe('minimum', function() {
      it('minimum exists', function() {
        expect(funkier).to.have.a.property('minimum');
      });


      it('funkierJS\'s minimum is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.minimum).to.equal(module.minimum);
      });


      it('minimum is a function', function() {
        expect(funkier.minimum).to.be.a('function');
      });


      it('minimum has documented arity', function() {
        expect(funkier.arityOf(funkier.minimum)).to.equal(1);
      });


      it('minimum is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.minimum)).to.equal(true);
      });
    });


    describe('modify', function() {
      it('modify exists', function() {
        expect(funkier).to.have.a.property('modify');
      });


      it('funkierJS\'s modify is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.modify).to.equal(module.modify);
      });


      it('modify is a function', function() {
        expect(funkier.modify).to.be.a('function');
      });


      it('modify has documented arity', function() {
        expect(funkier.arityOf(funkier.modify)).to.equal(3);
      });


      it('modify is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.modify)).to.equal(true);
      });
    });


    describe('modifyProp', function() {
      it('modifyProp exists', function() {
        expect(funkier).to.have.a.property('modifyProp');
      });


      it('modifyProp is a synonym for modify', function() {
        expect(funkier.modifyProp).to.equal(funkier.modify);
      });
    });


    describe('multiply', function() {
      it('multiply exists', function() {
        expect(funkier).to.have.a.property('multiply');
      });


      it('funkierJS\'s multiply is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.multiply).to.equal(module.multiply);
      });


      it('multiply is a function', function() {
        expect(funkier.multiply).to.be.a('function');
      });


      it('multiply has documented arity', function() {
        expect(funkier.arityOf(funkier.multiply)).to.equal(2);
      });


      it('multiply is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.multiply)).to.equal(true);
      });
    });


    describe('not', function() {
      it('not exists', function() {
        expect(funkier).to.have.a.property('not');
      });


      it('funkierJS\'s not is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.not).to.equal(module.not);
      });


      it('not is a function', function() {
        expect(funkier.not).to.be.a('function');
      });


      it('not has documented arity', function() {
        expect(funkier.arityOf(funkier.not)).to.equal(1);
      });


      it('not is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.not)).to.equal(true);
      });
    });


    describe('notEqual', function() {
      it('notEqual exists', function() {
        expect(funkier).to.have.a.property('notEqual');
      });


      it('funkierJS\'s notEqual is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.notEqual).to.equal(module.notEqual);
      });


      it('notEqual is a function', function() {
        expect(funkier.notEqual).to.be.a('function');
      });


      it('notEqual has documented arity', function() {
        expect(funkier.arityOf(funkier.notEqual)).to.equal(2);
      });


      it('notEqual is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.notEqual)).to.equal(true);
      });
    });


    describe('notEquals', function() {
      it('notEquals exists', function() {
        expect(funkier).to.have.a.property('notEquals');
      });


      it('notEquals is a synonym for notEqual', function() {
        expect(funkier.notEquals).to.equal(funkier.notEqual);
      });
    });


    describe('notPred', function() {
      it('notPred exists', function() {
        expect(funkier).to.have.a.property('notPred');
      });


      it('funkierJS\'s notPred is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.notPred).to.equal(module.notPred);
      });


      it('notPred is a function', function() {
        expect(funkier.notPred).to.be.a('function');
      });


      it('notPred has documented arity', function() {
        expect(funkier.arityOf(funkier.notPred)).to.equal(1);
      });


      it('notPred is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.notPred)).to.equal(true);
      });
    });


    describe('nub', function() {
      it('nub exists', function() {
        expect(funkier).to.have.a.property('nub');
      });


      it('funkierJS\'s nub is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.nub).to.equal(module.nub);
      });


      it('nub is a function', function() {
        expect(funkier.nub).to.be.a('function');
      });


      it('nub has documented arity', function() {
        expect(funkier.arityOf(funkier.nub)).to.equal(1);
      });


      it('nub is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.nub)).to.equal(true);
      });
    });


    describe('nubWith', function() {
      it('nubWith exists', function() {
        expect(funkier).to.have.a.property('nubWith');
      });


      it('funkierJS\'s nubWith is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.nubWith).to.equal(module.nubWith);
      });


      it('nubWith is a function', function() {
        expect(funkier.nubWith).to.be.a('function');
      });


      it('nubWith has documented arity', function() {
        expect(funkier.arityOf(funkier.nubWith)).to.equal(2);
      });


      it('nubWith is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.nubWith)).to.equal(true);
      });
    });


    describe('objectCurry', function() {
      it('objectCurry exists', function() {
        expect(funkier).to.have.a.property('objectCurry');
      });


      it('funkierJS\'s objectCurry is indeed the documented value', function() {
        var module = require('../../lib/components/curry');
        expect(funkier.objectCurry).to.equal(module.objectCurry);
      });


      it('objectCurry is a function', function() {
        expect(funkier.objectCurry).to.be.a('function');
      });


      it('objectCurry has documented arity', function() {
        expect(funkier.arityOf(funkier.objectCurry)).to.equal(1);
      });


      it('objectCurry is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.objectCurry)).to.equal(true);
      });
    });


    describe('objectCurryWithArity', function() {
      it('objectCurryWithArity exists', function() {
        expect(funkier).to.have.a.property('objectCurryWithArity');
      });


      it('funkierJS\'s objectCurryWithArity is indeed the documented value', function() {
        var module = require('../../lib/components/curry');
        expect(funkier.objectCurryWithArity).to.equal(module.objectCurryWithArity);
      });


      it('objectCurryWithArity is a function', function() {
        expect(funkier.objectCurryWithArity).to.be.a('function');
      });


      it('objectCurryWithArity has documented arity', function() {
        expect(funkier.arityOf(funkier.objectCurryWithArity)).to.equal(2);
      });


      it('objectCurryWithArity is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.objectCurryWithArity)).to.equal(true);
      });
    });


    describe('occurrences', function() {
      it('occurrences exists', function() {
        expect(funkier).to.have.a.property('occurrences');
      });


      it('funkierJS\'s occurrences is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.occurrences).to.equal(module.occurrences);
      });


      it('occurrences is a function', function() {
        expect(funkier.occurrences).to.be.a('function');
      });


      it('occurrences has documented arity', function() {
        expect(funkier.arityOf(funkier.occurrences)).to.equal(2);
      });


      it('occurrences is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.occurrences)).to.equal(true);
      });
    });


    describe('occurrencesWith', function() {
      it('occurrencesWith exists', function() {
        expect(funkier).to.have.a.property('occurrencesWith');
      });


      it('funkierJS\'s occurrencesWith is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.occurrencesWith).to.equal(module.occurrencesWith);
      });


      it('occurrencesWith is a function', function() {
        expect(funkier.occurrencesWith).to.be.a('function');
      });


      it('occurrencesWith has documented arity', function() {
        expect(funkier.arityOf(funkier.occurrencesWith)).to.equal(2);
      });


      it('occurrencesWith is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.occurrencesWith)).to.equal(true);
      });
    });


    describe('odd', function() {
      it('odd exists', function() {
        expect(funkier).to.have.a.property('odd');
      });


      it('funkierJS\'s odd is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.odd).to.equal(module.odd);
      });


      it('odd is a function', function() {
        expect(funkier.odd).to.be.a('function');
      });


      it('odd has documented arity', function() {
        expect(funkier.arityOf(funkier.odd)).to.equal(1);
      });


      it('odd is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.odd)).to.equal(true);
      });
    });


    describe('or', function() {
      it('or exists', function() {
        expect(funkier).to.have.a.property('or');
      });


      it('funkierJS\'s or is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.or).to.equal(module.or);
      });


      it('or is a function', function() {
        expect(funkier.or).to.be.a('function');
      });


      it('or has documented arity', function() {
        expect(funkier.arityOf(funkier.or)).to.equal(2);
      });


      it('or is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.or)).to.equal(true);
      });
    });


    describe('orPred', function() {
      it('orPred exists', function() {
        expect(funkier).to.have.a.property('orPred');
      });


      it('funkierJS\'s orPred is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.orPred).to.equal(module.orPred);
      });


      it('orPred is a function', function() {
        expect(funkier.orPred).to.be.a('function');
      });


      it('orPred has documented arity', function() {
        expect(funkier.arityOf(funkier.orPred)).to.equal(2);
      });


      it('orPred is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.orPred)).to.equal(true);
      });
    });


    describe('ord', function() {
      it('ord exists', function() {
        expect(funkier).to.have.a.property('ord');
      });


      it('funkierJS\'s ord is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.ord).to.equal(module.ord);
      });


      it('ord is a function', function() {
        expect(funkier.ord).to.be.a('function');
      });


      it('ord has documented arity', function() {
        expect(funkier.arityOf(funkier.ord)).to.equal(1);
      });


      it('ord is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.ord)).to.equal(true);
      });
    });


    describe('parseInt', function() {
      it('parseInt exists', function() {
        expect(funkier).to.have.a.property('parseInt');
      });


      it('funkierJS\'s parseInt is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.parseInt).to.equal(module.parseInt);
      });


      it('parseInt is a function', function() {
        expect(funkier.parseInt).to.be.a('function');
      });


      it('parseInt has documented arity', function() {
        expect(funkier.arityOf(funkier.parseInt)).to.equal(1);
      });


      it('parseInt is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.parseInt)).to.equal(true);
      });
    });


    describe('parseIntInBase', function() {
      it('parseIntInBase exists', function() {
        expect(funkier).to.have.a.property('parseIntInBase');
      });


      it('parseIntInBase is a synonym for stringToInt', function() {
        expect(funkier.parseIntInBase).to.equal(funkier.stringToInt);
      });
    });


    describe('permuteLeft', function() {
      it('permuteLeft exists', function() {
        expect(funkier).to.have.a.property('permuteLeft');
      });


      it('funkierJS\'s permuteLeft is indeed the documented value', function() {
        var module = require('../../lib/components/fn');
        expect(funkier.permuteLeft).to.equal(module.permuteLeft);
      });


      it('permuteLeft is a function', function() {
        expect(funkier.permuteLeft).to.be.a('function');
      });


      it('permuteLeft has documented arity', function() {
        expect(funkier.arityOf(funkier.permuteLeft)).to.equal(1);
      });


      it('permuteLeft is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.permuteLeft)).to.equal(true);
      });
    });


    describe('permuteRight', function() {
      it('permuteRight exists', function() {
        expect(funkier).to.have.a.property('permuteRight');
      });


      it('funkierJS\'s permuteRight is indeed the documented value', function() {
        var module = require('../../lib/components/fn');
        expect(funkier.permuteRight).to.equal(module.permuteRight);
      });


      it('permuteRight is a function', function() {
        expect(funkier.permuteRight).to.be.a('function');
      });


      it('permuteRight has documented arity', function() {
        expect(funkier.arityOf(funkier.permuteRight)).to.equal(1);
      });


      it('permuteRight is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.permuteRight)).to.equal(true);
      });
    });


    describe('plus', function() {
      it('plus exists', function() {
        expect(funkier).to.have.a.property('plus');
      });


      it('plus is a synonym for add', function() {
        expect(funkier.plus).to.equal(funkier.add);
      });
    });


    describe('post', function() {
      it('post exists', function() {
        expect(funkier).to.have.a.property('post');
      });


      it('funkierJS\'s post is indeed the documented value', function() {
        var module = require('../../lib/components/fn');
        expect(funkier.post).to.equal(module.post);
      });


      it('post is a function', function() {
        expect(funkier.post).to.be.a('function');
      });


      it('post has documented arity', function() {
        expect(funkier.arityOf(funkier.post)).to.equal(2);
      });


      it('post is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.post)).to.equal(true);
      });
    });


    describe('pow', function() {
      it('pow exists', function() {
        expect(funkier).to.have.a.property('pow');
      });


      it('pow is a synonym for exp', function() {
        expect(funkier.pow).to.equal(funkier.exp);
      });
    });


    describe('pre', function() {
      it('pre exists', function() {
        expect(funkier).to.have.a.property('pre');
      });


      it('funkierJS\'s pre is indeed the documented value', function() {
        var module = require('../../lib/components/fn');
        expect(funkier.pre).to.equal(module.pre);
      });


      it('pre is a function', function() {
        expect(funkier.pre).to.be.a('function');
      });


      it('pre has documented arity', function() {
        expect(funkier.arityOf(funkier.pre)).to.equal(2);
      });


      it('pre is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.pre)).to.equal(true);
      });
    });


    describe('prefixes', function() {
      it('prefixes exists', function() {
        expect(funkier).to.have.a.property('prefixes');
      });


      it('prefixes is a synonym for inits', function() {
        expect(funkier.prefixes).to.equal(funkier.inits);
      });
    });


    describe('prepend', function() {
      it('prepend exists', function() {
        expect(funkier).to.have.a.property('prepend');
      });


      it('funkierJS\'s prepend is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.prepend).to.equal(module.prepend);
      });


      it('prepend is a function', function() {
        expect(funkier.prepend).to.be.a('function');
      });


      it('prepend has documented arity', function() {
        expect(funkier.arityOf(funkier.prepend)).to.equal(2);
      });


      it('prepend is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.prepend)).to.equal(true);
      });
    });


    describe('product', function() {
      it('product exists', function() {
        expect(funkier).to.have.a.property('product');
      });


      it('funkierJS\'s product is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.product).to.equal(module.product);
      });


      it('product is a function', function() {
        expect(funkier.product).to.be.a('function');
      });


      it('product has documented arity', function() {
        expect(funkier.arityOf(funkier.product)).to.equal(1);
      });


      it('product is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.product)).to.equal(true);
      });
    });


    describe('range', function() {
      it('range exists', function() {
        expect(funkier).to.have.a.property('range');
      });


      it('funkierJS\'s range is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.range).to.equal(module.range);
      });


      it('range is a function', function() {
        expect(funkier.range).to.be.a('function');
      });


      it('range has documented arity', function() {
        expect(funkier.arityOf(funkier.range)).to.equal(2);
      });


      it('range is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.range)).to.equal(true);
      });
    });


    describe('rangeStep', function() {
      it('rangeStep exists', function() {
        expect(funkier).to.have.a.property('rangeStep');
      });


      it('rangeStep is a synonym for rangeStride', function() {
        expect(funkier.rangeStep).to.equal(funkier.rangeStride);
      });
    });


    describe('rangeStride', function() {
      it('rangeStride exists', function() {
        expect(funkier).to.have.a.property('rangeStride');
      });


      it('funkierJS\'s rangeStride is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.rangeStride).to.equal(module.rangeStride);
      });


      it('rangeStride is a function', function() {
        expect(funkier.rangeStride).to.be.a('function');
      });


      it('rangeStride has documented arity', function() {
        expect(funkier.arityOf(funkier.rangeStride)).to.equal(3);
      });


      it('rangeStride is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.rangeStride)).to.equal(true);
      });
    });


    describe('reduce', function() {
      it('reduce exists', function() {
        expect(funkier).to.have.a.property('reduce');
      });


      it('reduce is a synonym for foldl', function() {
        expect(funkier.reduce).to.equal(funkier.foldl);
      });
    });


    describe('reduce1', function() {
      it('reduce1 exists', function() {
        expect(funkier).to.have.a.property('reduce1');
      });


      it('reduce1 is a synonym for foldl1', function() {
        expect(funkier.reduce1).to.equal(funkier.foldl1);
      });
    });


    describe('reduceRight', function() {
      it('reduceRight exists', function() {
        expect(funkier).to.have.a.property('reduceRight');
      });


      it('reduceRight is a synonym for foldr', function() {
        expect(funkier.reduceRight).to.equal(funkier.foldr);
      });
    });


    describe('reduceRight1', function() {
      it('reduceRight1 exists', function() {
        expect(funkier).to.have.a.property('reduceRight1');
      });


      it('reduceRight1 is a synonym for foldr1', function() {
        expect(funkier.reduceRight1).to.equal(funkier.foldr1);
      });
    });


    describe('regExpSplit', function() {
      it('regExpSplit exists', function() {
        expect(funkier).to.have.a.property('regExpSplit');
      });


      it('funkierJS\'s regExpSplit is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.regExpSplit).to.equal(module.regExpSplit);
      });


      it('regExpSplit is a function', function() {
        expect(funkier.regExpSplit).to.be.a('function');
      });


      it('regExpSplit has documented arity', function() {
        expect(funkier.arityOf(funkier.regExpSplit)).to.equal(2);
      });


      it('regExpSplit is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.regExpSplit)).to.equal(true);
      });
    });


    describe('regExpSplitCount', function() {
      it('regExpSplitCount exists', function() {
        expect(funkier).to.have.a.property('regExpSplitCount');
      });


      it('regExpSplitCount is a synonym for regExpSplitMax', function() {
        expect(funkier.regExpSplitCount).to.equal(funkier.regExpSplitMax);
      });
    });


    describe('regExpSplitLimit', function() {
      it('regExpSplitLimit exists', function() {
        expect(funkier).to.have.a.property('regExpSplitLimit');
      });


      it('regExpSplitLimit is a synonym for regExpSplitMax', function() {
        expect(funkier.regExpSplitLimit).to.equal(funkier.regExpSplitMax);
      });
    });


    describe('regExpSplitMax', function() {
      it('regExpSplitMax exists', function() {
        expect(funkier).to.have.a.property('regExpSplitMax');
      });


      it('funkierJS\'s regExpSplitMax is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.regExpSplitMax).to.equal(module.regExpSplitMax);
      });


      it('regExpSplitMax is a function', function() {
        expect(funkier.regExpSplitMax).to.be.a('function');
      });


      it('regExpSplitMax has documented arity', function() {
        expect(funkier.arityOf(funkier.regExpSplitMax)).to.equal(3);
      });


      it('regExpSplitMax is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.regExpSplitMax)).to.equal(true);
      });
    });


    describe('rem', function() {
      it('rem exists', function() {
        expect(funkier).to.have.a.property('rem');
      });


      it('funkierJS\'s rem is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.rem).to.equal(module.rem);
      });


      it('rem is a function', function() {
        expect(funkier.rem).to.be.a('function');
      });


      it('rem has documented arity', function() {
        expect(funkier.arityOf(funkier.rem)).to.equal(2);
      });


      it('rem is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.rem)).to.equal(true);
      });
    });


    describe('replicate', function() {
      it('replicate exists', function() {
        expect(funkier).to.have.a.property('replicate');
      });


      it('funkierJS\'s replicate is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.replicate).to.equal(module.replicate);
      });


      it('replicate is a function', function() {
        expect(funkier.replicate).to.be.a('function');
      });


      it('replicate has documented arity', function() {
        expect(funkier.arityOf(funkier.replicate)).to.equal(2);
      });


      it('replicate is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.replicate)).to.equal(true);
      });
    });


    describe('reverse', function() {
      it('reverse exists', function() {
        expect(funkier).to.have.a.property('reverse');
      });


      it('funkierJS\'s reverse is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.reverse).to.equal(module.reverse);
      });


      it('reverse is a function', function() {
        expect(funkier.reverse).to.be.a('function');
      });


      it('reverse has documented arity', function() {
        expect(funkier.arityOf(funkier.reverse)).to.equal(1);
      });


      it('reverse is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.reverse)).to.equal(true);
      });
    });


    describe('rightShift', function() {
      it('rightShift exists', function() {
        expect(funkier).to.have.a.property('rightShift');
      });


      it('funkierJS\'s rightShift is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.rightShift).to.equal(module.rightShift);
      });


      it('rightShift is a function', function() {
        expect(funkier.rightShift).to.be.a('function');
      });


      it('rightShift has documented arity', function() {
        expect(funkier.arityOf(funkier.rightShift)).to.equal(2);
      });


      it('rightShift is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.rightShift)).to.equal(true);
      });
    });


    describe('rightShiftZero', function() {
      it('rightShiftZero exists', function() {
        expect(funkier).to.have.a.property('rightShiftZero');
      });


      it('funkierJS\'s rightShiftZero is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.rightShiftZero).to.equal(module.rightShiftZero);
      });


      it('rightShiftZero is a function', function() {
        expect(funkier.rightShiftZero).to.be.a('function');
      });


      it('rightShiftZero has documented arity', function() {
        expect(funkier.arityOf(funkier.rightShiftZero)).to.equal(2);
      });


      it('rightShiftZero is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.rightShiftZero)).to.equal(true);
      });
    });


    describe('rotateLeft', function() {
      it('rotateLeft exists', function() {
        expect(funkier).to.have.a.property('rotateLeft');
      });


      it('rotateLeft is a synonym for permuteLeft', function() {
        expect(funkier.rotateLeft).to.equal(funkier.permuteLeft);
      });
    });


    describe('rotateRight', function() {
      it('rotateRight exists', function() {
        expect(funkier).to.have.a.property('rotateRight');
      });


      it('rotateRight is a synonym for permuteRight', function() {
        expect(funkier.rotateRight).to.equal(funkier.permuteRight);
      });
    });


    describe('safeCreateProp', function() {
      it('safeCreateProp exists', function() {
        expect(funkier).to.have.a.property('safeCreateProp');
      });


      it('funkierJS\'s safeCreateProp is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.safeCreateProp).to.equal(module.safeCreateProp);
      });


      it('safeCreateProp is a function', function() {
        expect(funkier.safeCreateProp).to.be.a('function');
      });


      it('safeCreateProp has documented arity', function() {
        expect(funkier.arityOf(funkier.safeCreateProp)).to.equal(3);
      });


      it('safeCreateProp is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.safeCreateProp)).to.equal(true);
      });
    });


    describe('safeDeleteProp', function() {
      it('safeDeleteProp exists', function() {
        expect(funkier).to.have.a.property('safeDeleteProp');
      });


      it('funkierJS\'s safeDeleteProp is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.safeDeleteProp).to.equal(module.safeDeleteProp);
      });


      it('safeDeleteProp is a function', function() {
        expect(funkier.safeDeleteProp).to.be.a('function');
      });


      it('safeDeleteProp has documented arity', function() {
        expect(funkier.arityOf(funkier.safeDeleteProp)).to.equal(2);
      });


      it('safeDeleteProp is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.safeDeleteProp)).to.equal(true);
      });
    });


    describe('safeExtract', function() {
      it('safeExtract exists', function() {
        expect(funkier).to.have.a.property('safeExtract');
      });


      it('safeExtract is a synonym for maybeExtract', function() {
        expect(funkier.safeExtract).to.equal(funkier.maybeExtract);
      });
    });


    describe('safeModify', function() {
      it('safeModify exists', function() {
        expect(funkier).to.have.a.property('safeModify');
      });


      it('funkierJS\'s safeModify is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.safeModify).to.equal(module.safeModify);
      });


      it('safeModify is a function', function() {
        expect(funkier.safeModify).to.be.a('function');
      });


      it('safeModify has documented arity', function() {
        expect(funkier.arityOf(funkier.safeModify)).to.equal(3);
      });


      it('safeModify is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.safeModify)).to.equal(true);
      });
    });


    describe('safeModifyProp', function() {
      it('safeModifyProp exists', function() {
        expect(funkier).to.have.a.property('safeModifyProp');
      });


      it('safeModifyProp is a synonym for safeModify', function() {
        expect(funkier.safeModifyProp).to.equal(funkier.safeModify);
      });
    });


    describe('safeSet', function() {
      it('safeSet exists', function() {
        expect(funkier).to.have.a.property('safeSet');
      });


      it('funkierJS\'s safeSet is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.safeSet).to.equal(module.safeSet);
      });


      it('safeSet is a function', function() {
        expect(funkier.safeSet).to.be.a('function');
      });


      it('safeSet has documented arity', function() {
        expect(funkier.arityOf(funkier.safeSet)).to.equal(3);
      });


      it('safeSet is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.safeSet)).to.equal(true);
      });
    });


    describe('safeSetProp', function() {
      it('safeSetProp exists', function() {
        expect(funkier).to.have.a.property('safeSetProp');
      });


      it('safeSetProp is a synonym for safeSet', function() {
        expect(funkier.safeSetProp).to.equal(funkier.safeSet);
      });
    });


    describe('safeTap', function() {
      it('safeTap exists', function() {
        expect(funkier).to.have.a.property('safeTap');
      });


      it('safeTap is a synonym for maybeExtract', function() {
        expect(funkier.safeTap).to.equal(funkier.maybeExtract);
      });
    });


    describe('second', function() {
      it('second exists', function() {
        expect(funkier).to.have.a.property('second');
      });


      it('second is a synonym for snd', function() {
        expect(funkier.second).to.equal(funkier.snd);
      });
    });


    describe('sectionLeft', function() {
      it('sectionLeft exists', function() {
        expect(funkier).to.have.a.property('sectionLeft');
      });


      it('funkierJS\'s sectionLeft is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.sectionLeft).to.equal(module.sectionLeft);
      });


      it('sectionLeft is a function', function() {
        expect(funkier.sectionLeft).to.be.a('function');
      });


      it('sectionLeft has documented arity', function() {
        expect(funkier.arityOf(funkier.sectionLeft)).to.equal(2);
      });


      it('sectionLeft is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.sectionLeft)).to.equal(true);
      });
    });


    describe('sectionRight', function() {
      it('sectionRight exists', function() {
        expect(funkier).to.have.a.property('sectionRight');
      });


      it('funkierJS\'s sectionRight is indeed the documented value', function() {
        var module = require('../../lib/components/base');
        expect(funkier.sectionRight).to.equal(module.sectionRight);
      });


      it('sectionRight is a function', function() {
        expect(funkier.sectionRight).to.be.a('function');
      });


      it('sectionRight has documented arity', function() {
        expect(funkier.arityOf(funkier.sectionRight)).to.equal(2);
      });


      it('sectionRight is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.sectionRight)).to.equal(true);
      });
    });


    describe('set', function() {
      it('set exists', function() {
        expect(funkier).to.have.a.property('set');
      });


      it('funkierJS\'s set is indeed the documented value', function() {
        var module = require('../../lib/components/object');
        expect(funkier.set).to.equal(module.set);
      });


      it('set is a function', function() {
        expect(funkier.set).to.be.a('function');
      });


      it('set has documented arity', function() {
        expect(funkier.arityOf(funkier.set)).to.equal(3);
      });


      it('set is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.set)).to.equal(true);
      });
    });


    describe('setDayOfMonth', function() {
      it('setDayOfMonth exists', function() {
        expect(funkier).to.have.a.property('setDayOfMonth');
      });


      it('funkierJS\'s setDayOfMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setDayOfMonth).to.equal(module.setDayOfMonth);
      });


      it('setDayOfMonth is a function', function() {
        expect(funkier.setDayOfMonth).to.be.a('function');
      });


      it('setDayOfMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.setDayOfMonth)).to.equal(2);
      });


      it('setDayOfMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setDayOfMonth)).to.equal(true);
      });
    });


    describe('setFullYear', function() {
      it('setFullYear exists', function() {
        expect(funkier).to.have.a.property('setFullYear');
      });


      it('funkierJS\'s setFullYear is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setFullYear).to.equal(module.setFullYear);
      });


      it('setFullYear is a function', function() {
        expect(funkier.setFullYear).to.be.a('function');
      });


      it('setFullYear has documented arity', function() {
        expect(funkier.arityOf(funkier.setFullYear)).to.equal(2);
      });


      it('setFullYear is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setFullYear)).to.equal(true);
      });
    });


    describe('setHours', function() {
      it('setHours exists', function() {
        expect(funkier).to.have.a.property('setHours');
      });


      it('funkierJS\'s setHours is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setHours).to.equal(module.setHours);
      });


      it('setHours is a function', function() {
        expect(funkier.setHours).to.be.a('function');
      });


      it('setHours has documented arity', function() {
        expect(funkier.arityOf(funkier.setHours)).to.equal(2);
      });


      it('setHours is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setHours)).to.equal(true);
      });
    });


    describe('setMilliseconds', function() {
      it('setMilliseconds exists', function() {
        expect(funkier).to.have.a.property('setMilliseconds');
      });


      it('funkierJS\'s setMilliseconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setMilliseconds).to.equal(module.setMilliseconds);
      });


      it('setMilliseconds is a function', function() {
        expect(funkier.setMilliseconds).to.be.a('function');
      });


      it('setMilliseconds has documented arity', function() {
        expect(funkier.arityOf(funkier.setMilliseconds)).to.equal(2);
      });


      it('setMilliseconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setMilliseconds)).to.equal(true);
      });
    });


    describe('setMinutes', function() {
      it('setMinutes exists', function() {
        expect(funkier).to.have.a.property('setMinutes');
      });


      it('funkierJS\'s setMinutes is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setMinutes).to.equal(module.setMinutes);
      });


      it('setMinutes is a function', function() {
        expect(funkier.setMinutes).to.be.a('function');
      });


      it('setMinutes has documented arity', function() {
        expect(funkier.arityOf(funkier.setMinutes)).to.equal(2);
      });


      it('setMinutes is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setMinutes)).to.equal(true);
      });
    });


    describe('setMonth', function() {
      it('setMonth exists', function() {
        expect(funkier).to.have.a.property('setMonth');
      });


      it('funkierJS\'s setMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setMonth).to.equal(module.setMonth);
      });


      it('setMonth is a function', function() {
        expect(funkier.setMonth).to.be.a('function');
      });


      it('setMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.setMonth)).to.equal(2);
      });


      it('setMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setMonth)).to.equal(true);
      });
    });


    describe('setProp', function() {
      it('setProp exists', function() {
        expect(funkier).to.have.a.property('setProp');
      });


      it('setProp is a synonym for set', function() {
        expect(funkier.setProp).to.equal(funkier.set);
      });
    });


    describe('setSeconds', function() {
      it('setSeconds exists', function() {
        expect(funkier).to.have.a.property('setSeconds');
      });


      it('funkierJS\'s setSeconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setSeconds).to.equal(module.setSeconds);
      });


      it('setSeconds is a function', function() {
        expect(funkier.setSeconds).to.be.a('function');
      });


      it('setSeconds has documented arity', function() {
        expect(funkier.arityOf(funkier.setSeconds)).to.equal(2);
      });


      it('setSeconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setSeconds)).to.equal(true);
      });
    });


    describe('setTimeSinceEpoch', function() {
      it('setTimeSinceEpoch exists', function() {
        expect(funkier).to.have.a.property('setTimeSinceEpoch');
      });


      it('funkierJS\'s setTimeSinceEpoch is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setTimeSinceEpoch).to.equal(module.setTimeSinceEpoch);
      });


      it('setTimeSinceEpoch is a function', function() {
        expect(funkier.setTimeSinceEpoch).to.be.a('function');
      });


      it('setTimeSinceEpoch has documented arity', function() {
        expect(funkier.arityOf(funkier.setTimeSinceEpoch)).to.equal(2);
      });


      it('setTimeSinceEpoch is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setTimeSinceEpoch)).to.equal(true);
      });
    });


    describe('setUTCDayOfMonth', function() {
      it('setUTCDayOfMonth exists', function() {
        expect(funkier).to.have.a.property('setUTCDayOfMonth');
      });


      it('funkierJS\'s setUTCDayOfMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setUTCDayOfMonth).to.equal(module.setUTCDayOfMonth);
      });


      it('setUTCDayOfMonth is a function', function() {
        expect(funkier.setUTCDayOfMonth).to.be.a('function');
      });


      it('setUTCDayOfMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.setUTCDayOfMonth)).to.equal(2);
      });


      it('setUTCDayOfMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setUTCDayOfMonth)).to.equal(true);
      });
    });


    describe('setUTCFullYear', function() {
      it('setUTCFullYear exists', function() {
        expect(funkier).to.have.a.property('setUTCFullYear');
      });


      it('funkierJS\'s setUTCFullYear is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setUTCFullYear).to.equal(module.setUTCFullYear);
      });


      it('setUTCFullYear is a function', function() {
        expect(funkier.setUTCFullYear).to.be.a('function');
      });


      it('setUTCFullYear has documented arity', function() {
        expect(funkier.arityOf(funkier.setUTCFullYear)).to.equal(2);
      });


      it('setUTCFullYear is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setUTCFullYear)).to.equal(true);
      });
    });


    describe('setUTCHours', function() {
      it('setUTCHours exists', function() {
        expect(funkier).to.have.a.property('setUTCHours');
      });


      it('funkierJS\'s setUTCHours is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setUTCHours).to.equal(module.setUTCHours);
      });


      it('setUTCHours is a function', function() {
        expect(funkier.setUTCHours).to.be.a('function');
      });


      it('setUTCHours has documented arity', function() {
        expect(funkier.arityOf(funkier.setUTCHours)).to.equal(2);
      });


      it('setUTCHours is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setUTCHours)).to.equal(true);
      });
    });


    describe('setUTCMilliseconds', function() {
      it('setUTCMilliseconds exists', function() {
        expect(funkier).to.have.a.property('setUTCMilliseconds');
      });


      it('funkierJS\'s setUTCMilliseconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setUTCMilliseconds).to.equal(module.setUTCMilliseconds);
      });


      it('setUTCMilliseconds is a function', function() {
        expect(funkier.setUTCMilliseconds).to.be.a('function');
      });


      it('setUTCMilliseconds has documented arity', function() {
        expect(funkier.arityOf(funkier.setUTCMilliseconds)).to.equal(2);
      });


      it('setUTCMilliseconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setUTCMilliseconds)).to.equal(true);
      });
    });


    describe('setUTCMinutes', function() {
      it('setUTCMinutes exists', function() {
        expect(funkier).to.have.a.property('setUTCMinutes');
      });


      it('funkierJS\'s setUTCMinutes is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setUTCMinutes).to.equal(module.setUTCMinutes);
      });


      it('setUTCMinutes is a function', function() {
        expect(funkier.setUTCMinutes).to.be.a('function');
      });


      it('setUTCMinutes has documented arity', function() {
        expect(funkier.arityOf(funkier.setUTCMinutes)).to.equal(2);
      });


      it('setUTCMinutes is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setUTCMinutes)).to.equal(true);
      });
    });


    describe('setUTCMonth', function() {
      it('setUTCMonth exists', function() {
        expect(funkier).to.have.a.property('setUTCMonth');
      });


      it('funkierJS\'s setUTCMonth is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setUTCMonth).to.equal(module.setUTCMonth);
      });


      it('setUTCMonth is a function', function() {
        expect(funkier.setUTCMonth).to.be.a('function');
      });


      it('setUTCMonth has documented arity', function() {
        expect(funkier.arityOf(funkier.setUTCMonth)).to.equal(2);
      });


      it('setUTCMonth is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setUTCMonth)).to.equal(true);
      });
    });


    describe('setUTCSeconds', function() {
      it('setUTCSeconds exists', function() {
        expect(funkier).to.have.a.property('setUTCSeconds');
      });


      it('funkierJS\'s setUTCSeconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.setUTCSeconds).to.equal(module.setUTCSeconds);
      });


      it('setUTCSeconds is a function', function() {
        expect(funkier.setUTCSeconds).to.be.a('function');
      });


      it('setUTCSeconds has documented arity', function() {
        expect(funkier.arityOf(funkier.setUTCSeconds)).to.equal(2);
      });


      it('setUTCSeconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.setUTCSeconds)).to.equal(true);
      });
    });


    describe('shallowClone', function() {
      it('shallowClone exists', function() {
        expect(funkier).to.have.a.property('shallowClone');
      });


      it('shallowClone is a synonym for clone', function() {
        expect(funkier.shallowClone).to.equal(funkier.clone);
      });
    });


    describe('slice', function() {
      it('slice exists', function() {
        expect(funkier).to.have.a.property('slice');
      });


      it('funkierJS\'s slice is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.slice).to.equal(module.slice);
      });


      it('slice is a function', function() {
        expect(funkier.slice).to.be.a('function');
      });


      it('slice has documented arity', function() {
        expect(funkier.arityOf(funkier.slice)).to.equal(3);
      });


      it('slice is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.slice)).to.equal(true);
      });
    });


    describe('snd', function() {
      it('snd exists', function() {
        expect(funkier).to.have.a.property('snd');
      });


      it('funkierJS\'s snd is indeed the documented value', function() {
        var module = require('../../lib/components/pair');
        expect(funkier.snd).to.equal(module.snd);
      });


      it('snd is a function', function() {
        expect(funkier.snd).to.be.a('function');
      });


      it('snd has documented arity', function() {
        expect(funkier.arityOf(funkier.snd)).to.equal(1);
      });


      it('snd is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.snd)).to.equal(true);
      });
    });


    describe('some', function() {
      it('some exists', function() {
        expect(funkier).to.have.a.property('some');
      });


      it('funkierJS\'s some is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.some).to.equal(module.some);
      });


      it('some is a function', function() {
        expect(funkier.some).to.be.a('function');
      });


      it('some has documented arity', function() {
        expect(funkier.arityOf(funkier.some)).to.equal(2);
      });


      it('some is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.some)).to.equal(true);
      });
    });


    describe('sort', function() {
      it('sort exists', function() {
        expect(funkier).to.have.a.property('sort');
      });


      it('funkierJS\'s sort is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.sort).to.equal(module.sort);
      });


      it('sort is a function', function() {
        expect(funkier.sort).to.be.a('function');
      });


      it('sort has documented arity', function() {
        expect(funkier.arityOf(funkier.sort)).to.equal(1);
      });


      it('sort is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.sort)).to.equal(true);
      });
    });


    describe('sortWith', function() {
      it('sortWith exists', function() {
        expect(funkier).to.have.a.property('sortWith');
      });


      it('funkierJS\'s sortWith is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.sortWith).to.equal(module.sortWith);
      });


      it('sortWith is a function', function() {
        expect(funkier.sortWith).to.be.a('function');
      });


      it('sortWith has documented arity', function() {
        expect(funkier.arityOf(funkier.sortWith)).to.equal(2);
      });


      it('sortWith is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.sortWith)).to.equal(true);
      });
    });


    describe('split', function() {
      it('split exists', function() {
        expect(funkier).to.have.a.property('split');
      });


      it('funkierJS\'s split is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.split).to.equal(module.split);
      });


      it('split is a function', function() {
        expect(funkier.split).to.be.a('function');
      });


      it('split has documented arity', function() {
        expect(funkier.arityOf(funkier.split)).to.equal(2);
      });


      it('split is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.split)).to.equal(true);
      });
    });


    describe('splitCount', function() {
      it('splitCount exists', function() {
        expect(funkier).to.have.a.property('splitCount');
      });


      it('splitCount is a synonym for splitMax', function() {
        expect(funkier.splitCount).to.equal(funkier.splitMax);
      });
    });


    describe('splitLimit', function() {
      it('splitLimit exists', function() {
        expect(funkier).to.have.a.property('splitLimit');
      });


      it('splitLimit is a synonym for splitMax', function() {
        expect(funkier.splitLimit).to.equal(funkier.splitMax);
      });
    });


    describe('splitMax', function() {
      it('splitMax exists', function() {
        expect(funkier).to.have.a.property('splitMax');
      });


      it('funkierJS\'s splitMax is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.splitMax).to.equal(module.splitMax);
      });


      it('splitMax is a function', function() {
        expect(funkier.splitMax).to.be.a('function');
      });


      it('splitMax has documented arity', function() {
        expect(funkier.arityOf(funkier.splitMax)).to.equal(3);
      });


      it('splitMax is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.splitMax)).to.equal(true);
      });
    });


    describe('splitRegExp', function() {
      it('splitRegExp exists', function() {
        expect(funkier).to.have.a.property('splitRegExp');
      });


      it('splitRegExp is a synonym for regExpSplit', function() {
        expect(funkier.splitRegExp).to.equal(funkier.regExpSplit);
      });
    });


    describe('strictEquals', function() {
      it('strictEquals exists', function() {
        expect(funkier).to.have.a.property('strictEquals');
      });


      it('funkierJS\'s strictEquals is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.strictEquals).to.equal(module.strictEquals);
      });


      it('strictEquals is a function', function() {
        expect(funkier.strictEquals).to.be.a('function');
      });


      it('strictEquals has documented arity', function() {
        expect(funkier.arityOf(funkier.strictEquals)).to.equal(2);
      });


      it('strictEquals is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.strictEquals)).to.equal(true);
      });
    });


    describe('strictInequality', function() {
      it('strictInequality exists', function() {
        expect(funkier).to.have.a.property('strictInequality');
      });


      it('strictInequality is a synonym for strictNotEqual', function() {
        expect(funkier.strictInequality).to.equal(funkier.strictNotEqual);
      });
    });


    describe('strictNotEqual', function() {
      it('strictNotEqual exists', function() {
        expect(funkier).to.have.a.property('strictNotEqual');
      });


      it('funkierJS\'s strictNotEqual is indeed the documented value', function() {
        var module = require('../../lib/components/types');
        expect(funkier.strictNotEqual).to.equal(module.strictNotEqual);
      });


      it('strictNotEqual is a function', function() {
        expect(funkier.strictNotEqual).to.be.a('function');
      });


      it('strictNotEqual has documented arity', function() {
        expect(funkier.arityOf(funkier.strictNotEqual)).to.equal(2);
      });


      it('strictNotEqual is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.strictNotEqual)).to.equal(true);
      });
    });


    describe('strictNotEquals', function() {
      it('strictNotEquals exists', function() {
        expect(funkier).to.have.a.property('strictNotEquals');
      });


      it('strictNotEquals is a synonym for strictNotEqual', function() {
        expect(funkier.strictNotEquals).to.equal(funkier.strictNotEqual);
      });
    });


    describe('stringToInt', function() {
      it('stringToInt exists', function() {
        expect(funkier).to.have.a.property('stringToInt');
      });


      it('funkierJS\'s stringToInt is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.stringToInt).to.equal(module.stringToInt);
      });


      it('stringToInt is a function', function() {
        expect(funkier.stringToInt).to.be.a('function');
      });


      it('stringToInt has documented arity', function() {
        expect(funkier.arityOf(funkier.stringToInt)).to.equal(2);
      });


      it('stringToInt is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.stringToInt)).to.equal(true);
      });
    });


    describe('subtract', function() {
      it('subtract exists', function() {
        expect(funkier).to.have.a.property('subtract');
      });


      it('funkierJS\'s subtract is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.subtract).to.equal(module.subtract);
      });


      it('subtract is a function', function() {
        expect(funkier.subtract).to.be.a('function');
      });


      it('subtract has documented arity', function() {
        expect(funkier.arityOf(funkier.subtract)).to.equal(2);
      });


      it('subtract is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.subtract)).to.equal(true);
      });
    });


    describe('suffixes', function() {
      it('suffixes exists', function() {
        expect(funkier).to.have.a.property('suffixes');
      });


      it('suffixes is a synonym for tails', function() {
        expect(funkier.suffixes).to.equal(funkier.tails);
      });
    });


    describe('sum', function() {
      it('sum exists', function() {
        expect(funkier).to.have.a.property('sum');
      });


      it('funkierJS\'s sum is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.sum).to.equal(module.sum);
      });


      it('sum is a function', function() {
        expect(funkier.sum).to.be.a('function');
      });


      it('sum has documented arity', function() {
        expect(funkier.arityOf(funkier.sum)).to.equal(1);
      });


      it('sum is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.sum)).to.equal(true);
      });
    });


    describe('tail', function() {
      it('tail exists', function() {
        expect(funkier).to.have.a.property('tail');
      });


      it('funkierJS\'s tail is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.tail).to.equal(module.tail);
      });


      it('tail is a function', function() {
        expect(funkier.tail).to.be.a('function');
      });


      it('tail has documented arity', function() {
        expect(funkier.arityOf(funkier.tail)).to.equal(1);
      });


      it('tail is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.tail)).to.equal(true);
      });
    });


    describe('tails', function() {
      it('tails exists', function() {
        expect(funkier).to.have.a.property('tails');
      });


      it('funkierJS\'s tails is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.tails).to.equal(module.tails);
      });


      it('tails is a function', function() {
        expect(funkier.tails).to.be.a('function');
      });


      it('tails has documented arity', function() {
        expect(funkier.arityOf(funkier.tails)).to.equal(1);
      });


      it('tails is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.tails)).to.equal(true);
      });
    });


    describe('take', function() {
      it('take exists', function() {
        expect(funkier).to.have.a.property('take');
      });


      it('funkierJS\'s take is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.take).to.equal(module.take);
      });


      it('take is a function', function() {
        expect(funkier.take).to.be.a('function');
      });


      it('take has documented arity', function() {
        expect(funkier.arityOf(funkier.take)).to.equal(2);
      });


      it('take is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.take)).to.equal(true);
      });
    });


    describe('takeWhile', function() {
      it('takeWhile exists', function() {
        expect(funkier).to.have.a.property('takeWhile');
      });


      it('funkierJS\'s takeWhile is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.takeWhile).to.equal(module.takeWhile);
      });


      it('takeWhile is a function', function() {
        expect(funkier.takeWhile).to.be.a('function');
      });


      it('takeWhile has documented arity', function() {
        expect(funkier.arityOf(funkier.takeWhile)).to.equal(2);
      });


      it('takeWhile is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.takeWhile)).to.equal(true);
      });
    });


    describe('tap', function() {
      it('tap exists', function() {
        expect(funkier).to.have.a.property('tap');
      });


      it('tap is a synonym for extract', function() {
        expect(funkier.tap).to.equal(funkier.extract);
      });
    });


    describe('test', function() {
      it('test exists', function() {
        expect(funkier).to.have.a.property('test');
      });


      it('funkierJS\'s test is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.test).to.equal(module.test);
      });


      it('test is a function', function() {
        expect(funkier.test).to.be.a('function');
      });


      it('test has documented arity', function() {
        expect(funkier.arityOf(funkier.test)).to.equal(2);
      });


      it('test is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.test)).to.equal(true);
      });
    });


    describe('toBaseAndRadix', function() {
      it('toBaseAndRadix exists', function() {
        expect(funkier).to.have.a.property('toBaseAndRadix');
      });


      it('toBaseAndRadix is a synonym for toBaseAndString', function() {
        expect(funkier.toBaseAndRadix).to.equal(funkier.toBaseAndString);
      });
    });


    describe('toBaseAndString', function() {
      it('toBaseAndString exists', function() {
        expect(funkier).to.have.a.property('toBaseAndString');
      });


      it('funkierJS\'s toBaseAndString is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.toBaseAndString).to.equal(module.toBaseAndString);
      });


      it('toBaseAndString is a function', function() {
        expect(funkier.toBaseAndString).to.be.a('function');
      });


      it('toBaseAndString has documented arity', function() {
        expect(funkier.arityOf(funkier.toBaseAndString)).to.equal(2);
      });


      it('toBaseAndString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toBaseAndString)).to.equal(true);
      });
    });


    describe('toCharCode', function() {
      it('toCharCode exists', function() {
        expect(funkier).to.have.a.property('toCharCode');
      });


      it('funkierJS\'s toCharCode is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.toCharCode).to.equal(module.toCharCode);
      });


      it('toCharCode is a function', function() {
        expect(funkier.toCharCode).to.be.a('function');
      });


      it('toCharCode has documented arity', function() {
        expect(funkier.arityOf(funkier.toCharCode)).to.equal(2);
      });


      it('toCharCode is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toCharCode)).to.equal(true);
      });
    });


    describe('toDateString', function() {
      it('toDateString exists', function() {
        expect(funkier).to.have.a.property('toDateString');
      });


      it('funkierJS\'s toDateString is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.toDateString).to.equal(module.toDateString);
      });


      it('toDateString is a function', function() {
        expect(funkier.toDateString).to.be.a('function');
      });


      it('toDateString has documented arity', function() {
        expect(funkier.arityOf(funkier.toDateString)).to.equal(1);
      });


      it('toDateString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toDateString)).to.equal(true);
      });
    });


    describe('toEpochMilliseconds', function() {
      it('toEpochMilliseconds exists', function() {
        expect(funkier).to.have.a.property('toEpochMilliseconds');
      });


      it('funkierJS\'s toEpochMilliseconds is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.toEpochMilliseconds).to.equal(module.toEpochMilliseconds);
      });


      it('toEpochMilliseconds is a function', function() {
        expect(funkier.toEpochMilliseconds).to.be.a('function');
      });


      it('toEpochMilliseconds has documented arity', function() {
        expect(funkier.arityOf(funkier.toEpochMilliseconds)).to.equal(1);
      });


      it('toEpochMilliseconds is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toEpochMilliseconds)).to.equal(true);
      });
    });


    describe('toExponential', function() {
      it('toExponential exists', function() {
        expect(funkier).to.have.a.property('toExponential');
      });


      it('funkierJS\'s toExponential is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.toExponential).to.equal(module.toExponential);
      });


      it('toExponential is a function', function() {
        expect(funkier.toExponential).to.be.a('function');
      });


      it('toExponential has documented arity', function() {
        expect(funkier.arityOf(funkier.toExponential)).to.equal(2);
      });


      it('toExponential is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toExponential)).to.equal(true);
      });
    });


    describe('toFixed', function() {
      it('toFixed exists', function() {
        expect(funkier).to.have.a.property('toFixed');
      });


      it('funkierJS\'s toFixed is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.toFixed).to.equal(module.toFixed);
      });


      it('toFixed is a function', function() {
        expect(funkier.toFixed).to.be.a('function');
      });


      it('toFixed has documented arity', function() {
        expect(funkier.arityOf(funkier.toFixed)).to.equal(2);
      });


      it('toFixed is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toFixed)).to.equal(true);
      });
    });


    describe('toISOString', function() {
      it('toISOString exists', function() {
        expect(funkier).to.have.a.property('toISOString');
      });


      it('funkierJS\'s toISOString is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.toISOString).to.equal(module.toISOString);
      });


      it('toISOString is a function', function() {
        expect(funkier.toISOString).to.be.a('function');
      });


      it('toISOString has documented arity', function() {
        expect(funkier.arityOf(funkier.toISOString)).to.equal(1);
      });


      it('toISOString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toISOString)).to.equal(true);
      });
    });


    describe('toLocaleDateString', function() {
      it('toLocaleDateString exists', function() {
        expect(funkier).to.have.a.property('toLocaleDateString');
      });


      it('funkierJS\'s toLocaleDateString is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.toLocaleDateString).to.equal(module.toLocaleDateString);
      });


      it('toLocaleDateString is a function', function() {
        expect(funkier.toLocaleDateString).to.be.a('function');
      });


      it('toLocaleDateString has documented arity', function() {
        expect(funkier.arityOf(funkier.toLocaleDateString)).to.equal(1);
      });


      it('toLocaleDateString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toLocaleDateString)).to.equal(true);
      });
    });


    describe('toLocaleLowerCase', function() {
      it('toLocaleLowerCase exists', function() {
        expect(funkier).to.have.a.property('toLocaleLowerCase');
      });


      it('funkierJS\'s toLocaleLowerCase is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.toLocaleLowerCase).to.equal(module.toLocaleLowerCase);
      });


      it('toLocaleLowerCase is a function', function() {
        expect(funkier.toLocaleLowerCase).to.be.a('function');
      });


      it('toLocaleLowerCase has documented arity', function() {
        expect(funkier.arityOf(funkier.toLocaleLowerCase)).to.equal(1);
      });


      it('toLocaleLowerCase is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toLocaleLowerCase)).to.equal(true);
      });
    });


    describe('toLocaleString', function() {
      it('toLocaleString exists', function() {
        expect(funkier).to.have.a.property('toLocaleString');
      });


      it('funkierJS\'s toLocaleString is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.toLocaleString).to.equal(module.toLocaleString);
      });


      it('toLocaleString is a function', function() {
        expect(funkier.toLocaleString).to.be.a('function');
      });


      it('toLocaleString has documented arity', function() {
        expect(funkier.arityOf(funkier.toLocaleString)).to.equal(1);
      });


      it('toLocaleString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toLocaleString)).to.equal(true);
      });
    });


    describe('toLocaleUpperCase', function() {
      it('toLocaleUpperCase exists', function() {
        expect(funkier).to.have.a.property('toLocaleUpperCase');
      });


      it('funkierJS\'s toLocaleUpperCase is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.toLocaleUpperCase).to.equal(module.toLocaleUpperCase);
      });


      it('toLocaleUpperCase is a function', function() {
        expect(funkier.toLocaleUpperCase).to.be.a('function');
      });


      it('toLocaleUpperCase has documented arity', function() {
        expect(funkier.arityOf(funkier.toLocaleUpperCase)).to.equal(1);
      });


      it('toLocaleUpperCase is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toLocaleUpperCase)).to.equal(true);
      });
    });


    describe('toLowerCase', function() {
      it('toLowerCase exists', function() {
        expect(funkier).to.have.a.property('toLowerCase');
      });


      it('funkierJS\'s toLowerCase is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.toLowerCase).to.equal(module.toLowerCase);
      });


      it('toLowerCase is a function', function() {
        expect(funkier.toLowerCase).to.be.a('function');
      });


      it('toLowerCase has documented arity', function() {
        expect(funkier.arityOf(funkier.toLowerCase)).to.equal(1);
      });


      it('toLowerCase is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toLowerCase)).to.equal(true);
      });
    });


    describe('toPrecision', function() {
      it('toPrecision exists', function() {
        expect(funkier).to.have.a.property('toPrecision');
      });


      it('funkierJS\'s toPrecision is indeed the documented value', function() {
        var module = require('../../lib/components/maths');
        expect(funkier.toPrecision).to.equal(module.toPrecision);
      });


      it('toPrecision is a function', function() {
        expect(funkier.toPrecision).to.be.a('function');
      });


      it('toPrecision has documented arity', function() {
        expect(funkier.arityOf(funkier.toPrecision)).to.equal(2);
      });


      it('toPrecision is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toPrecision)).to.equal(true);
      });
    });


    describe('toString', function() {
      it('toString exists', function() {
        expect(funkier).to.have.a.property('toString');
      });


      it('funkierJS\'s toString is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.toString).to.equal(module.toString);
      });


      it('toString is a function', function() {
        expect(funkier.toString).to.be.a('function');
      });


      it('toString has documented arity', function() {
        expect(funkier.arityOf(funkier.toString)).to.equal(1);
      });


      it('toString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toString)).to.equal(true);
      });
    });


    describe('toTimeString', function() {
      it('toTimeString exists', function() {
        expect(funkier).to.have.a.property('toTimeString');
      });


      it('funkierJS\'s toTimeString is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.toTimeString).to.equal(module.toTimeString);
      });


      it('toTimeString is a function', function() {
        expect(funkier.toTimeString).to.be.a('function');
      });


      it('toTimeString has documented arity', function() {
        expect(funkier.arityOf(funkier.toTimeString)).to.equal(1);
      });


      it('toTimeString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toTimeString)).to.equal(true);
      });
    });


    describe('toUTCString', function() {
      it('toUTCString exists', function() {
        expect(funkier).to.have.a.property('toUTCString');
      });


      it('funkierJS\'s toUTCString is indeed the documented value', function() {
        var module = require('../../lib/components/date');
        expect(funkier.toUTCString).to.equal(module.toUTCString);
      });


      it('toUTCString is a function', function() {
        expect(funkier.toUTCString).to.be.a('function');
      });


      it('toUTCString has documented arity', function() {
        expect(funkier.arityOf(funkier.toUTCString)).to.equal(1);
      });


      it('toUTCString is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toUTCString)).to.equal(true);
      });
    });


    describe('toUpperCase', function() {
      it('toUpperCase exists', function() {
        expect(funkier).to.have.a.property('toUpperCase');
      });


      it('funkierJS\'s toUpperCase is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.toUpperCase).to.equal(module.toUpperCase);
      });


      it('toUpperCase is a function', function() {
        expect(funkier.toUpperCase).to.be.a('function');
      });


      it('toUpperCase has documented arity', function() {
        expect(funkier.arityOf(funkier.toUpperCase)).to.equal(1);
      });


      it('toUpperCase is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.toUpperCase)).to.equal(true);
      });
    });


    describe('trim', function() {
      it('trim exists', function() {
        expect(funkier).to.have.a.property('trim');
      });


      it('funkierJS\'s trim is indeed the documented value', function() {
        var module = require('../../lib/components/string');
        expect(funkier.trim).to.equal(module.trim);
      });


      it('trim is a function', function() {
        expect(funkier.trim).to.be.a('function');
      });


      it('trim has documented arity', function() {
        expect(funkier.arityOf(funkier.trim)).to.equal(1);
      });


      it('trim is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.trim)).to.equal(true);
      });
    });


    describe('uniq', function() {
      it('uniq exists', function() {
        expect(funkier).to.have.a.property('uniq');
      });


      it('uniq is a synonym for nub', function() {
        expect(funkier.uniq).to.equal(funkier.nub);
      });
    });


    describe('uniqWith', function() {
      it('uniqWith exists', function() {
        expect(funkier).to.have.a.property('uniqWith');
      });


      it('uniqWith is a synonym for nubWith', function() {
        expect(funkier.uniqWith).to.equal(funkier.nubWith);
      });
    });


    describe('unzip', function() {
      it('unzip exists', function() {
        expect(funkier).to.have.a.property('unzip');
      });


      it('funkierJS\'s unzip is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.unzip).to.equal(module.unzip);
      });


      it('unzip is a function', function() {
        expect(funkier.unzip).to.be.a('function');
      });


      it('unzip has documented arity', function() {
        expect(funkier.arityOf(funkier.unzip)).to.equal(1);
      });


      it('unzip is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.unzip)).to.equal(true);
      });
    });


    describe('wrap', function() {
      it('wrap exists', function() {
        expect(funkier).to.have.a.property('wrap');
      });


      it('funkierJS\'s wrap is indeed the documented value', function() {
        var module = require('../../lib/components/fn');
        expect(funkier.wrap).to.equal(module.wrap);
      });


      it('wrap is a function', function() {
        expect(funkier.wrap).to.be.a('function');
      });


      it('wrap has documented arity', function() {
        expect(funkier.arityOf(funkier.wrap)).to.equal(3);
      });


      it('wrap is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.wrap)).to.equal(true);
      });
    });


    describe('xor', function() {
      it('xor exists', function() {
        expect(funkier).to.have.a.property('xor');
      });


      it('funkierJS\'s xor is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.xor).to.equal(module.xor);
      });


      it('xor is a function', function() {
        expect(funkier.xor).to.be.a('function');
      });


      it('xor has documented arity', function() {
        expect(funkier.arityOf(funkier.xor)).to.equal(2);
      });


      it('xor is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.xor)).to.equal(true);
      });
    });


    describe('xorPred', function() {
      it('xorPred exists', function() {
        expect(funkier).to.have.a.property('xorPred');
      });


      it('funkierJS\'s xorPred is indeed the documented value', function() {
        var module = require('../../lib/components/logical');
        expect(funkier.xorPred).to.equal(module.xorPred);
      });


      it('xorPred is a function', function() {
        expect(funkier.xorPred).to.be.a('function');
      });


      it('xorPred has documented arity', function() {
        expect(funkier.arityOf(funkier.xorPred)).to.equal(2);
      });


      it('xorPred is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.xorPred)).to.equal(true);
      });
    });


    describe('zip', function() {
      it('zip exists', function() {
        expect(funkier).to.have.a.property('zip');
      });


      it('funkierJS\'s zip is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.zip).to.equal(module.zip);
      });


      it('zip is a function', function() {
        expect(funkier.zip).to.be.a('function');
      });


      it('zip has documented arity', function() {
        expect(funkier.arityOf(funkier.zip)).to.equal(2);
      });


      it('zip is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.zip)).to.equal(true);
      });
    });


    describe('zipWith', function() {
      it('zipWith exists', function() {
        expect(funkier).to.have.a.property('zipWith');
      });


      it('funkierJS\'s zipWith is indeed the documented value', function() {
        var module = require('../../lib/components/array');
        expect(funkier.zipWith).to.equal(module.zipWith);
      });


      it('zipWith is a function', function() {
        expect(funkier.zipWith).to.be.a('function');
      });


      it('zipWith has documented arity', function() {
        expect(funkier.arityOf(funkier.zipWith)).to.equal(3);
      });


      it('zipWith is curried', function() {
        expect(funkier.arityOf._isCurried(funkier.zipWith)).to.equal(true);
      });
    });
  });


  describe('Exported values', function() {
    var documentedNames;


    beforeEach(function() {
      documentedNames = ['help', 'Err', 'Just', 'Maybe', 'Nothing', 'Ok', 'Pair', 'Result', 'add', 'all', 'and',
         'andPred', 'any', 'append', 'apply', 'arity', 'arityOf', 'asArray', 'bind', 'bindWithContext',
         'bindWithContextAndArity', 'bitwiseAnd', 'bitwiseNot', 'bitwiseOr', 'bitwiseXor', 'callProp',
         'callPropWithArity', 'chr', 'clone', 'compose', 'composeMany', 'composeOn', 'concat', 'constant', 'constant0',
         'copy', 'createObject', 'createObjectWithProps', 'createProp', 'curry', 'curryOwn', 'curryWithArity',
         'deepEqual', 'deepEquals', 'defaultTap', 'defineProperties', 'defineProperty', 'deleteProp', 'descriptors',
         'div', 'divide', 'drop', 'dropWhile', 'each', 'either', 'element', 'elementWith', 'equals', 'even', 'every',
         'exp', 'extend', 'extendOwn', 'extract', 'extractOrDefault', 'fMap', 'filter', 'first', 'firstMatch',
         'firstMatchFrom', 'flatten', 'flattenMap', 'flip', 'fmap', 'foldl', 'foldl1', 'foldr', 'foldr1', 'fst',
         'getCurrentTimeString', 'getDayOfMonth', 'getDayOfWeek', 'getErrValue', 'getFullYear', 'getHours', 'getIndex',
         'getJustValue', 'getMilliseconds', 'getMinutes', 'getMonth', 'getOkValue', 'getOwnPropertyDescriptor',
         'getOwnPropertyNames', 'getSeconds', 'getTimezoneOffset', 'getType', 'getUTCDayOfMonth', 'getUTCDayOfWeek',
         'getUTCFullYear', 'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth', 'getUTCSeconds',
         'greaterThan', 'greaterThanEqual', 'gt', 'gte', 'hasOwnProperty', 'hasProperty', 'hasType', 'head', 'id',
         'init', 'inits', 'instanceOf', 'intersperse', 'is', 'isArray', 'isBoolean', 'isEmpty', 'isErr', 'isJust',
         'isMaybe', 'isNothing', 'isNull', 'isNumber', 'isObject', 'isOk', 'isPair', 'isPrototypeOf', 'isRealObject',
         'isResult', 'isString', 'isUndefined', 'join', 'keyValues', 'keys', 'last', 'leftShift', 'length', 'lessThan',
         'lessThanEqual', 'log', 'lt', 'lte', 'makeDateFromMilliseconds', 'makeDateFromString', 'makeDayDate',
         'makeHourDate', 'makeMaybeReturner', 'makeMillisecondDate', 'makeMinuteDate', 'makeMonthDate',
         'makeResultReturner', 'makeSecondDate', 'map', 'matches', 'matchesFrom', 'max', 'maximum', 'maybeCreate',
         'maybeDelete', 'maybeExtract', 'maybeModify', 'maybeModifyProp', 'maybeSet', 'maybeSetProp', 'maybeTap',
         'min', 'minimum', 'modify', 'modifyProp', 'multiply', 'not', 'notEqual', 'notEquals', 'notPred', 'nub',
         'nubWith', 'objectCurry', 'objectCurryWithArity', 'occurrences', 'occurrencesWith', 'odd', 'or', 'orPred',
         'ord', 'parseInt', 'parseIntInBase', 'permuteLeft', 'permuteRight', 'plus', 'post', 'pow', 'pre', 'prefixes',
         'prepend', 'product', 'range', 'rangeStep', 'rangeStride', 'reduce', 'reduce1', 'reduceRight', 'reduceRight1',
         'regExpSplit', 'regExpSplitCount', 'regExpSplitLimit', 'regExpSplitMax', 'rem', 'replicate', 'reverse',
         'rightShift', 'rightShiftZero', 'rotateLeft', 'rotateRight', 'safeCreateProp', 'safeDeleteProp',
         'safeExtract', 'safeModify', 'safeModifyProp', 'safeSet', 'safeSetProp', 'safeTap', 'second', 'sectionLeft',
         'sectionRight', 'set', 'setDayOfMonth', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes',
         'setMonth', 'setProp', 'setSeconds', 'setTimeSinceEpoch', 'setUTCDayOfMonth', 'setUTCFullYear', 'setUTCHours',
         'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'shallowClone', 'slice', 'snd', 'some',
         'sort', 'sortWith', 'split', 'splitCount', 'splitLimit', 'splitMax', 'splitRegExp', 'strictEquals',
         'strictInequality', 'strictNotEqual', 'strictNotEquals', 'stringToInt', 'subtract', 'suffixes', 'sum', 'tail',
         'tails', 'take', 'takeWhile', 'tap', 'test', 'toBaseAndRadix', 'toBaseAndString', 'toCharCode',
         'toDateString', 'toEpochMilliseconds', 'toExponential', 'toFixed', 'toISOString', 'toLocaleDateString',
         'toLocaleLowerCase', 'toLocaleString', 'toLocaleUpperCase', 'toLowerCase', 'toPrecision', 'toString',
         'toTimeString', 'toUTCString', 'toUpperCase', 'trim', 'uniq', 'uniqWith', 'unzip', 'wrap', 'xor', 'xorPred',
         'zip', 'zipWith'];
    });


    Object.keys(funkier).forEach(function(k) {
      var prop = funkier[k];
      if (k[0] === '_' || prop === null ||
          (typeof(prop) !== 'object' && typeof(prop) !== 'function'))
        return;

      it(k + ' is documented', function() {
        expect(documentedNames.indexOf(k)).to.not.equal(-1);
      });
    });
  });
})();

},{"../../lib/components/array":10,"../../lib/components/base":11,"../../lib/components/categories":12,"../../lib/components/curry":13,"../../lib/components/date":14,"../../lib/components/fn":15,"../../lib/components/logical":16,"../../lib/components/maths":17,"../../lib/components/maybe":18,"../../lib/components/object":19,"../../lib/components/pair":20,"../../lib/components/result":21,"../../lib/components/string":22,"../../lib/components/types":23,"../../lib/funkier":25,"chai":64}],47:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var array = require('../../lib/components/array');

  var curryModule = require('../../lib/components/curry');
  var arityOf = curryModule.arityOf;

  var base = require('../../lib/components/base');
  var id = base.id;
  var constant = base.constant;

  var pair = require('../../lib/components/pair');
  var Pair = pair.Pair;
  var isPair = pair.isPair;
  var fst = pair.fst;
  var snd = pair.snd;

  var types = require('../../lib/components/types');
  var isArray = types.isArray;
  var strictEquals = types.strictEquals;

  var alwaysTrue = base.constant(true);
  var alwaysFalse = base.constant(false);

  var testingUtilities = require('./testingUtilities');
  var checkModule = testingUtilities.checkModule;
  var checkFunction = testingUtilities.checkFunction;
  var makeArrayLike = testingUtilities.makeArrayLike;


  describe('Array', function() {
    var expectedObjects = [];
    var expectedFunctions = ['append', 'concat', 'copy', 'drop', 'dropWhile', 'each', 'element', 'elementWith', 'every',
                             'filter', /*'find', 'findFrom', 'findFromWith', 'findWith', */ 'flatten', 'flattenMap', 'foldl',
                             'foldl1', 'foldr', 'foldr1', 'getIndex', 'head', 'init', 'inits', /*'insert',*/ 'intersperse',
                             'isEmpty', 'join', 'last', 'length', 'map', 'maximum', 'minimum', 'nub', 'nubWith',
                             'occurrences', 'occurrencesWith', 'prepend', 'product', 'range', 'rangeStride', /*'remove',
                             'removeAll', 'removeAllWith', 'removeOne', 'removeOneWith', 'replace', 'replaceAll',
                             'replaceAllWith', 'replaceOne', 'replaceOneWith',*/ 'replicate', 'reverse', 'slice', 'some',
                             'sort', 'sortWith', 'sum', 'tail', 'tails', 'take', 'takeWhile', 'unzip', 'zip', 'zipWith'];
    checkModule('array', array, expectedObjects, expectedFunctions);


    /*
     *******************************************************************************************************************
     *                                                                                                                 *
     * There is a lot of test generation in this file, in order to avoid almost-the-same tests for arrays, strings and *
     * array likes. Various helper functions associated with this test generation follow.                              *
     *                                                                                                                 *
     *******************************************************************************************************************
     */

    /*
     * Several functions need to auto-generate tests for the empty values. Let's not replicate that logic all over the
     * place.
     *
     */

    var addEmptyTests = function(testAdder) {
      testAdder('empty array', []);
      testAdder('empty arrayLike', makeArrayLike());
      testAdder('empty string', '');
    };


    /*
     * Several functions should throw when invoked with  empty arrays/strings
     *
     */

    var addThrowsOnEmptyTests = function(fnUnderTest, args) {
      var addOne = function(message, data) {
        it('Throws for empty ' + message, function() {
          var fn = function() {
            fnUnderTest.apply(null, args.concat([data]));
          };

          expect(fn).to.throw(TypeError);
        });
      };


      addOne('arrays', []);
      addOne('arrayLikes', makeArrayLike());
      addOne('strings', '');
    };


    /*
     * Various test generation functions need a clean copy of their test data, to ensure there is no interdependence
     * between individual tests.
     *
     */

    var sliceIfNecessary = function(originalData) {
      if (typeof(originalData) === 'string')
        return originalData;

      return originalData.slice();
    };


    /*
     * Several functions expect the first argument to be a function that should be always be called with a specific
     * number of arguments.
     *
     */

    var addFuncCalledWithSpecificArityTests = function(fnUnderTest, requiredArgs, argsBetween, arrayOnly) {
      // None of the functions in array need more than 2 arguments: throw at test generation stage if I get
      // this wrong
      if (requiredArgs > 2)
        throw new Error('Incorrect test: addFuncCalledWithSpecificArityTests called with ' + requiredArgs);

      argsBetween = argsBetween || [];
      arrayOnly = arrayOnly || false;

      var addTestsForType = function(type, originalData) {
        it('Function called with correct number of arguments when called with ' + type, function() {
          var allArgs = [];
          var f;

          if (requiredArgs === 1) {
            f = function(x) {
              var args = [].slice.call(arguments);
              allArgs.push(args);
            };
          } else {
            f = function(x, y) {
              var args = [].slice.call(arguments);
              allArgs.push(args);
            };
          }

          fnUnderTest.apply(null, [f].concat(argsBetween).concat([originalData]));
          var result = allArgs.every(function(arr) {
            return arr.length === requiredArgs;
          });

          expect(result).to.equal(true);
        });
      };


      addTestsForType('array', [1, 2, 3]);
      addTestsForType('arrayLike', makeArrayLike(2, 3, 4, 5));
      if (!arrayOnly)
        addTestsForType('string', 'abc');
    };


    /*
     * Several functions expect that the function being tested should be called with each element of the given object,
     * in order.
     *
     */

    var addCalledWithEveryMemberTests = function(fnUnderTest, argsBetween, isArity2, isRTL, skipsFirst) {
      argsBetween = argsBetween || [];

      // only the fold* functions have arity 2
      isArity2 = isArity2 || false;
      // only the foldr* functions operate RTL
      isRTL = isRTL || false;
      // only the fold*1 functions skip the first element
      skipsFirst = skipsFirst || false;

      var addTestsForType = function(type, originalData) {
        it('Called the correct number of times for ' + type, function() {
          var data = sliceIfNecessary(originalData);

          var allArgs = [];
          var f = function(x) {
            allArgs.push(x);
          };

          if (isArity2) {
            f = function(x, y) {
              // In the fold* functions, the current element is the second parameter
              allArgs.push(y);
            };
          }

          fnUnderTest.apply(null, [f].concat(argsBetween).concat([data]));

          // allArgs now contains each element that our function was called with
          expect(allArgs.length).to.equal(skipsFirst ? originalData.length - 1 : originalData.length);
        });


        it('Called with every element of ' + type, function() {
          var data = sliceIfNecessary(originalData);

          var allArgs = [];
          var f = function(x) {
            allArgs.push(x);
          };

          if (isArity2) {
            f = function(x, y) {
              // In the fold* functions, the current element is the second parameter
              allArgs.push(y);
            };
          }

          fnUnderTest.apply(null, [f].concat(argsBetween).concat([data]));

          // allArgs now contains each element that our function was called with
          originalData = splitIfNecessary(originalData);
          var numElems = originalData.length - 1;

          var result = originalData.every(function(elem, i) {
            // The fold*1 functions should have 1 call fewer
            if (skipsFirst) {
              if ((isRTL && i === numElems) || (!isRTL && i === 0))
                return true;
            }

            // Where should this element be in allArgs?
            var index = i;
            if (skipsFirst) {
              if (isRTL)
                index += 1;
              else
                index -= 1;
            }

            return allArgs[isRTL ? numElems - index : index] === elem;
          });

          expect(result).to.equal(true);
        });
      };


      addTestsForType('array', [1, 2, 3]);
      addTestsForType('arrayLike', makeArrayLike(2, 3, 4, 5));
      addTestsForType('string', 'abc');
    };


    /*
     * Several functions should yield the empty array/string when called with an empty array/string.
     *
     */

    var addReturnsEmptyOnEmptyTests = function(fnUnderTest, argsBefore, alwaysArray) {
      alwaysArray = alwaysArray || false;

      it('Returns empty array when called with empty array', function() {
        var original = [];
        var result = fnUnderTest.apply(null, argsBefore.concat([original]));

        expect(result).to.not.equal(original);
        expect(result).to.deep.equal([]);
      });


      it('Returns empty array when called with empty arrayLike', function() {
        var original = makeArrayLike();
        var result = fnUnderTest.apply(null, argsBefore.concat([original]));

        expect(result).to.not.equal(original);
        expect(result).to.deep.equal([]);
      });


      it('Returns empty ' + (alwaysArray ? 'array' : 'string') + ' when called with empty string', function() {
        var original = '';
        var result = fnUnderTest.apply(null, argsBefore.concat([original]));

        expect(result).to.deep.equal(alwaysArray ? [] : '');
      });
    };


    /*
     * Several functions expect the return type to be the same as the final argument.
     *
     */

    var addReturnsSameTypeTests = function(fnUnderTest, argsBefore, arrayOnly) {
      arrayOnly = arrayOnly || false;

      var addOne = function(type, data) {
        it('Returns ' + (type === 'arrayLike' ? 'array' : type) + ' when called with ' + type, function() {
          var result = fnUnderTest.apply(null, argsBefore.concat([data]));

          if (type !== 'string')
            expect(isArray(result)).to.equal(true);
          else
            expect(typeof(result)).to.equal('string');
        });
      };

      addOne('array', [{foo: 1}]);
      addOne('arrayLike', makeArrayLike(1, 2));
      if (!arrayOnly)
        addOne('string', 'abc');
    };


    /*
     * Several functions expect that the result should be distinct from the original value, not harming the original
     * value in any way.
     *
     */

    var addNoModificationOfOriginalTests = function(fnUnderTest, argsBefore) {
      var addOne = function(type, data) {
        it('Doesn\'t modify original ' + type + ' value', function() {
          // Take a copy before we make the call, so that we have something to compare to
          var copy = sliceIfNecessary(data);
          var fnResult = fnUnderTest.apply(null, argsBefore.concat([data]));

          var different = fnResult !== data;
          var sameLength = data.length === copy.length;

          data = splitIfNecessary(data);
          var sameEntries = data.every(function(v, i) {
            return copy[i] === v;
          });

          expect(sameLength && sameEntries && different).to.equal(true);
        });
      };


      addOne('array', [{foo: 1}, {foo: 2}, {bar: 3}]);
      addOne('arrayLike', makeArrayLike({foo: 1}, {foo: 2}, {bar: 3}));
    };


    /*
     * Many functions split string arguments in order to run a test using every.
     *
     */

    var splitIfNecessary = function(val) {
      if (typeof(val) === 'string')
        val = val.split('');

      // Turn arrayLikes into real arrays
      if (!isArray(val))
        return [].slice.call(val);

      return val;
    };


    /*
     * Several functions need to check "equality" where one value is an array and the other an arrayLike.
     *
     */

    var valuesEqual = function(source, copy) {
      var sameLength = source.length === copy.length;

      source = splitIfNecessary(source);
      var sameValues = source.every(function(val, i) {
        return copy[i] === val;
      });

      return sameLength && sameValues;
    };



    /*
     * Several functions should return a value of the same length.
     *
     */

    var addSameLengthTest = function(fnUnderTest, message, otherArgs, originalData, modifier) {
      modifier = modifier || 0;

      it('Result has same length for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var length = fnUnderTest.apply(null, otherArgs.concat([data])).length;

        expect(length).to.equal(data.length + modifier);
      });
    };


    // Many of the predicate functions on strings are tested with the following predicate
    var isDigit = function(x) {return x >= '0' && x <= '9';};

    // and likewise the array tests regularly use this test
    var fooIs42 = function(x) {return x.foo === 42;};


    /*
     *******************************************************************************************************************
     *                                                                                                                *
     *                                               End of test generation helpers                                   *
     *                                                                                                                *
     ******************************************************************************************************************
     */


    var lengthSpec = {
      name: 'length',
      restrictions: [['arrayLike']],
      validArguments: [[[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(lengthSpec, array.length, function(length) {
      var addOne = function(message, data) {
        it('Works ' + message, function() {
          expect(length(data)).to.equal(data.length);
        });
      };


      addEmptyTests(addOne);
      addOne('arrays (1)', [1]);
      addOne('arrays (2)', [2, 3]);
      addOne('arrayLikes (1)', makeArrayLike(1));
      addOne('arrayLikes (2)', makeArrayLike(2, 3));
      addOne('strings (1)', 'a');
      addOne('strings (2)', 'bcd');
    });


    var getIndexSpec = {
      name: 'getIndex',
      restrictions: [['natural'], ['arrayLike']],
      validArguments: [[1], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(getIndexSpec, array.getIndex, function(getIndex) {
      addThrowsOnEmptyTests(getIndex, [0]);


      var addTests = function(originalData) {
        // The generated tests assume a length of 3. Sanity-check my data.
        if (originalData.length < 3)
          throw new Error('Test generation for getIndex requires test data of length ' + originalData.length);

        var type = typeof(originalData) === 'string' ? 'string' : (isArray(originalData) ? 'array' : 'arrayLike');


        it('Works for ' + type + ' (1)', function() {
          var data = sliceIfNecessary(originalData);
          var result = getIndex(0, data);

          expect(result).to.equal(data[0]);
        });


        it('Works for ' + type + ' (2)', function() {
          var data = sliceIfNecessary(originalData);
          var result = getIndex(2, data);

          expect(result).to.equal(data[2]);
        });


        it('Throws when ' + type + ' indices outside range', function() {
          var data = sliceIfNecessary(originalData);
          var fn = function() {
            getIndex(data.length, data);
          };

          expect(fn).to.throw(TypeError);
        });
      };


      addTests([1, 7, 0, 42]);
      addTests(makeArrayLike(4, 3, 2, 1));
      addTests('funkier');
    });


    /*
     * The tests for head and tail are very similar, and can be generated
     *
     */

    var makeElementSelectorTest = function(desc, fnUnderTest, isFirst) {
      describe(desc, function() {
        addThrowsOnEmptyTests(fnUnderTest, []);

        var addOne = function(message, data) {
          it('Works for ' + message, function() {
            var result = fnUnderTest(data);

            expect(result).to.equal(data[isFirst ? 0 : data.length - 1]);
          });
        };


        addOne('arrays (1)', [1]);
        addOne('arrays (2)', [2, 3]);
        addOne('arrayLikes (1)', makeArrayLike(4));
        addOne('arrayLikes (2)', makeArrayLike(5, 6));
        addOne('strings (1)', 'a');
        addOne('strings (2)', 'funkier');
      });
    };


    makeElementSelectorTest('head', array.head, true);
    makeElementSelectorTest('last', array.last, false);


    var replicateSpec = {
      name: 'replicate',
      restrictions: [['natural'], []],
      validArguments: [[1], ['a']]
    };


    checkFunction(replicateSpec, array.replicate, function(replicate) {
      var addTests = function(message, count, data) {
        it('Returns array ' + message, function() {
          var replicated = replicate(count, data);

          expect(isArray(replicated)).to.equal(true);
        });


        it('Returned array has correct length ' + message, function() {
          var result = replicate(count, data);

          expect(result.length).to.equal(count);
        });


        it('Returned array\'s elements strictly equal given value ' + message, function() {
          var allEqual = replicate(count, data).every(function(e) {
            return e === data;
          });

          expect(allEqual).to.equal(true);
        });
      };


      addTests('(1)', 1, 'a');
      addTests('(2)', 10, {});
      addTests('when count is zero', 0, 2);
    });


    var mapSpec = {
      name: 'map',
      restrictions: [['function: minarity 1'], ['arrayLike']],
      validArguments: [[function() {}], [['a'], 'a', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(mapSpec, array.map, function(map) {
      addFuncCalledWithSpecificArityTests(map, 1);
      addNoModificationOfOriginalTests(map, [id]);
      addCalledWithEveryMemberTests(map);
      addReturnsEmptyOnEmptyTests(map, [function(x) { return 42; }], true);


      var addTests = function(message, f, originalData) {
        addSameLengthTest(map, message, [f], originalData);


        it('Returns an array for ', function() {
          var data = sliceIfNecessary(originalData);
          var mapped = map(f, data);

          expect(isArray(mapped)).to.equal(true);
        });


        it('Returned array correct for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = map(f, data).every(function(val, i) {
            return val === f(data[i]);
          });

          expect(result).to.equal(true);
        });
      };


      addTests('array (1)', id, [1, true, null, undefined]);
      addTests('array (2)', function(x) {return x + 1;}, [2, 3, 4]);
      addTests('arrayLike (1)', id, makeArrayLike({}, {}));
      addTests('arrayLike (2)', function(x) {return x - 1;}, makeArrayLike(5, 6, 7));
      addTests('strings (1)', function(x) {return x.toUpperCase();}, 'funkier');
      addTests('strings (2)', function(x) {return x.charCodeAt(0);}, 'abc');


      it('Array contains partially applied functions if supplied function arity > 1', function() {
        var uncurried = function(x, y) {return x + y;};
        var mapped = map(uncurried, [1, 2]);
        var allPartiallyApplied = mapped.every(function(f) {
          return typeof(f) === 'function' && arityOf(f) === 1;
        });

        expect(allPartiallyApplied).to.equal(true);
      });
    });


    var eachSpec = {
      name: 'each',
      restrictions: [['function'], ['arrayLike']],
      validArguments: [[function() {}], [['a'], 'a', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(eachSpec, array.each, function(each) {
      addFuncCalledWithSpecificArityTests(each, 1);
      addNoModificationOfOriginalTests(each, [id]);
      addCalledWithEveryMemberTests(each);


      var addOne = function(message, data) {
        it('Returns undefined when called with ' + data, function() {
          var result = each(id, data);

          expect(result).to.equal(undefined);
        });
      };


      addOne('array', [1, true, null]);
      addOne('arrayLike', makeArrayLike(2, 3, 4));
      addOne('string', 'abc');
    });


    var filterSpec = {
      name: 'filter',
      restrictions: [['function: arity 1'], ['arrayLike']],
      validArguments: [[function(x) {}], [['a'], 'a', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(filterSpec, array.filter, function(filter) {
      addReturnsSameTypeTests(filter, [alwaysTrue]);
      addFuncCalledWithSpecificArityTests(filter, 1);
      addCalledWithEveryMemberTests(filter);
      addNoModificationOfOriginalTests(filter, [alwaysTrue]);
      addReturnsEmptyOnEmptyTests(filter, [alwaysTrue]);


      var addTests = function(message, f, originalData, expectedResult, isArrayLike) {
        isArrayLike = isArrayLike || false;


        var addLengthAndValuesTests = function(countMessage, fn, expected) {
          it('Returned value correct for ' + message + ' ' + countMessage, function() {
            var data = sliceIfNecessary(originalData);
            var filtered = filter(fn, data);

            expect(filtered).to.deep.equal(expected);
          });
        };


        // We test filter returns correct arrays for 3 different functions:
        //  - alwaysTrue: this should result in a copy of the original value
        //  - alwaysFalse: this should result in an empty value
        //  - the custom function passed in to this test generator
        addLengthAndValuesTests('(1)', alwaysTrue, isArrayLike ? [].slice.call(originalData) : originalData);
        addLengthAndValuesTests('(2)', alwaysFalse, typeof(originalData) === 'string' ? '' : []);
        addLengthAndValuesTests('(3)', f, expectedResult);
      };


      addTests('for an array', function(x) {return x % 2 === 0;}, [1, 2, 3, 4], [2, 4]);
      addTests('for an arrayLike', function(x) {return x > 10;}, makeArrayLike(11, 3, 2, 20, 42, 1), [11, 20, 42], true);
      addTests('for a string', function(c) {return c !== 'a';}, 'banana', 'bnn');


      it('Elements of returned values strictly equal those from the original value', function() {
        var a = [{}, {}, {}, {}];
        var f = alwaysTrue;
        var allStrictEqual = filter(f, a).every(function(e, i) {
          return e === a[i];
        });

        expect(allStrictEqual).to.equal(true);
      });
    });


    /*
     * There is a large amount of commonality in the various fold* tests. We wrap up this commonality here.
     *
     */

    var addFoldTests = function(spec, fnUnderTest, specificTests, is1Func, isRTL) {
      var betweenArgs = is1Func ? [] : [0];


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        addFuncCalledWithSpecificArityTests(fnUnderTest, 2);
        addCalledWithEveryMemberTests(fnUnderTest, betweenArgs, true, isRTL, is1Func);


        var addCalledWithAccumulatorTest = function(type, originalData) {
          it('Function called with correct accumulator for ' + type, function() {
            // We save each accumulator our fold function is called with
            var data = sliceIfNecessary(originalData);
            var accumulators = [];

            var count = 1;
            var f = function(acc, current) {
              accumulators.push(acc);
              return count++;
            };

            var fnArgs = is1Func ? [f, data] : [f, 0, data];
            fnUnderTest.apply(null, fnArgs);

            // Calculate the first element of the array/string for fold*1 tests
            var first = data[isRTL ? data.length - 1 : 0];

            var accumulatorsCorrect = accumulators.every(function(acc, i) {
              if (is1Func && i === 0)
                return acc === first;

              return acc === i;
            });

            expect(accumulatorsCorrect).to.equal(true);
          });
        };


        var addInitialOnEmptyTests = function(message, originalData) {
          // fold(l|r) should return the 'initial' parameter if the value to be folded is empty
          // We test with two different values to confirm the return value is not fixed

          var addOneInitialTest = function(count, initValue) {
            it('Returns initial value when called with empty ' + message + ' ' + count, function() {
              var data = sliceIfNecessary(originalData);
              var result = fnUnderTest(function(x, y) {return 3;}, initValue, data);

              expect(result).to.deep.equal(initValue);
            });
          };


          addOneInitialTest('(1)', {});
          addOneInitialTest('(2)', 'z');
        };


        addCalledWithAccumulatorTest([1, 2, 3], 'array');
        addCalledWithAccumulatorTest(makeArrayLike(2, 3, 4), 'arrayLike');
        addCalledWithAccumulatorTest('123', 'string');


        if (is1Func)
          addThrowsOnEmptyTests(fnUnderTest, function(x, y) {return 3;});
        else
          addEmptyTests(addInitialOnEmptyTests);


        specificTests.forEach(function(testData) {
          var message = testData.message;
          var args = testData.args;
          var expected = testData.expected;


          it('Works correctly for ' + message, function() {
            var result = fnUnderTest.apply(null, args);

            expect(result).to.equal(expected);
          });
        });
      });
    };


    var foldlSpec = {
      name: 'foldl',
      restrictions: [['function: arity 2'], [], ['arrayLike']],
      validArguments: [[function(x, y) {}], [0], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    var foldlTests = [
      {message: 'array (1)', args: [function(x, y) {return x + y;}, 4, [1, 2, 3]], expected: 4 + 1 + 2 + 3},
      {message: 'array (2)', args: [function(x, y) {return x - y;}, 0, [1, 2, 3]], expected: -1 - 2 - 3},
      {message: 'arrayLike (1)', args: [function(x, y) {return x + y;}, 6, makeArrayLike(3, 4, 5)],
       expected: 6 + 3 + 4 + 5},
      {message: 'arrayLike (2)', args: [function(x, y) {return x - y;}, 0, makeArrayLike(5, 6, 7)],
       expected: 0 - 5 - 6 - 7},
      {message: 'string (1)', args: [function(x, y) {return x + y;}, '', 'abc'], expected: '' + 'a' + 'b' + 'c'},
      {message: 'string (2)', args: [function(x, y) {return x + y;}, 'z', 'abc'], expected: 'z' + 'a' + 'b' + 'c'}
    ];


    addFoldTests(foldlSpec, array.foldl, foldlTests, false, false);


    var foldl1Spec = {
      name: 'foldl1',
      restrictions: [['function: arity 2'], ['arrayLike']],
      validArguments: [[function(x, y) {}], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    var foldl1Tests = [
      {message: 'array (1)', args: [function(x, y) {return x + y;}, [1, 2, 3]], expected: 1 + 2 + 3},
      {message: 'array (2)', args: [function(x, y) {return x - y;}, [1, 2, 3]], expected: 1 - 2 - 3},
      {message: 'arrayLike (1)', args: [function(x, y) {return x + y;}, makeArrayLike(3, 4, 5)], expected: 3 + 4 + 5},
      {message: 'arrayLike (2)', args: [function(x, y) {return x - y;}, makeArrayLike(5, 6, 7)], expected: 5 - 6 - 7},
      {message: 'string (1)', args: [function(x, y) {return x + y;}, 'abc'], expected: 'a' + 'b' + 'c'},
      {message: 'string (2)', args: [function(x, y) {return y + x;}, 'abc'], expected: 'c' + 'b' + 'a'}
    ];


    addFoldTests(foldl1Spec, array.foldl1, foldl1Tests, true, false);


    var foldrSpec = {
      name: 'foldr',
      restrictions: [['function: arity 2'], [], ['arrayLike']],
      validArguments: [[function(x, y) {}], [0], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    var foldrTests = [
      {message: 'array (1)', args: [function(x, y) {return x + y;}, 4, [1, 2, 3]], expected: 4 + 3 + 2 + 1},
      {message: 'array (2)', args: [function(x, y) {return x - y;}, 0, [1, 2, 3]], expected: -3 - 2 - 1},
      {message: 'arrayLike (1)', args: [function(x, y) {return x + y;}, 6, makeArrayLike(3, 4, 5)],
       expected: 6 + 5 + 4 + 3},
      {message: 'arrayLike (2)', args: [function(x, y) {return x - y;}, 0, makeArrayLike(5, 6, 7)],
       expected:  0 - 5 - 6 - 7},
      {message: 'string (1)', args: [function(x, y) {return x + y;}, '', 'abc'], expected: '' + 'c' + 'b' + 'a'},
      {message: 'string (2)', args: [function(x, y) {return y + x;}, 'z', 'abc'], expected: 'a' + 'b' + 'c' + 'z'}
    ];


    addFoldTests(foldrSpec, array.foldr, foldrTests, false, true);


    var foldr1Spec = {
      name: 'foldr1',
      restrictions: [['function: arity 2'], ['arrayLike']],
      validArguments: [[function(x, y) {}], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    var foldr1Tests = [
      {message: 'array (1)', args: [function(x, y) {return x + y;}, [1, 2, 3]], expected: 3 + 2 + 1},
      {message: 'array (2)', args: [function(x, y) {return x - y;}, [1, 2, 3]], expected: 3 - 2 - 1},
      {message: 'arrayLike (1)', args: [function(x, y) {return x + y;}, makeArrayLike(3, 4, 5)], expected: 5 + 4 + 3},
      {message: 'arrayLike (2)', args: [function(x, y) {return x - y;}, makeArrayLike(5, 6, 7)], expected: 7 - 6 - 5},
      {message: 'string (1)', args: [function(x, y) {return x + y;}, 'abc'], expected: 'c' + 'b' + 'a'},
      {message: 'string (2)', args: [function(x, y) {return y + x;}, 'abc'], expected: 'a' + 'b' + 'c'}
    ];


    addFoldTests(foldr1Spec, array.foldr1, foldr1Tests, true, true);


    /*
     * This function factors out commonality between every/some tests.
     *
     */

    var makeArrayBooleanTest = function(desc, fnUnderTest, trigger) {
      var spec = {
        name: desc,
        restrictions: [['function: arity 1'], ['arrayLike']],
        validArguments: [[function(x) {}], [[1, 2], 'ab', makeArrayLike(2, 3, 4)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        var okVal = !trigger;
        addFuncCalledWithSpecificArityTests(fnUnderTest, 1);


        var addTests = function(type, num, originalData) {
          it('Stops prematurely when called with ' + type + ' and ' + trigger + ' returned (' + num + ')', function() {
            var data = sliceIfNecessary(originalData);

            // We use a function that is expected to return the short-circuit trigger after length - 2 calls. If the
            // function under tests works correctly, this function should not be called again, and calls should still
            // equal data.length - 2

            var calls = 0;
            var f = function(x) {
              calls += 1;
              if (calls === data.length - 2)
                return trigger;
              return okVal;
            };

            fnUnderTest(f, data);

            expect(calls).to.equal(data.length - 2);
          });


          it('Called with correct values when called with ' + type + ' and ' + trigger + ' returned (' + num + ')',
             function() {
            var data = sliceIfNecessary(originalData);

            // This function ensures the function under test traverses the array in order, starting at element 0
            // equal data.length - 2
            var vals = [];
            var calls = 0;
            var f = function(x) {
              calls += 1;
              vals.push(x);
              if (calls === data.length - 1)
                return trigger;
              return okVal;
            };

            fnUnderTest(f, data);
            var result = vals.every(function(elem, i) {
              return data[i] === elem;
            });

            expect(result).to.equal(true);
          });


          it('Returns correct value when called with ' + type + ' and ' + trigger + ' returned (' + num + ')',
             function() {
            var data = sliceIfNecessary(originalData);

            var calls = 0;
            var f = function(x) {
              calls += 1;
              if (calls === data.length - 1)
                return trigger;
              return okVal;
            };

            var result = fnUnderTest(f, data);

            expect(result).to.equal(trigger);
          });


          it('Called with all values when called with ' + type + ' and ' + okVal + ' returned (' + num + ')',
             function() {
            var data = sliceIfNecessary(originalData);

            // If the trigger is not returned, the entire value should be iterated over
            var calls = 0;
            var f = function(x) {
              calls += 1;
              return okVal;
            };

            fnUnderTest(f, data);

            expect(calls).to.equal(data.length);
          });


          it('Called with correct values when called with ' + type + ' and ' + okVal + ' returned (' + num + ')',
             function() {
            var data = sliceIfNecessary(originalData);

            var vals = [];
            var calls = 0;
            var f = function(x) {
              vals.push(x);
              calls += 1;
              return okVal;
            };

            fnUnderTest(f, data);

            var calledWithEvery = vals.every(function(elem, i) {
              return data[i] === elem;
            });

            expect(calledWithEvery).to.equal(true);
          });


          it('Returns correctly when called with ' + type + ' and ' + okVal + ' returned (' + num + ')', function() {
            var data = sliceIfNecessary(originalData);
            var calls = 0;
            var f = function(x) {
              calls += 1;
              return okVal;
            };
            var result = fnUnderTest(f, data);

            expect(result).to.equal(okVal);
          });
        };


        addTests('array', 1, [1, 2, 3]);
        addTests('array', 2, [{}, {}, {}, {}]);
        addTests('arrayLike', 1, makeArrayLike(true, false, true));
        addTests('arrayLike', 2, makeArrayLike(function() {}, function() {}, function() {}));
        addTests('string', 1, 'abc');
        addTests('string', 2, 'funkier');


        var checkEmpty = function(message, value) {
          it('Returns ' + okVal + ' for ' + message, function() {
            expect(fnUnderTest(function(x) {}, value)).to.equal(okVal);
          });
        };
        addEmptyTests(checkEmpty);
      });
    };


    makeArrayBooleanTest('every', array.every, false);
    makeArrayBooleanTest('some', array.some, true);


    /*
     * The "works correctly" tests for max/min/sum/product are the same shape.
     *
     */

    var addSpecialFoldsTest = function(fnUnderTest, message, originalData, expected) {
      it('Works correctly for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var result = fnUnderTest(data);

        expect(result).to.equal(expected);
      });
    };


    var makeMinMaxTests = function(desc, fnUnderTest, isMax) {
      var spec = {
        name: desc,
        restrictions: [['arrayLike']],
        validArguments: [[[1, 2], 'ab', makeArrayLike(2, 3, 4)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        addThrowsOnEmptyTests(fnUnderTest, []);


        addSpecialFoldsTest(fnUnderTest, 'for array (1)', [3, 1, 2, 42, 6], isMax ? 42 : 1);
        addSpecialFoldsTest(fnUnderTest, 'for array (2)', [2], 2);
        addSpecialFoldsTest(fnUnderTest, 'for arrayLike (1)', makeArrayLike(4, 7, 13, 2, 8), isMax ? 13 : 2);
        addSpecialFoldsTest(fnUnderTest, 'for arrayLike (2)', makeArrayLike(7), 7);
        addSpecialFoldsTest(fnUnderTest, 'for string (1)', 'bad0Z9w', isMax ? 'w' : '0');
        addSpecialFoldsTest(fnUnderTest, 'for string (2)', 'e', 'e');
      });
    };


    makeMinMaxTests('maximum', array.maximum, true);
    makeMinMaxTests('minimum', array.minimum, false);


    var makeSumProductTests = function(desc, fnUnderTest, isSum) {
      var spec = {
        name: desc,
        restrictions: [['strictarrayLike']],
        validArguments: [[[1, 2], makeArrayLike(2, 3, 4)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        it('Throws when called with a string', function() {
          var fn = function() {
            fnUnderTest('abc');
          };

          expect(fn).to.throw(TypeError);
        });


        addSpecialFoldsTest(fnUnderTest, 'for array (1)', [1, 2, 3, 4], isSum ? 10 : 24);
        addSpecialFoldsTest(fnUnderTest, 'for array (2)', [2], 2);
        addSpecialFoldsTest(fnUnderTest, 'for empty array', [], isSum ? 0 : 1);
        addSpecialFoldsTest(fnUnderTest, 'for arrayLike (1)', makeArrayLike(1, 3, 5), isSum ? 9 : 15);
        addSpecialFoldsTest(fnUnderTest, 'for arrayLike (2)', makeArrayLike(5), 5);
        addSpecialFoldsTest(fnUnderTest, 'for empty arrayLike', makeArrayLike(), isSum ? 0 : 1);
      });
    };


    makeSumProductTests('sum', array.sum, true);
    makeSumProductTests('product', array.product, false);


    /*
     * element and elementWith share common behaviours. The next two functions are used for generating these tests.
     *
     */

    var addElementNotFoundTest = function(fnUnderTest, message, value, data) {
      it('Returns false when called with empty ' + message, function() {
        var found = fnUnderTest(value, data);

        expect(found).to.equal(false);
      });
    };


    var addElementFoundTest = function(fnUnderTest, message, value, data) {
      it('Returns true when ' + message, function() {
        var found = fnUnderTest(value, data);

        expect(found).to.equal(true);
      });
    };


    var elementSpec = {
      name: 'element',
      restrictions: [[], ['arrayLike']],
      validArguments: [['a'], [['a', 'b', 'c'], 'abc', makeArrayLike('a', 'c', 'd')]]
    };


    checkFunction(elementSpec, array.element, function(element) {
      addElementNotFoundTest(element, 'array empty', 2, []);
      addElementNotFoundTest(element, 'arrayLike empty', 7, makeArrayLike());
      addElementNotFoundTest(element, 'string empty', 'a', '');
      addElementNotFoundTest(element, 'element not present in array', 5, [1, 3, 4]);
      addElementNotFoundTest(element, 'element not present in arrayLike', 6, makeArrayLike(1, 2, 3));
      addElementNotFoundTest(element, 'element not present in string', 'd', 'abc');
      addElementNotFoundTest(element, 'identical element not in array', {foo: 1},
                                      [{foo: 1}, {foo: 1}, {foo: 1}]);
      addElementNotFoundTest(element, 'identical element not in arrayLike', {}, makeArrayLike({}, {}, {}));

      addElementFoundTest(element, 'element present in array', 6, [1, 6, 4]);
      addElementFoundTest(element, 'element present in arrayLike', 8, makeArrayLike(1, 2, 8));
      addElementFoundTest(element, 'element present in string', 'b', 'abc');
      var obj = {foo: 1};
      addElementFoundTest(element, 'identical element in array', obj, [{foo: 1}, {foo: 1}, obj]);
      addElementFoundTest(element, 'identical element in arrayLike', obj, makeArrayLike({foo: 1}, obj, {}));
    });


    var elementWithSpec = {
      name: 'elementWith',
      restrictions: [['function: arity 1'], ['arrayLike']],
      validArguments: [[function(x) {return true;}], [['a', 'b', 'c'], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(elementWithSpec, array.elementWith, function(elementWith) {
      addElementNotFoundTest(elementWith, 'array is empty', alwaysTrue, []);
      addElementNotFoundTest(elementWith, 'arrayLike is empty', alwaysTrue, makeArrayLike());
      addElementNotFoundTest(elementWith, 'string is empty', alwaysTrue, '');
      addElementNotFoundTest(elementWith, 'array predicate returns false', function(x) {return x.foo === 5;},
                                          [{foo: 1}, {foo: 4}, {foo: 3}]);
      addElementNotFoundTest(elementWith, 'arrayLike predicate returns false', alwaysFalse, makeArrayLike('a', 'b'));
      addElementNotFoundTest(elementWith, 'string predicate returns false', isDigit, 'abcde');

      addElementFoundTest(elementWith, 'predicate matches array element', function(x) {return x.foo === 7;},
                                       [{foo: 1}, {foo: 7}, {foo: 4}]);
      addElementFoundTest(elementWith, 'predicate matches arrayLike element', fooIs42,
                                       makeArrayLike({foo: 4}, {foo: 42}));
      addElementFoundTest(elementWith, 'predicate matches element in string', isDigit, 'abc8de');
    });


    // The two range functions have some common behaviours: the value returned should be empty if the limits are equal,
    // and the right-hand limit should not be included
    var addCommonRangeTests = function(fnUnderTest, hasStride) {
      hasStride = hasStride || false;


      it('Returns empty array if b === a', function() {
        var args = hasStride ? [1, 1, 1] : [1, 1];
        var result = fnUnderTest.apply(null, args);

        expect(result).to.deep.equal([]);
      });


      it('Does not include right-hand limit (1)', function() {
        var b = 10;
        var args = hasStride ? [0, 1, b] : [0, b];
        var result = fnUnderTest.apply(null, args);

        expect(array.last(result) < b).to.equal(true);
      });


      it('Does not include right-hand limit (2)', function() {
        var b = 15.2;
        var args = hasStride ? [1.1, 1.1, b] : [1.1, b];
        var result = fnUnderTest.apply(null, args);

        expect(array.last(result) < b).to.equal(true);
      });
    };


    describe('range', function() {
      var range = array.range;
      addCommonRangeTests(range);


      it('Throws if b < a', function() {
        var fn = function() {
          range(1, 0);
        };

        expect(fn).to.throw(TypeError);
      });


      var addCorrectTest = function(message, a, b) {
        it('Works correctly ' + message, function() {
          var arr = range(a, b);
          var result = arr.every(function(val, i) {
            return (i === 0 && val === a) || (val === arr[i - 1] + 1);
          });

          expect(result).to.equal(true);
        });
      };


      addCorrectTest('(1)', 0, 10);
      addCorrectTest('(2)', 1.1, 15.2);
    });


    describe('rangeStride', function() {
      var rangeStride = array.rangeStride;
      addCommonRangeTests(rangeStride, true);


      var addBadRangeTest = function(message, a, step, b) {
        it('Throws if ' + message, function() {
          var fn = function() {
            rangeStride(a, step, b);
          };

          expect(fn).to.throw(TypeError);
        });
      };


      addBadRangeTest('b < a, and stride positive', 1, 1, 0);
      addBadRangeTest('b < a, and stride zero', 1, 0, 0);
      addBadRangeTest('b < a, and stride not finite (1)', 1, Number.POSITIVE_INFINITY, 0);
      addBadRangeTest('b < a, and stride not finite (2)', 1, Number.NEGATIVE_INFINITY, 0);
      addBadRangeTest('b > a, and stride positive', 1, -1, 10);
      addBadRangeTest('b > a, and stride zero', 1, 0, 10);
      addBadRangeTest('b > a, and stride not finite (1)', 1, Number.POSITIVE_INFINITY, 10);
      addBadRangeTest('b > a, and stride not finite (2)', 1, Number.NEGATIVE_INFINITY, 10);


      var addCorrectTest = function(message, a, step, b) {
        it('Works correctly (1)', function() {
          var arr = rangeStride(a, step, b);
          var result = arr.every(function(val, i) {
            return (i === 0 && val === a) || (val === arr[i - 1] + step);
          });

          expect(result).to.equal(true);
        });
      };


      addCorrectTest('(1)', 0, 2, 10);
      addCorrectTest('(2)', 15.2, -1.1, 1.1);


      it('Empty if a === b, and stride incorrect', function() {
        var a = 1;
        var step = 0;
        var b = 1;
        var arr = rangeStride(a, step, b);

        expect(arr).to.deep.equal([]);
      });


      // The common range tests don't test the backward step case
      it('Does not include right-hand limit (3)', function() {
        var a = 20;
        var step = -1;
        var b = 10;
        var result = rangeStride(a, step, b);

        expect(array.last(result) > b).to.equal(true);
      });
    });


    var addCommonTakeDropTests = function(testAdder) {
      var tests = [
        {name: 'array', makeEmpty: function() {return [];}, makeNormal: function() {return [1, 2, 3];}},
        {name: 'arrayLike', makeEmpty: function() {return makeArrayLike();},
                            makeNormal: function() {return makeArrayLike(2, 3, 4);}},
        {name: 'string', makeEmpty: function() {return '';}, makeNormal: function() {return 'funkier';}}
      ];


      tests.forEach(function(test) {
        testAdder('count is 0 for empty ' + test.name, 0, test.makeEmpty());
        testAdder('count is 0 for ' + test.name, 0, test.makeNormal());
        testAdder('count is negative for empty ' + test.name, -1, test.makeEmpty());
        testAdder('count is negative for ' + test.name, -1, test.makeNormal());
      });
    };


    var takeSpec = {
      name: 'take',
      restrictions: [['integer'], ['arrayLike']],
      validArguments: [[1], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(takeSpec, array.take, function(take) {
      addReturnsSameTypeTests(take, [1]);
      addNoModificationOfOriginalTests(take, [1]);
      addReturnsEmptyOnEmptyTests(take, [1]);


      var addExpectEmptyTest = function(message, count, originalData) {
        var isArray = typeof(originalData) !== 'string';


        it('Returns empty ' + (isArray ? 'array' : 'string') + ' when ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = take(count, data);

          expect(result).to.deep.equal(isArray ? [] : '');
        });
      };


      addCommonTakeDropTests(addExpectEmptyTest);


      var addCorrectEntryTests = function(message, count, arrData, arrlikeData, strData) {
        var addTest = function(typeMessage, originalData) {
          it('Works correctly when ' + message + typeMessage, function() {
            var data = sliceIfNecessary(originalData);
            var arr = take(count, data);
            arr = splitIfNecessary(arr);

            var result = arr.every(function(val, i) {
              return val === data[i];
            });

            expect(result).to.equal(true);
          });
        };

        addTest(' for array', arrData);
        addTest(' for arrayLike', arrlikeData);
        addTest(' for string', strData);
      };


      addCorrectEntryTests('count < length', 2, [1, 2, 3], makeArrayLike(2, 3, 4), 'funkier');
      addCorrectEntryTests('count === length', 3, [{}, {}, {}], makeArrayLike(5, 6, 7), 'abc');
      addCorrectEntryTests('count > length', 4, [3, 4, 5], makeArrayLike(8, 9), 'x');
    });


    var dropSpec = {
      name: 'drop',
      restrictions: [['integer'], ['arrayLike']],
      validArguments: [[1], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(dropSpec, array.drop, function(drop) {
      addReturnsSameTypeTests(drop, [1]);
      addNoModificationOfOriginalTests(drop, [1]);
      addReturnsEmptyOnEmptyTests(drop, [1]);


      var addExpectFullTest = function(message, count, originalData) {
        var isArray = typeof(original) !== 'string';

        it('Returns copy of ' + (isArray ? 'array' : 'string') + ' when ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var dropped = drop(count, data);

          expect(valuesEqual(data, dropped)).to.equal(true);
        });
      };


      addCommonTakeDropTests(addExpectFullTest);


      var addCorrectEntryTests = function(message, count, arrData, arrlikeData, strData) {
        var addTest = function(typeMessage, originalData) {
          it('Works correctly when ' + message + typeMessage, function() {
            var data = sliceIfNecessary(originalData);
            var arr = drop(count, data);
            arr = splitIfNecessary(arr);

            var result = arr.every(function(val, i) {
              return val === data[i + count];
            });

            expect(result).to.equal(true);
          });
        };

        addTest(' for array', arrData);
        addTest(' for arrayLike', arrlikeData);
        addTest(' for string', strData);
      };


      var addEmptyAfterDropTests = function(message, count, arrData, arrlikeData, strData) {
        var addTest = function(type, typeMessage, originalData) {
          it('Returns empty ' + type + ' when ' + message + typeMessage, function() {
            var data = sliceIfNecessary(originalData);
            var result = drop(count, data);

            expect(result).to.deep.equal(type === 'array' ? [] : '');
          });
        };

        addTest('array', ' for array ', arrData);
        addTest('array', ' for arrayLike', arrlikeData);
        addTest('string', ' for string ', strData);
      };


      addCorrectEntryTests('count < length', 1, [1, 2, 3], makeArrayLike(2, 3, 4), 'funkier');
      addEmptyAfterDropTests('count === length', 3, [{}, {}, {}], makeArrayLike(1, 2, 3), 'abc');
      addEmptyAfterDropTests('count > length', 4, [3, 4, 5], makeArrayLike('a', 'b'), 'x');
    });


    var makeInitTailTests = function(desc, fnUnderTest) {
      var spec = {
        name: desc,
        restrictions: [['arrayLike']],
        validArguments: [[[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        addThrowsOnEmptyTests(fnUnderTest, []);
        addReturnsSameTypeTests(fnUnderTest, []);


        var addTests = function(type, tests) {
          var addOne = function(originalData, count) {
            var lenMessage = 'Returns ' + (typeof(originalData === 'string') ? 'string' : 'array') +
                             ' of correct length when called with ' + type + '(' + count + ')';
            addSameLengthTest(fnUnderTest, lenMessage, [], originalData, -1);


            it('Works correctly for ' + type + ' (' + count + ')', function() {
              var data = sliceIfNecessary(originalData);
              var arr = fnUnderTest(data);
              arr = splitIfNecessary(arr);

              var valuesCorrect = arr.every(function(val, i) {
                return val === data[fnUnderTest === array.tail ? i + 1 : i];
              });

              expect(valuesCorrect).to.equal(true);
            });
          };

          tests.forEach(addOne);
        };


        addTests('array', [[1, 2, 3], [{}, {}, {}, {}, {}]]);
        addTests('arrayLike', [makeArrayLike({}, {}), makeArrayLike(true, false, null)]);
        addTests('string', ['abc', 'funkier']);
      });
    };


    makeInitTailTests('init', array.init);
    makeInitTailTests('tail', array.tail);


    var makeInitsTailsTests = function(desc, fnUnderTest) {
      var spec = {
        name: desc,
        restrictions: [['arrayLike']],
        validArguments: [[[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        var addTests = function(type, tests) {
          var expectedType = type === 'string' ? 'string' : 'array';


          var addOneSet = function(originalData, count) {
            var lenMessage = 'Returns array of correct length when called with ' + type + '(' + count + ')';
            addSameLengthTest(fnUnderTest, lenMessage, [], originalData, 1);


            it('Returns array when called with ' + type + '(' + count + ')', function() {
              var data = sliceIfNecessary(originalData);
              var result = fnUnderTest(data);

              expect(isArray(result)).to.equal(true);
            });


            it('Returns elements of type ' + expectedType + ' when called with ' + type + '(' + count + ')', function() {
              var data = sliceIfNecessary(originalData);
              var elementsHaveCorrectType = fnUnderTest(data).every(function(val) {
                if (expectedType === 'array')
                  return isArray(val);
                return typeof(val) === 'string';
               });

               expect(elementsHaveCorrectType).to.equal(true);
            });


            it('Elements have correct length when called with ' + type + '(' + count + ')', function() {
              var data = sliceIfNecessary(originalData);
              var elementLengthsCorrect = fnUnderTest(data).every(function(val, i) {
                return val.length === (fnUnderTest === array.tails ? data.length - i : i);
              });

              expect(elementLengthsCorrect).to.equal(true);
            });


            it('Works correctly for ' + type + ' (' + count + ')', function() {
              var data = sliceIfNecessary(originalData);
              var arr = fnUnderTest(data);
              var elementsCorrect = arr.every(function(val, i) {
                val = splitIfNecessary(val);

                return val.every(function(v, j) {
                  return v === data[fnUnderTest === array.tails ? i + j : j];
                });
              });

              expect(elementsCorrect).to.equal(true);
            });
          };

          tests.forEach(addOneSet);
        };


        addTests('array', [[], [1, 2], [{}, {}, {}]]);
        addTests('arrayLike', [makeArrayLike(), makeArrayLike(2, 3), makeArrayLike({}, true, null)]);
        addTests('string', ['', 'ab', 'funkier']);
        addNoModificationOfOriginalTests(fnUnderTest, []);
      });
    };


    makeInitsTailsTests('inits', array.inits);
    makeInitsTailsTests('tails', array.tails);


    var copySpec = {
      name: 'copy',
      restrictions: [['arrayLike']],
      validArguments: [[[1, 2], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(copySpec, array.copy, function(copy) {
      addReturnsSameTypeTests(copy, []);
      addReturnsEmptyOnEmptyTests(copy, []);


      var addTests = function(message, originalData) {
        addSameLengthTest(copy, message, [], originalData);


        it('Returns a copy for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var sameValue = copy(data) === data;

          expect(sameValue).to.equal(false);
        });


        it('Works correctly for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var copied = copy(data);


          expect(valuesEqual(data, copied)).to.equal(true);
        });


        it('Shallow copies members for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var membersAreCopies = copy(data).every(function(val, i) {
            return val === data[i];
          });

          expect(membersAreCopies).to.equal(true);
        });
      };


      addTests('empty arrays', []);
      addTests('arrays (1)', [1, 2, 3]);
      addTests('arrays (2)', [{foo: 1}, {baz: 2}, {fizz: 3, buzz: 5}]);
      addTests('empty arrayLikes', makeArrayLike());
      addTests('arrayLikes (1)', makeArrayLike(2, 3, 4));
      addTests('arrayLikes (2)', makeArrayLike({fizz: 3}, {buzz: 5}));
    });


    var sliceSpec = {
      name: 'slice',
      restrictions: [['natural'], ['natural'], ['arrayLike']],
      validArguments: [[0], [1], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(sliceSpec, array.slice, function(slice) {
      addReturnsSameTypeTests(slice, [0, 1]);
      addNoModificationOfOriginalTests(slice, []);


      var addReturnEmptyTests = function(originalData) {
        var isArray = typeof(originalData) !== 'string';


        it('Returns empty ' + (isArray ? 'array' : 'string') + ' if from > length', function() {
          var data = originalData.slice();
          var result = slice(data.length + 2, data.length + 4, data);

          expect(result).to.deep.equal(isArray ? [] : '');
        });


        it('Returns empty ' + (isArray ? 'array' : 'string') + ' if from === length', function() {
          var data = originalData.slice();
          var result = slice(data.length, data.length + 3, data);

          expect(result).to.deep.equal(isArray ? [] : '');
        });
      };


      addReturnEmptyTests([1, 2, 3]);
      addReturnEmptyTests(makeArrayLike(true, 1, null));
      addReturnEmptyTests('abc');

      // we should also test we get an empty when passing empty. We cannot pass addReturnEmptyTests directly to
      // addTests: addTests expects the generator to have arity 2, addReturnEmptyTests has arity 1. Thus we wrap it.
      var addEmpty = function(message, data) { addReturnEmptyTests(data); };
      addEmptyTests(addEmpty);


      var addTests = function(message, from, to, arrData, arrlikeData, strData) {
        var addOne = function(type, originalData) {
          it('Result has correct length when ' + message + ' for ' + type, function() {
            var data = sliceIfNecessary(originalData);
            var result = slice(from, to, data).length === Math.min(data.length - from, to - from);

            expect(result).to.equal(true);
          });


          it('Result has correct values when ' + message + ' for ' + type, function() {
            var data = sliceIfNecessary(originalData);
            var newVal = slice(from, to, data);
            newVal = splitIfNecessary(newVal);

            var result = newVal.every(function(val, i) {
              return val === data[from + i];
            });

            expect(result).to.equal(true);
          });
        };

        addOne('array', arrData);
        addOne('arrayLike', arrlikeData);
        addOne('string', strData);
      };


      addTests('to > len', 1, 5, [1, 2, 3, 4], makeArrayLike(2, 3, 4, 5), 'abcd');
      addTests('to === len', 1, 4, [2, 3, 4, 5], makeArrayLike(2, 3, 4, 5), 'efgh');
      addTests('slicing normally', 1, 3, [{foo: 1}, {bar: 2}, {fizz: 3}, {buzz: 5}], makeArrayLike(2, 3, 4, 5), 'abcd');
    });


    var makeTakeWDropWTests = function(desc, fnUnderTest) {
      var isTakeWhile = desc === 'takeWhile';


      var spec = {
        name: desc,
        restrictions: [['function: arity 1'], ['arrayLike']],
        validArguments: [[function(x) {return true;}], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        addFuncCalledWithSpecificArityTests(fnUnderTest, 1);
        addReturnsSameTypeTests(fnUnderTest, [alwaysTrue]);
        addReturnsEmptyOnEmptyTests(fnUnderTest, [alwaysTrue]);
        addNoModificationOfOriginalTests(fnUnderTest, [alwaysTrue]);


        var addTests = function(type, message, predicate, expectedLength, originalData) {
          it('Result has correct length ' + message + ' for ' + type, function() {
            var data = sliceIfNecessary(originalData);
            var correctLength = isTakeWhile ? expectedLength : data.length - expectedLength;
            var length = fnUnderTest(predicate, data).length;

            expect(length).to.equal(correctLength);
          });


          it('Predicate only called as often as needed ' + message + ' for ' + type, function() {
            var data = sliceIfNecessary(originalData);

            // We use a predicate that records how often it is called, and check we didn't iterate over the whole value
            var called = 0;
            var newPredicate = function(x) {called += 1; return predicate(x);};
            fnUnderTest(newPredicate, data);
            var calledCorrectly = called === expectedLength + (expectedLength === data.length ? 0 : 1);

            expect(calledCorrectly).to.equal(true);
          });


          it('Result has correct members ' + message + ' for ' + type, function() {
            var data = sliceIfNecessary(originalData);
            var arr = fnUnderTest(predicate, originalData);
            arr = splitIfNecessary(arr);

            var membersCorrect = arr.every(function(val, i) {
              return val === data[isTakeWhile ? i : i + expectedLength];
            });

            expect(membersCorrect).to.equal(true);
          });
        };


        // Each type has 3 tests: one where only some initial elements match, one where no element matches, and one
        // where every element matches
        var testData = [
          {name: 'array', tests: [{f: function(x) {return x.foo < 4;}, expected: 2,
                                   data: [{foo: 1}, {foo: 3}, {foo: 4}, {foo: 5}, {foo: 6}]},
                                  {f: function(x) {return x % 2 === 0;}, expected: 0, data: [3, 4, 6, 1, 5]},
                                  {f: alwaysTrue, expected: 5, data: [2, 4, 6, 1, 5]}]},
          {name: 'arrayLike', tests: [{f: function(x) {return x.foo < 5;}, expected: 4,
                                       data: makeArrayLike({foo: 1}, {foo: 3}, {foo: 4}, {foo: 2}, {foo: 6})},
                                      {f: function(x) {return x % 2 !== 0;}, expected: 0,
                                       data: makeArrayLike(2, 4, 6, 1, 5)},
                                      {f: alwaysTrue, expected: 5, data: makeArrayLike(2, 4, 6, 1, 5)}]},
          {name: 'string', tests: [{f: function(x) {return x === ' ';}, expected: 3, data: '   funkier'},
                                   {f: isDigit, expected: 0, data: 'zxabc'},
                                   {f: alwaysTrue, expected: 5, data: 'abcde'}]}
        ];


        testData.forEach(function(t) {
          t.tests.forEach(function(test, i) {
            addTests(t.name, '(' + (i + 1) + ')', test.f, test.expected, test.data);
          });
        });
      });
    };


    makeTakeWDropWTests('takeWhile', array.takeWhile);
    makeTakeWDropWTests('dropWhile', array.dropWhile);


    var makePrependAppendTests = function(desc, fnUnderTest) {
      var isPrepend = desc === 'prepend';


      var spec = {
        name: desc,
        restrictions: [[], ['arrayLike']],
        validArguments: [[1], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        addReturnsSameTypeTests(fnUnderTest, [1]);
        addNoModificationOfOriginalTests(fnUnderTest, [1]);


        var addTests = function(arrData, arrlikeData, strData) {
          var addOne = function(type, message, val, originalData) {
            addSameLengthTest(fnUnderTest, message, [val], originalData, 1);


            it('Result has correct values ' + message + ' for ' + type, function() {
              var data = sliceIfNecessary(originalData);
              var newVal = fnUnderTest(val, data);
              newVal = splitIfNecessary(newVal);

              var prependCheck = function(v, i) {
                if (i === 0)
                  return v === val;
                return v === data[i - 1];
              };

              var appendCheck = function(v, i) {
                if (i === data.length)
                  return v === val;
                return v === data[i];
              };

              var elementsCorrect = newVal.every(isPrepend ? prependCheck : appendCheck);

              expect(elementsCorrect).to.equal(true);
            });
          };

          arrData.forEach(function(data, i) {
            addOne('array', '(' + (i + 1) + ')', data[0], data[1]);
          });
          arrlikeData.forEach(function(data, i) {
            addOne('arrayLike', '(' + (i + 1) + ')', data[0], data[1]);
          });
          strData.forEach(function(data, i) {
            addOne('string', '(' + (i + 1) + ')', data[0], data[1]);
          });
        };


        // The tests include a "normal" test, and a value to be modified to is empty test
        addTests([[{}, [{foo: 1}, {bar: 2}, {fizz: 3}]], [1, []]],
                 [[5, makeArrayLike(6, 7, 8, 9)], ['a', makeArrayLike()]],
                 [['a', 'bcd'], ['z', '']]);
      });
    };


    makePrependAppendTests('prepend', array.prepend);
    makePrependAppendTests('append', array.append);


    var concatSpec = {
      name: 'concat',
      restrictions: [['arrayLike'], ['arrayLike']],
      validArguments: [[[1, 2], 'abc', makeArrayLike(2, 3, 4)], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(concatSpec, array.concat, function(concat) {
      var addTest = function(expectedType, message, left, right) {
        // We can't use the global returnsSameType test generator here
        it('Result has type ' + expectedType + ' for ' + message, function() {
          var first = left.slice();
          var second = right.slice();
          var result = concat(first, second);

          if (expectedType === 'array')
            expect(isArray(result)).to.equal(true);
          else
            expect(result).to.be.a('string');
        });


        it('Result has correct length for ' + message, function() {
          var first = left.slice();
          var second = right.slice();
          var length = concat(first, second).length;

          expect(length).to.equal(first.length + second.length);
        });


        it('Result has correct values for ' + message, function() {
          var first = left.slice();
          var second = right.slice();
          var newVal = concat(first, second);
          newVal = splitIfNecessary(newVal);

          var valsCorrect = newVal.every(function(v, i) {
            return v === (i < first.length ? first[i] : second[i - first.length]);
          });

          expect(valsCorrect).to.equal(true);
        });


        it('Doesn\'t affect originals for ' + message, function() {
          var first = left.slice();
          var second = right.slice();
          var firstLength = first.length;
          var secondLength = second.length;
          concat(first, second);

          expect(first.length === firstLength && second.length === secondLength).to.equal(true);
        });
      };


      var tests = [
        {name: 'array', tests: [{type: 'empty', value: []}, {type: 'normal', value: [1, 2]}]},
        {name: 'arrayLike', tests: [{type: 'empty', value: makeArrayLike()},
                                    {type: 'normal', value: makeArrayLike(2, 3, 4)}]},
        {name: 'string', tests: [{type: 'empty', value: ''}, {type: 'normal', value: 'funkier'}]}
      ];


      tests.forEach(function(left) {
        left.tests.forEach(function(leftTest) {
          tests.forEach(function(right) {
            right.tests.forEach(function(rightTest) {
              var expectedType = left.name === 'string' && right.name === 'string' ? 'string' : 'array';
              var message = ['LHS', leftTest.type, left.name, ',', 'RHS', rightTest.type, right.name].join(' ');

              addTest(expectedType, message, leftTest.value, rightTest.value);
            });
          });
        });
      });
    });


    var isEmptySpec = {
      name: 'empty',
      restrictions: [['arrayLike']],
      validArguments: [[[], '', makeArrayLike()]]
    };


    checkFunction(isEmptySpec, array.isEmpty, function(isEmpty) {
      var addOne = function(message, originalData) {
        it('Works for ' + message, function() {
          var data = sliceIfNecessary(originalData);

          expect(isEmpty(data)).to.equal(data.length === 0);
        });
      };


      addEmptyTests(addOne);
      addOne('a non-empty array', [1, 2]);
      addOne('a non-empty arrayLike', makeArrayLike(2, 3));
      addOne('a non-empty string', 'a');
    });


    var intersperseSpec = {
      name: 'intersperse',
      restrictions: [[], ['arrayLike']],
      validArguments: [[','], [[1, 2], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(intersperseSpec, array.intersperse, function(intersperse) {
      addReturnsSameTypeTests(intersperse, ['-']);


      var addDegenerateTest = function(message, originalData) {
        it('Works correctly for ' + message, function() {
          var val = originalData.slice();
          var result = intersperse(',', val);

          expect(valuesEqual(val, result)).to.equal(true);
        });
      };


      addEmptyTests(addDegenerateTest);
      addDegenerateTest('for single element array', [1]);
      addDegenerateTest('for single element arrayLike', makeArrayLike(2));
      addDegenerateTest('for single element string', 'a');


      var addTests = function(message, originalData) {
        it('Result has correct length ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var length = intersperse(',', data).length;

          expect(length).to.equal(2 * data.length - 1);
        });


        it('Result has original values at correct positions ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var interspersed = intersperse(',', data);
          interspersed = splitIfNecessary(interspersed);
          var originalElementsPresent = interspersed.every(function(v, i) {
            // the values at odd indices should be the interspersed string
            if (i % 2 === 1) return true;

            return v === data[i / 2];
          });

          expect(originalElementsPresent).to.equal(true);
        });


        it('Result has interspersed values at correct positions ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var intersperseValue = ':';
          var interspersed = intersperse(intersperseValue, data);
          interspersed = splitIfNecessary(interspersed);
          var interspersedCorrectly = interspersed.every(function(v, i) {
            // the values at even indices were checked in the preceding test
            if (i % 2 === 0) return true;

            return v === intersperseValue;
          });

          expect(interspersedCorrectly).to.equal(true);
        });
      };


      addTests('array (1)', [1, 2]);
      addTests('array (2)', [1, 2, 3, 4]);
      addTests('arrayLike (1)', makeArrayLike(2, 3));
      addTests('arrayLike (2)', makeArrayLike(4, 5, 6, 7));
      addTests('string (1)', 'ab');
      addTests('string (2)', 'funkier');
    });


    var reverseSpec = {
      name: 'reverse',
      restrictions: [['arrayLike']],
      validArguments: [[[1, 2], 'ab', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(reverseSpec, array.reverse, function(reverse) {
      addReturnsEmptyOnEmptyTests(reverse, []);
      addReturnsSameTypeTests(reverse, []);


      var addTests = function(message, originalData) {
        it('Returns value with same length as original for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var expected = data.length;
          var result = reverse(data);

          expect(result.length).to.equal(expected);
        });


        it('Returns correct result for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var originalLength = data.length - 1;
          var reversed = reverse(data);
          reversed = splitIfNecessary(reversed);
          var result = reversed.every(function(v, i) {
            return v === data[originalLength - i];
          });

          expect(result).to.equal(true);
        });
      };


      addTests('array', [{}, {}]);
      addTests('arrayLike', makeArrayLike(1, 2));
      addTests('string', 'funkier');
      addTests('single element array', [1]);
      addTests('single element arrayLike', makeArrayLike(3));
      addTests('single element string', '');
    });


    /*
     * The search and modification functions are not yet ready for implementation, until I get the API finalized.
     *

    var addFindTest = function(message, fnUnderTest, args, expected) {
      var val = args[0];
      var originalData = args[args.length - 1];

      it(message, function() {
        var data = sliceIfNecessary(originalData);
        var argData = args.slice();
        var result = fnUnderTest.apply(null, argData);

        expect(result).to.equal(expected);
        if (result !== -1) {
          if (typeof(val) !== 'function') {
            expect(data[result]).to.equal(val);
          } else {
            expect(val(data[result])).to.equal(true);
          }
        }
      });
    };


    var findSpec = {
      name: 'find',
      restrictions: [[], ['arrayLike']],
      validArguments: [[1], [[2, 3], '234', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(findSpec, array.find, function(find) {
      var addEmpty = function(message, value) {
        addFindTest('Works correctly for ' + message, find, [1, value], -1);
      };
      addEmptyTests(addEmpty);


      // Each test's value should be such that the value at index 0 is duplicated in the value, the second and last
      // values are not duplicated, and the number 0 does not appear anywhere in the value
      var tests = [
        {name: 'array', value: [1, 2, 3, 1, 4]},
        {name: 'arrayLike', value: makeArrayLike(2, 4, 2, 6)},
        {name: 'string', value: 'abacus'}
      ];


      tests.forEach(function(test) {
        addFindTest('Works correctly for ' + test.name + ' (1)', find, [test.value[1], test.value], 1);
        var len = test.value.length - 1;
        addFindTest('Works correctly for ' + test.name + ' (2)', find, [test.value[len], test.value], len);
        addFindTest('Returns first match for  ' + test.name, find, [test.value[0], test.value], 0);
        addFindTest('Returns -1 when no match for ' + test.name, find, [0, test.value], -1);
      });


      var obj = {};
      addFindTest('Tests with strict identity for array (1)', find, [obj, [{}, {}, {}]], -1);
      addFindTest('Tests with strict identity for array (2)', find, [obj, [{}, obj, {}]], 1);
      addFindTest('Tests with strict identity for arrayLike (1)', find, [obj, makeArrayLike({}, {}, {})], -1);
      addFindTest('Tests with strict identity for arrayLike (2)', find, [obj, makeArrayLike({}, obj, {})], 1);
    });


    var findFromSpec = {
      name: 'findFrom',
      restrictions: [[], ['positive'], ['arrayLike']],
      validArguments: [[1], [1], [[2, 3], '234', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(findFromSpec, array.findFrom, function(findFrom) {
      var addEmpty = function(message, value) {
        addFindTest('Works correctly for ' + message, findFrom, [0, 0, value], -1);
      };
      addEmptyTests(addEmpty);


      // Each test's value should be such that:
      //  - the value at index 3 is the same as that at index 0
      //  - the values at index 1 and the last value occur only once
      //  - the value at index 2 and the second last value are the same
      //  - the number 0 does not appear anywhere in the value
      var tests = [
        {name: 'array', value: [1, 5, 6, 1, 6, 8]},
        {name: 'arrayLike', value: makeArrayLike(2, 9, 7, 2, 7, 1)},
        {name: 'string', value: 'bacbcd'}
      ];


      tests.forEach(function(test) {
        var len = test.value.length - 1;
        addFindTest('Works correctly for ' + test.name + ' (1)', findFrom, [test.value[1], 1, test.value], 1);
        addFindTest('Works correctly for ' + test.name + ' (2)', findFrom, [test.value[len], 2, test.value], len);
        addFindTest('Returns first match for ' + test.name, findFrom, [test.value[2], 3, test.value], len - 1);
        addFindTest('Ignores earlier matches for ' + test.name, findFrom, [test.value[0], 1, test.value], 3);
        addFindTest('Returns -1 when no match for ' + test.name, findFrom, [0, 1, test.value], -1);
        addFindTest('Returns -1 when no match at position for ' + test.name, findFrom, [test.value[1], 2, test.value], -1);
        addFindTest('Returns -1 when from === length for ' + test.name, findFrom, [0, len + 1, test.value], -1);
        addFindTest('Returns -1 when from > length for ' + test.name, findFrom, [0, len + 2, test.value], -1);
      });

      var obj = {};
      addFindTest('Tests with strict identity for array (1)', findFrom, [obj, 0, [{}, {}, {}]], -1);
      addFindTest('Tests with strict identity for array (2)', findFrom, [obj, 1, [{}, {}, obj, {}]], 2);
      addFindTest('Tests with strict identity for arrayLike (1)', findFrom, [obj, 1, makeArrayLike({}, {})], -1);
      addFindTest('Tests with strict identity for arrayLike (2)', findFrom, [obj, 1, makeArrayLike({}, obj, {}, {})], 1);
    });


    var addFindPredicateCalledWithEveryNotFoundTest = function(fnUnderTest, fnArgs) {
      var originalData = fnArgs[fnArgs.length - 1];
      var message = isArray(originalData) ? 'array' : typeof(originalData) === 'string' ? 'string' : 'object';


      it('Function called with every element if not found (' + message + ')', function() {
        // The function records every argument it is called with. This should equal the original data
        var args = [];
        var f = function(x) {args.push(x); return false;};

        var from = fnArgs.length === 1 ? 0 : fnArgs[0];
        var data = sliceIfNecessary(fnArgs[fnArgs.length - 1]);
        var realFnArgs = [f].concat(fnArgs.slice(0, fnArgs.length - 1)).concat([data]);

        var result = fnUnderTest.apply(null, realFnArgs);

        var calledWithEvery = args.every(function(v, i) {
          return v === data[i + from];
        });

        expect(args.length).to.equal(data.length - from);
        expect(calledWithEvery).to.equal(true);
      });
    };


    var addFindPredicateCalledOnlyAsOftenAsNecessaryTest = function(fnUnderTest, fnArgs) {
      var originalData = fnArgs[fnArgs.length - 1];
      var message = isArray(originalData) ? 'array' : typeof(originalData) === 'string' ? 'string' : 'object';


      it('Function called only as often as necessary when found (' + message + ')', function() {
        // Create a new predicate function that records the values it's called with, then defers to
        // the supplied predicate. We can then confirm we iterated from left to right.
        var args = [];
        var predicate = fnArgs[0];
        var f = function(x) {args.push(x); return predicate(x);};

        var data = sliceIfNecessary(fnArgs[fnArgs.length - 1]);
        var from = fnArgs.length === 2 ? 0 : fnArgs[1];
        var realFnArgs = [f].concat(fnArgs.slice(1, fnArgs.length - 1)).concat([data]);
        var index = fnUnderTest.apply(null, realFnArgs);

        var iteratedOverValue = args.every(function(v, i) {
          return v === data[from + i];
        });

        expect(args.length).to.equal(index + 1 - from);
        expect(iteratedOverValue).to.equal(true);
      });
    };


    var findWithSpec = {
      name: 'findWith',
      restrictions: [['function: arity 1'], ['arrayLike']],
      validArguments: [[alwaysTrue], [[1, 2], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(findWithSpec, array.findWith, function(findWith) {
      addFuncCalledWithSpecificArityTests(findWith, 1);


      var addEmpty = function(message, originalData) {
        it('Function never called for ' + message, function() {
          var called = false;
          var f = function(x) {called = true; return true;};
          var data = sliceIfNecessary(originalData);
          findWith(f, data);

          expect(called).to.equal(false);
        });


        it('Works correctly for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = findWith(alwaysTrue, data);

          expect(result).to.equal(-1);
        });
      };


      addEmptyTests(addEmpty);
      addFindPredicateCalledWithEveryNotFoundTest(findWith, [[1, 2, 3]]);
      addFindPredicateCalledWithEveryNotFoundTest(findWith, [makeArrayLike()]);
      addFindPredicateCalledWithEveryNotFoundTest(findWith, ['funkier']);
      addFindPredicateCalledOnlyAsOftenAsNecessaryTest(findWith,
                                              [fooIs42, [{foo: 1}, {foo: 6}, {foo: 7}, {foo: 1}, {foo: 42}, {foo: 4}]]);
      addFindPredicateCalledOnlyAsOftenAsNecessaryTest(findWith,
                                                     [fooIs42, makeArrayLike({foo: 1}, {foo: 6}, {foo: 42}, {foo: 1})]);
      addFindPredicateCalledOnlyAsOftenAsNecessaryTest(findWith, [function(x) {return x < 'a';}, 'abCde']);


      // Each test's value should be such that:
      // - value1 should have one value that matches the predicate, at index 2
      // - value2 should have two values that match the predicate, at indices 1 and 3
      var tests = [
        {name: 'array', predicate: fooIs42, value1: [{foo: 1}, {foo: 3}, {foo: 42}, {foo: 6}],
                                            value2: [{foo: 2}, {foo: 42}, {foo: 5}, {foo: 42}, {foo: 7}]},
        {name: 'arrayLike', predicate: fooIs42, value1: makeArrayLike({foo: 3}, {foo: 12}, {foo: 42}, {foo: 1}),
                                                value2: makeArrayLike({foo: 0}, {foo: 42}, {foo: 10}, {foo: 42})},
        {name: 'string', predicate: isDigit, value1: 'ab7def', value2: 'a1b2d'}
      ];


      tests.forEach(function(test) {
        addFindTest('Returns -1 when value not found for ' + test.name, findWith, [alwaysFalse, test.value1], -1);
        addFindTest('Works correctly for ' + test.name, findWith, [test.predicate, test.value1], 2);
        addFindTest('Returns first match for ' + test.name, findWith, [test.predicate, test.value2], 1);
      });
    });


    var findFromWithSpec = {
      name: 'findFromWith',
      restrictions: [['function: arity 1'], ['positive'], ['arrayLike']],
      validArguments: [[alwaysTrue], [1], [[1, 2], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(findFromWithSpec, array.findFromWith, function(findFromWith) {
      addFuncCalledWithSpecificArityTests(findFromWith, 1, [1]);


      var addEmpty = function(message, originalData) {
        it('Function never called with ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var called = 0;
          var f = function(x) {called += 1; return true;};
          findFromWith(f, 1, data);

          expect(called).to.equal(0);
        });


        it('Works correctly for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = findFromWith(alwaysTrue, 0, data);

          expect(result).to.equal(-1);
        });
      };


      // Each test's value should be such that:
      // - value1 should have one value that matches the predicate, at index 2
      // - value2 should have two values that match the predicate, at indices 1 and 3
      var tests = [
        {name: 'array', predicate: fooIs42, value1: [{foo: 1}, {foo: 3}, {foo: 42}, {foo: 6}, {foo: 8}],
                                            value2: [{foo: 2}, {foo: 42}, {foo: 5}, {foo: 42}, {foo: 7}]},
        {name: 'arrayLike', predicate: fooIs42, value1: makeArrayLike({foo: 3}, {foo: 12}, {foo: 42}, {foo: 1}, {foo: 9}),
                                                value2: makeArrayLike({foo: 0}, {foo: 42}, {foo: 10}, {foo: 42})},
        {name: 'string', predicate: isDigit, value1: 'ab7edef', value2: 'a1b2d'}
      ];


      tests.forEach(function(test) {
        addFindTest('Returns -1 when value not found for ' + test.name, findFromWith,
                                                                 [alwaysFalse, 1, test.value1], -1);
        addFindTest('Returns -1 when value not found from position for ' + test.name, findFromWith,
                                                                 [test.predicate, 3, test.value1], -1);
        addFindTest('Returns -1 when index equals length for ' + test.name, findFromWith,
                                                                 [test.predicate, test.value1.length, test.value1], -1);
        addFindTest('Returns -1 when index > length for ' + test.name, findFromWith,
                                                              [test.predicate, test.value1.length + 1, test.value1], -1);
        addFindTest('Works correctly for ' + test.name, findFromWith, [test.predicate, 1, test.value1], 2);
        addFindTest('Returns first match for ' + test.name, findFromWith, [test.predicate, 0, test.value2], 1);
        addFindTest('Ignores earlier matches for ' + test.name, findFromWith, [test.predicate, 2, test.value2], 3);
      });


      addEmptyTests(addEmpty);
      addFindPredicateCalledWithEveryNotFoundTest(findFromWith, [1, [1, 2, 3]]);
      addFindPredicateCalledWithEveryNotFoundTest(findFromWith, [2, makeArrayLike(2, 3, 4, 5, 6)]);
      addFindPredicateCalledWithEveryNotFoundTest(findFromWith, [3, 'funkier']);
      addFindPredicateCalledOnlyAsOftenAsNecessaryTest(findFromWith,
                                           [fooIs42, 2, [{foo: 1}, {foo: 6}, {foo: 7}, {foo: 1}, {foo: 42}, {foo: 4}]]);
      addFindPredicateCalledOnlyAsOftenAsNecessaryTest(findFromWith,
                                                  [fooIs42, 1, makeArrayLike({foo: 1}, {foo: 6}, {foo: 42}, {foo: 1})]);
      addFindPredicateCalledOnlyAsOftenAsNecessaryTest(findFromWith, [function(x) {return x < 'a';}, 1, 'abdCde']);
    });
    */


    var occurrencesSpec = {
      name: 'occurrences',
      restrictions: [[], ['arrayLike']],
      validArguments: [[1], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(occurrencesSpec, array.occurrences, function(occurrences) {
      addReturnsEmptyOnEmptyTests(occurrences, ['z'], true);


      var addEmptyWhenNotFoundTest = function(val, data) {
        var message = isArray(data) ? 'array' : typeof(data) === 'string' ? 'string' : 'arrayLike';


        it('Returns empty array when value not found (' + message + ')', function() {
          var result = occurrences(val, data);

          expect(result).to.deep.equal([]);
        });
      };


      addEmptyWhenNotFoundTest(1, [2, 3, 4]);
      addEmptyWhenNotFoundTest(1, makeArrayLike(2, 3, 4));
      addEmptyWhenNotFoundTest('a', 'bcd');


      var addTest = function(message, val, originalData) {
        it('Returns an array ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = occurrences(val, data);

          expect(isArray(result)).to.equal(true);
        });


        it('Returned values are valid indices ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = occurrences(val, data).every(function(i) {
            return i >= 0 && i < data.length && data[i] === val;
          });

          expect(result).to.equal(true);
        });


        it('No indices missing ' + message, function() {
          var data = splitIfNecessary(originalData.slice());
          var found = occurrences(val, data);
          var result = data.every(function(v, i) {
            if (found.indexOf(i) !== -1) return true;
            return v !== val;
          });

          expect(result).to.equal(true);
        });
      };


      addTest('for array (1)', 1, [2, 1, 3]);
      addTest('for array (2)', 1, [2, 1, 1, 3, 1]);
      var obj = {};
      addTest('for array (3)', obj, [{}, {}, {}]);
      addTest('for array (4)', obj, [{}, obj, {}]);
      addTest('for arrayLike (1)', 1, makeArrayLike(2, 1, 3, 1, 1));
      addTest('for arrayLike (2)', obj, makeArrayLike({}, obj, obj, {}, obj));
      addTest('for string (1)', 'a', 'ban');
      addTest('for string (2)', 'a', 'banana');
    });


    var occurrencesWithSpec = {
      name: 'occurrencesWith',
      restrictions: [['function: arity 1'], ['arrayLike']],
      validArguments: [[alwaysTrue], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(occurrencesWithSpec, array.occurrencesWith, function(occurrencesWith) {
      addReturnsEmptyOnEmptyTests(occurrencesWith, [alwaysTrue], true);


      var addTests = function(message, p, originalData, isNotFound) {
        isNotFound = isNotFound || false;


        it('Returns an array for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = occurrencesWith(p, data);

          expect(isArray(result)).to.equal(true);
        });


        if (isNotFound) {
          it('Returns empty array for ' + message, function() {
            var data = sliceIfNecessary(originalData);
            var result = occurrencesWith(alwaysFalse, data);

            expect(result).to.deep.equal([]);
          });
        }


        it('Function called for every element for ' + message, function() {
          var args = [];
          var f = function(x) {args.push(x); return p(x);};
          var data = sliceIfNecessary(originalData);
          occurrencesWith(f, data);

          var calledWithEvery = args.every(function(v, i) {
            return v === data[i];
          });

          expect(args.length).to.equal(data.length);
          expect(calledWithEvery).to.equal(true);
        });


        it('Returned values are valid indices for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var indicesValid = occurrencesWith(p, data).every(function(i) {
            return i >= 0 && i < data.length && p(data[i]);
          });

          expect(indicesValid).to.equal(true);
        });


        it('No indices missing for ' + message, function() {
          var data = splitIfNecessary(originalData.slice());
          var found = occurrencesWith(p, data);

          var noneMissing = data.every(function(v, i) {
            if (found.indexOf(i) !== -1) return true;
            return p(v) === false;
          });

          expect(noneMissing).to.equal(true);
        });
      };


      addTests('array when value not found', alwaysFalse, [1, 2, 3]);
      addTests('arrayLike when value not found', alwaysFalse, makeArrayLike(2, 3, 4));
      addTests('string when value not found', alwaysFalse, 'funkier');
      addTests('array (1)', strictEquals(1), [2, 1, 3]);
      addTests('array (2)', strictEquals(1), [2, 1, 1, 3, 1]);
      addTests('array (3)', function(x) {return x.foo === 3;},
              [{foo: 3}, {foo: 42}, {foo: 3}, {foo: 3}, {foo: undefined}]);
      addTests('arrayLike (1)', strictEquals(2), [2, 1, 3]);
      addTests('arrayLike (2)', strictEquals(2), [2, 1, 1, 2, 2]);
      addTests('string (1)', strictEquals('a'), 'ban');
      addTests('string (2)', function(x) {return x >= '0' && x <= '9';}, 'b01d22e34');
    });


    var zipSpec = {
      name: 'zip',
      restrictions: [['arrayLike'], ['arrayLike']],
      validArguments: [[[1, 2], 'abc', makeArrayLike(2, 3, 4)], [[3, 4, 5], 'def', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(zipSpec, array.zip, function(zip) {
      var addDegenerateTests = function(message, left, right) {
        it('Works for ' + message, function() {
          var result = zip(left, right);

          expect(result).to.deep.equal([]);
        });
      };


      var degenerateTests = [
        {name: 'array', tests: [{type: 'empty', value: []}, {type: 'normal', value: [1, 2]}]},
        {name: 'arrayLike', tests: [{type: 'empty', value: makeArrayLike()},
                                    {type: 'normal', value: makeArrayLike(2, 3, 4)}]},
        {name: 'string', tests: [{type: 'empty', value: ''}, {type: 'normal', value: 'funkier'}]}
      ];


      degenerateTests.forEach(function(left) {
        left.tests.forEach(function(leftTest) {
          degenerateTests.forEach(function(right) {
            right.tests.forEach(function(rightTest) {
              if (leftTest.type === 'normal' && rightTest.type === 'normal')
                return;

              var message = ['LHS', leftTest.type, left.name, ',', 'RHS', rightTest.type, right.name].join(' ');
              addDegenerateTests(message, leftTest.value, rightTest.value);
            });
          });
        });
      });


      var addTests = function(message, left, right) {
        it('Result is an array for ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var result = zip(l, r);

          expect(isArray(result)).to.equal(true);
        });


        it('Result has correct length for ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var expectedLength = Math.min(l.length, r.length);
          var length = zip(l, r).length;

          expect(length).to.equal(expectedLength);
        });


        it('Every element is a pair for ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var allPairs = zip(l, r).every(function(p) {
            return isPair(p);
          });

          expect(allPairs).to.equal(true);
        });


        it('First of every element is correct for ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var firstsCorrect = zip(l, r).every(function(p, i) {
            return fst(p) === l[i];
          });

          expect(firstsCorrect).to.equal(true);
        });


        it('Second of every element is correct for ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var secondsCorrect = zip(l, r).every(function(p, i) {
            return snd(p) === r[i];
          });

          expect(secondsCorrect).to.equal(true);
        });
      };


      var tests = [
        {name: 'array', tests: [{type: 'singleton', value: [3]}, {type: 'normal', value: [1, 2]}]},
        {name: 'arrayLike', tests: [{type: 'singleton', value: makeArrayLike(5)},
                                    {type: 'normal', value: makeArrayLike(2, 3, 4)}]},
        {name: 'string', tests: [{type: 'singleton', value: 'a'}, {type: 'normal', value: 'funkier'}]}
      ];


      tests.forEach(function(left) {
        left.tests.forEach(function(leftTest) {
          tests.forEach(function(right) {
            right.tests.forEach(function(rightTest) {
              var message = ['LHS', leftTest.type, left.name, ',', 'RHS', rightTest.type, right.name].join(' ');
              if (left.name === right.name)
                message = ' ' + left.name + ' (' + message + ')';
              else
                message = ' mix (' + message + ')';

              addTests(message, leftTest.value, rightTest.value);
            });
          });
        });
      });
    });


    var zipWithSpec = {
      name: 'zipWith',
      restrictions: [['function: minarity 2'], ['arrayLike'], ['arrayLike']],
      validArguments: [[function(x, y) {return x + y;}], [[1, 2], 'abc', makeArrayLike(2, 3, 4)],
                      [[3, 4, 5], 'def', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(zipWithSpec, array.zipWith, function(zipWith) {
      addFuncCalledWithSpecificArityTests(zipWith, 2, [['a', 'b', 'c']]);


      var addDegenerateTests = function(message, left, right) {
        it('Works for ' + message, function() {
          var result = zipWith(function(l, r) {return l;}, left, right);

          expect(result).to.deep.equal([]);
        });
      };


      var degenerateTests = [
        {name: 'array', tests: [{type: 'empty', value: []}, {type: 'normal', value: [1, 2]}]},
        {name: 'arrayLike', tests: [{type: 'empty', value: makeArrayLike()},
                                    {type: 'normal', value: makeArrayLike(2, 3, 4)}]},
        {name: 'string', tests: [{type: 'empty', value: ''}, {type: 'normal', value: 'funkier'}]}
      ];


      degenerateTests.forEach(function(left) {
        left.tests.forEach(function(leftTest) {
          degenerateTests.forEach(function(right) {
            right.tests.forEach(function(rightTest) {
              if (leftTest.type === 'normal' && rightTest.type === 'normal')
                return;

              var message = ['LHS', leftTest.type, left.name, ',', 'RHS', rightTest.type, right.name].join(' ');
              addDegenerateTests(message, leftTest.value, rightTest.value);
            });
          });
        });
      });


      var addTests = function(message, f, left, right) {
        it('Result is an array ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var result = zipWith(f, l, r);

          expect(isArray(result)).to.equal(true);
        });


        it('Result has correct length ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var expectedLength = Math.min(l.length, r.length);
          var length = zipWith(f, l, r).length;

          expect(length).to.equal(expectedLength);
        });


        it('Every element is correct ' + message, function() {
          var l = left.slice();
          var r = right.slice();
          var elementsCorrect = zipWith(f, l, r).every(function(p, i) {
            return p === f(l[i], r[i]);
          });

          expect(elementsCorrect).to.equal(true);
        });
      };


      var tests = [
        {name: 'array', tests: [{type: 'singleton', value: [3]}, {type: 'normal', value: [1, 2]}]},
        {name: 'arrayLike', tests: [{type: 'singleton', value: makeArrayLike(5)},
                                    {type: 'normal', value: makeArrayLike(2, 3, 4)}]},
        {name: 'string', tests: [{type: 'singleton', value: 'a'}, {type: 'normal', value: 'funkier'}]}
      ];


      var addTwo = function(x, y) {return x + y;};
      tests.forEach(function(left) {
        left.tests.forEach(function(leftTest) {
          tests.forEach(function(right) {
            right.tests.forEach(function(rightTest) {
              var message = ['LHS', leftTest.type, left.name, ',', 'RHS', rightTest.type, right.name].join(' ');
              if (left.name === right.name)
                message = ' ' + left.name + ' (' + message + ')';
              else
                message = ' mix (' + message + ')';

              addTests(message, addTwo, leftTest.value, rightTest.value);
            });
          });
        });
      });
    });


    var addCommonNubTests = function(fnUnderTest, message, originalData, otherArgs, expectedLength) {
      it('Length is correct for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var length = fnUnderTest.apply(null, otherArgs.concat([data])).length;

        expect(length).to.equal(expectedLength);
      });


      it('Each value came from original for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var unique = fnUnderTest.apply(null, otherArgs.concat([data]));
        unique = splitIfNecessary(unique);
        var copiedFromSource = unique.every(function(val) {
          return data.indexOf(val) !== -1;
        });

        expect(copiedFromSource).to.equal(true);
      });


      it('Ordering maintained from original for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var unique = fnUnderTest.apply(null, otherArgs.concat([data]));
        unique = splitIfNecessary(unique);

        var sameOrder = unique.every(function(val, i) {
          if (i === 0) return true; // vacuously true

          return data.indexOf(unique[i - 1]) < data.indexOf(val);
        });

        expect(sameOrder).to.equal(true);
      });
    };


    var nubSpec = {
      name: 'nub',
      restrictions: [['arrayLike']],
      validArguments: [[[1, 2], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(nubSpec, array.nub, function(nub) {
      addReturnsEmptyOnEmptyTests(nub, []);
      addNoModificationOfOriginalTests(nub, []);
      addReturnsSameTypeTests(nub, []);


      var addTests = function(message, originalData, expectedLength) {
        addCommonNubTests(nub, message, originalData, [], expectedLength);


        it('Each value only occurs once for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var unique = nub(data);
          unique = splitIfNecessary(unique);
          var allUnique = unique.every(function(val) {
            return array.occurrences(val, unique).length === 1;
          });

          expect(allUnique).to.equal(true);
        });
      };


      addTests('singleton array', [5], 1);
      addTests('array with no duplicates', [2, 3, 4], 3);
      addTests('array with one duplicate', [2, 3, 2, 4], 3);
      addTests('array with multiple duplicates', [2, 3, 3, 4, 2, 4], 3);
      addTests('singleton arrayLike', makeArrayLike(1), 1);
      addTests('arrayLike with no duplicates', makeArrayLike(2, 3, 4), 3);
      addTests('arrayLike with one duplicate', makeArrayLike(2, 3, 2, 4), 3);
      addTests('arrayLike with multiple duplicates', makeArrayLike(2, 3, 2, 3, 4, 4), 3);
      addTests('singleton string', 'a', 1);
      addTests('string with no duplicates', 'abcd', 4);
      addTests('string with one duplicate', 'mozilla', 6);
      addTests('string with multiple duplicates', 'banana', 3);
    });


    var nubWithSpec = {
      name: 'nubWith',
      restrictions: [['function: arity 2'], ['arrayLike']],
      validArguments: [[function(x, y) {return false;}], [[1, 2, 3], 'abcd', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(nubWithSpec, array.nubWith, function(nubWith) {
      var alwaysFalse = function(x, y) {return false;};


      addReturnsEmptyOnEmptyTests(nubWith, [alwaysFalse]);
      addNoModificationOfOriginalTests(nubWith, [alwaysFalse]);
      addReturnsSameTypeTests(nubWith, [alwaysFalse]);
      addFuncCalledWithSpecificArityTests(nubWith, 2);


      var addTests = function(message, f, originalData, expectedLength) {
        addCommonNubTests(nubWith, message, originalData, [f], expectedLength);


        it('Predicate function called as often as required for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var called = 0;
          var p = function(x, y) {
            called += 1;
            return f(x, y);
          };
          nubWith(p, data);

          expect(called).to.be.at.most(data.length * (data.length - 1) / 2);
        });


        it('Each value only occurs once for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var unique = nubWith(f, data);
          unique = splitIfNecessary(unique);
          var allUnique = unique.every(function(val, i) {
            return unique.every(function(val2, j) {
              if (i === j) return true;

              if (j < i)
                return f(val2, val) === false;

              return f(val, val2) === false;
            });
          });

          expect(allUnique).to.equal(true);
        });
      };


      addTests('singleton array', alwaysFalse, [1], 1);
      addTests('array with no duplicates', function(x, y) {return x + y === 4;}, [2, 3, 4], 3);
      addTests('array with one duplicate', function(x, y) {return x + y === 4;}, [2, 3, 2, 4], 3);
      addTests('array with multiple duplicates', function(x, y) {return x.foo === y.foo;},
               [{foo: 1}, {foo: 2}, {foo: 1}, {foo: 3}, {foo: 2}], 3);
      addTests('singleton arrayLike', alwaysFalse, makeArrayLike(2), 1);
      addTests('arrayLike with no duplicates', function(x, y) {return x + y === 4;}, makeArrayLike(2, 3, 4), 3);
      addTests('arrayLike with one duplicate', function(x, y) {return x + y === 4;}, makeArrayLike(2, 3, 2, 4), 3);
      addTests('arrayLike with multiple duplicates', function(x, y) {return x.foo === y.foo;},
               makeArrayLike({foo: 1}, {foo: 2}, {foo: 1}, {foo: 3}, {foo: 2}), 3);

      var oneVowel = function(x, y) {return 'aeiou'.indexOf(x) !== -1 && 'aeiou'.indexOf(y) !== -1;};
      addTests('singleton string', oneVowel, 'a', 1);
      addTests('string with no duplicates', oneVowel, 'abcd', 4);
      addTests('string with one duplicate', oneVowel, 'java', 3);
      addTests('string with multiple duplicates', oneVowel, 'funkier', 5);
    });


    var sortSpec = {
      name: 'sort',
      restrictions: [['arrayLike']],
      validArguments: [[[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(sortSpec, array.sort, function(sort) {
      addReturnsEmptyOnEmptyTests(sort, []);
      addNoModificationOfOriginalTests(sort, []);
      addReturnsSameTypeTests(sort, []);


      var addTests = function(message, originalData) {
        addSameLengthTest(sort, message, [], originalData);


        it('Each value came from original for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var sorted = sort(data);
          sorted = splitIfNecessary(sorted);
          var copiedFromSource = sorted.every(function(val) {
            var ourOccurrences = array.occurrences(val, sorted).length;
            var originalOccurrences = array.occurrences(val, data).length;

            return data.indexOf(val) !== -1 && ourOccurrences === originalOccurrences;
          });

          expect(copiedFromSource).to.equal(true);
        });


        it('Ordering correct for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var sorted = sort(data);
          sorted = splitIfNecessary(sorted);
          var isSorted = sorted.every(function(val, i) {
            if (i === 0) return true; // vacuously true

            return sorted[i - 1] <= val;
          });

          expect(isSorted).to.equal(true);
        });
      };


      addTests('singleton array', [1]);
      addTests('array with no duplicates', [4, 2, 3]);
      addTests('array with duplicate', [4, 2, 3, 2]);
      addTests('already sorted array', [1, 2, 3]);
      addTests('worst case array', [5, 4, 3, 2, 1]);

      addTests('singleton arrayLike', makeArrayLike(1));
      addTests('arrayLike with no duplicates', makeArrayLike(5, 7, 1));
      addTests('arrayLike with duplicate', makeArrayLike(5, 7, 1, 7, 2));
      addTests('already sorted arrayLike', makeArrayLike(1, 2, 3));
      addTests('worst case arrayLike', makeArrayLike(5, 4, 3, 2, 1));

      addTests('singleton string', 'a');
      addTests('string with no duplicates', 'debc');
      addTests('string with duplicate', 'dcebc');
      addTests('already sorted string', '0123');
      addTests('worst case string', 'zyxw');
    });


    var sortWithSpec = {
      name: 'sortWith',
      restrictions: [['function: arity 2'], ['arrayLike']],
      validArguments: [[function(x, y) {return -1;}], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(sortWithSpec, array.sortWith, function(sortWith) {
      var normalCompare = function(x, y) {return x - y;};
      addReturnsEmptyOnEmptyTests(sortWith, [normalCompare]);
      addNoModificationOfOriginalTests(sortWith, [normalCompare]);
      addReturnsSameTypeTests(sortWith, [normalCompare]);
      addFuncCalledWithSpecificArityTests(sortWith, 2);


      var addTests = function(message, f, originalData) {
        addSameLengthTest(sortWith, message, [f], originalData);


        it('Each value came from original for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var sorted = sortWith(f, data);
          sorted = splitIfNecessary(sorted);
          var copiedFromSource = sorted.every(function(val) {
            var ourOccurrences = array.occurrences(val, sorted).length;
            var originalOccurrences = array.occurrences(val, data).length;

            return data.indexOf(val) !== -1 && ourOccurrences === originalOccurrences;
          });

          expect(copiedFromSource).to.equal(true);
        });


        it('Ordering correct for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var sorted = sortWith(f, data);
          sorted = splitIfNecessary(sorted);
          var result = sorted.every(function(val, i) {
            if (i === 0) return true; // vacuously true

            return f(sorted[i - 1], val) <= 0;
          });

          expect(result).to.equal(true);
        });
      };


      addTests('singleton array', normalCompare, [1]);
      addTests('array with no duplicates', function(x, y) {return x.foo - y.foo;},
                [{foo: 1}, {foo: 3}, {foo: 2}]);
      addTests('array with duplicate', function(x, y) {return x.foo - y.foo;},
                [{foo: 1}, {foo: 3}, {foo: 1}, {foo: 3}]);
      addTests('already sorted array', function(x, y) {return x.foo - y.foo;},
                [{foo: 1}, {foo: 2}, {foo: 3}]);
      addTests('worst case',  function(x, y) {return x.foo - y.foo;},
                [{foo: 3}, {foo: 2}, {foo: 1}]);

      addTests('singleton arrayLike', normalCompare, makeArrayLike(1));
      addTests('arrayLike with no duplicates', function(x, y) {return x.foo - y.foo;},
                makeArrayLike({foo: 1}, {foo: 3}, {foo: 2}));
      addTests('arrayLike with duplicate', function(x, y) {return x.foo - y.foo;},
                makeArrayLike({foo: 1}, {foo: 3}, {foo: 1}, {foo: 3}));
      addTests('already sorted arrayLike', function(x, y) {return x.foo - y.foo;},
                makeArrayLike({foo: 1}, {foo: 2}, {foo: 3}));
      addTests('worst case',  function(x, y) {return x.foo - y.foo;},
                makeArrayLike({foo: 3}, {foo: 2}, {foo: 1}));

      var stringSort = function(x, y) {
        return x.toUpperCase() < y.toUpperCase() ? -1 : x.toUpperCase() === y.toUpperCase() ? 0 : 1;
      };
      addTests('singleton string', stringSort, 'a');
      addTests('string with no duplicates', stringSort, 'debc');
      addTests('string with duplicate', stringSort, 'dcebc');
      addTests('already sorted string', stringSort, '0123');
      addTests('worst case', stringSort, 'zyxw');
    });


    var unzipSpec = {
      name: 'unzip',
      restrictions: [['strictarrayLike']],
      validArguments: [[[Pair(1, 2)], makeArrayLike(Pair(2, 3), Pair(4, 5))]]
    };


    checkFunction(unzipSpec, array.unzip, function(unzip) {
      var addThrowsWhenNotPairTest = function(bogus, message) {
        it('Throws if any element is not a Pair ' + message, function() {
          var fn = function() {
            unzip(bogus);
          };

          expect(fn).to.throw(TypeError);
        });
      };


      addThrowsWhenNotPairTest('(1)', ['a', Pair(1, 2), Pair(3, 4)]);
      addThrowsWhenNotPairTest('(2)', [Pair(1, 2), Pair(5, 6), 1, Pair(3, 4)]);
      addThrowsWhenNotPairTest('(3)', [Pair(1, 2), Pair(5, 6), Pair(3, 4), []]);
      addThrowsWhenNotPairTest('(4)', makeArrayLike('a', Pair(1, 2), Pair(3, 4)));


      var addDegenerateTest = function(message, data) {
        it('Works for degenerate ' + message + ' case', function() {
          var result = unzip(data);

          expect(isPair(result)).to.equal(true);
          expect(fst(result)).to.deep.equal([]);
          expect(snd(result)).to.deep.equal([]);
        });
      };


      addDegenerateTest('array', []);
      addDegenerateTest('arrayLike', makeArrayLike());


      var addTests = function(message, originalData) {
        it('Returns a pair for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = unzip(data);

          expect(isPair(result)).to.equal(true);
        });


        it('First element is an array for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var firstIsArray = isArray(fst(unzip(data)));

          expect(firstIsArray).to.equal(true);
        });


        it('Second element is an array for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var secondIsArray = isArray(snd(unzip(data)));

          expect(secondIsArray).to.equal(true);
        });


        it('First element has correct length for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var length = fst(unzip(data)).length;

          expect(length).to.equal(data.length);
        });


        it('Second element has correct length for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var length = snd(unzip(data)).length;

          expect(length).to.equal(data.length);
        });


        it('Doesn\'t affect the original ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var originalUnaffected = unzip(data) !== data;

          expect(originalUnaffected).to.equal(true);
        });


        it('First element correct for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var firstCorrect = fst(unzip(data)).every(function(val, i) {
            return fst(data[i]) === val;
          });

          expect(firstCorrect).to.equal(true);
        });


        it('Second element correct for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var secondCorrect = snd(unzip(data)).every(function(val, i) {
            return snd(data[i]) === val;
          });

          expect(secondCorrect).to.equal(true);
        });
      };


      addTests('singleton array', [Pair(1, 2)]);
      addTests('normal array', [Pair('a', true), Pair(3, null), Pair(1, 2), Pair({}, {})]);
      addTests('singleton arrayLike', makeArrayLike(Pair(1, 2)));
      addTests('normal arrayLike', makeArrayLike(Pair('a', true), Pair(3, null), Pair(1, 2), Pair({}, {})));
    });


    /*
     * The search and modification functions are not yet ready for implementation, until I get the API finalized.
     *
    var insertSpec = {
      name: 'insert',
      restrictions: [['positive'], [], ['arrayLike']],
      validArguments: [[0], ['1'], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(insertSpec, array.insert, function(insert) {
      addNoModificationOfOriginalTests(insert, [0, 'a']);
      addReturnsSameTypeTests(insert, [0, 'a']);


      var addIndexTest = function(message, index, val, originalData, dontThrow) {
        dontThrow = dontThrow || false;


        it((!dontThrow ? 'Does not throw' : 'Throws') + ' when ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var fn = function() {
            insert(index, val, data);
          };

          if (dontThrow)
            expect(fn).to.not.throw(TypeError);
          else
            expect(fn).to.throw(TypeError);
        });
      };


      addIndexTest('index > length (array)', 4, 1, [1, 2]);
      addIndexTest('index > length (arrayLike)', 5, 1, makeArrayLike(2, 3, 4));
      addIndexTest('index > length (string)', 10, 'a', 'bcde');
      addIndexTest('index === length (array)', 2, 1, [1, 2], true);
      addIndexTest('index === length (arrayLike)', 2, 1, makeArrayLike(2, 3), true);
      addIndexTest('index === length (string)', 4, 'a', 'bcde', true);


      var addTests = function(message, index, val, originalData) {
        addSameLengthTest(insert, 'Returned value is the correct length ' + message, [index, val], originalData, 1);


        it('Returned value has correct elements ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var newVal = insert(index, val, data);
          newVal = splitIfNecessary(newVal);
          var elementsCorrect = newVal.every(function(v, i) {
            if (i < index)
              return v === data[i];

            if (i === index)
              return v === val;

            return v === data[i - 1];
          });

          expect(elementsCorrect).to.equal(true);
        });
      };


      addTests('for array', 1, 4, [1, 2, 3]);
      addTests('for arrayLike', 1, 4, makeArrayLike(1, 2, 3));
      addTests('for string', 1, 'd', 'abc');
      addTests('for array when index === length', 3, 4, [1, 2, 3]);
      addTests('for arrayLike when index === length', 3, 4, makeArrayLike(1, 2, 3));
      addTests('for string when index === length', 3, 'd', 'abc');
      addTests('for array when index === 0', 0, 4, [1, 2, 3]);
      addTests('for arrayLike when index === 0', 0, 4, makeArrayLike(1, 2, 3));
      addTests('for string when index === 0', 0, 'd', 'abc');
      addTests('for empty array when index === 0', 0, 1, []);
      addTests('for empty arrayLike when index === 0', 0, 1, makeArrayLike());
      addTests('for empty string when index === 0', 0, 'a', '');


      it('toString called when inserting non-string in string', function() {
        var obj = {toString: function() {return 'funk';}};
        var result = insert(0, obj, 'ier');

        expect(result).to.equal('funkier');
      });
    });


    // remove and replace both throw when index >= length
    var addCommonRemoveReplaceTests = function(fnUnderTest, argsBetween) {
      argsBetween = argsBetween || [];


      var addTest = function(message, index, originalData) {
        it('Throws if index >= length ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var args = [index].concat(argsBetween).concat([data]);
          var fn = function() {
            fnUnderTest.apply(null, args);
          };

          expect(fn).to.throw(TypeError);
        });
      };


      addTest('for array (1)', 4, [1, 2, 3]);
      addTest('for array (2)', 3, [2, 3, 4]);
      addTest('for arrayLike (1)', 4, makeArrayLike(2, 3, 4));
      addTest('for arrayLike (2)', 3, makeArrayLike(3, 4, 5));
      addTest('for string (1)', 4, 'abc');
      addTest('for string (2)', 3, 'bcd');
    };


    var removeSpec = {
      name: 'remove',
      restrictions: [['positive'], ['arrayLike']],
      validArguments: [[0], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(removeSpec, array.remove, function(remove) {
      addNoModificationOfOriginalTests(remove, [0]);
      addReturnsSameTypeTests(remove, [0]);
      addCommonRemoveReplaceTests(remove);


      var addTests = function(message, index, originalData) {
        addSameLengthTest(remove, 'Returned value is the correct length for ' + message, [index], originalData, -1);


        it('Returned value has correct elements for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var newVal = remove(index, data);
          newVal = splitIfNecessary(newVal);
          var elementsCorrect = newVal.every(function(v, i) {
            if (i < index)
              return v === data[i];

            return v === data[i + 1];
          });

          expect(elementsCorrect).to.equal(true);
        });
      };


      addTests('array', 1, [1, 2, 3]);
      addTests('arrayLike', 1, makeArrayLike(1, 2, 3));
      addTests('string', 1, 'abc');
      addTests('array when index === length - 1', 2, [1, 2, 3]);
      addTests('arrayLike when index === length - 1', 1, makeArrayLike(2, 3));
      addTests('string when index === length - 1', 2, 'abc');
      addTests('array when index === 0', 0, [1, 2, 3]);
      addTests('arrayLike when index === 0', 0, makeArrayLike(3, 4));
      addTests('string when index === 0', 0, 'abc');
      addTests('singleton array when index === 0', 0, [1]);
      addTests('singleton arrayLike when index === 0', 0, makeArrayLike(2));
      addTests('singleton string when index === 0', 0, 'a');
    });


    var replaceSpec = {
      name: 'replace',
      restrictions: [['positive'], [], ['arrayLike']],
      validArguments: [[0], ['a'], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(replaceSpec, array.replace, function(replace) {
      addNoModificationOfOriginalTests(replace, [0, 'a']);
      addReturnsSameTypeTests(replace, [0, 'a']);
      addCommonRemoveReplaceTests(replace, [1]);


      var addTests = function(message, index, val, originalData) {
        addSameLengthTest(replace, message, [index, val], originalData);


        it('Returned value has correct elements for ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var newVal = replace(index, val, data);
          newVal = splitIfNecessary(newVal);
          var elementsCorrect = newVal.every(function(v, i) {
            if (i !== index)
              return v === data[i];

            return v === val;
          });

          expect(elementsCorrect).to.equal(true);
        });
      };


      addTests('array', 1, 0, [1, 2, 3]);
      addTests('arrayLike', 1, 0, makeArrayLike(2, 3, 4, 5));
      addTests('string', 1, 'd', 'abc');
      addTests('array when index === length - 1', 2, 0, [1, 2, 3]);
      addTests('arrayLike when index === length - 1', 3, 0, makeArrayLike(2, 3, 4, 5));
      addTests('string when index === length - 1', 2, 'd', 'abc');
      addTests('array when index === 0', 0, 0, [1, 2, 3]);
      addTests('arrayLike when index === 0', 0, 0, makeArrayLike(2, 3));
      addTests('string when index === 0', 0, 'd', 'abc');
      addTests('singleton array when index === 0', 0, 0, [1]);
      addTests('singleton arrayLike when index === 0', 0, 0, makeArrayLike(2));
      addTests('singleton string when index === 0', 0, 'd', 'a');


      it('toString called when replacement is non-string for string', function() {
        var obj = {toString: function() {return 'funk';}};
        var result = replace(0, obj, 'bier');

        expect(result).to.equal('funkier');
      });
    });


    var addCommonRemoveNotFoundTests = function(message, fnUnderTest, val, originalData) {
      addSameLengthTest(fnUnderTest, message, [val], originalData);


      it('Returned value has correct elements for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var newVal = fnUnderTest(val, data);
        var elementsCorrect = newVal.every(function(v, i) {
          return v === data[i];
        });

        expect(elementsCorrect).to.equal(true);
      });
    };


    var addCommonRemoveValTests = function(testAdder, fnUnderTest) {
      testAdder('array', 2, [1, 2, 3]);
      testAdder('array when value matches last entry', 3, [1, 2, 3]);
      testAdder('array when value matches first entry', 1, [1, 2, 3]);
      testAdder('singleton array when value matches', 1, [1]);
      testAdder('array with multiple matches', 1, [1, 2, 3, 1]);

      testAdder('arrayLike', 2, makeArrayLike(1, 2, 3));
      testAdder('arrayLike when value matches last entry', 3, makeArrayLike(1, 2, 3));
      testAdder('arrayLike when value matches first entry', 1, makeArrayLike(1, 2, 3));
      testAdder('singleton arrayLike when value matches', 1, makeArrayLike(1));
      testAdder('arrayLike with multiple matches', 1, makeArrayLike(1, 2, 3, 1));

      addCommonRemoveNotFoundTests('array when value not found', fnUnderTest, 4, [1, 2, 3]);
      var obj = {foo: 42};
      addCommonRemoveNotFoundTests('array when value not strictly equal', fnUnderTest, obj,
                                    [{foo: 1}, {foo: 42}, {foo: 3}]);
      testAdder('array when value strictly equal', obj, [{foo: 1}, obj, {foo: 3}]);

      addCommonRemoveNotFoundTests('arrayLike when value not found', fnUnderTest, 4, makeArrayLike(1, 2, 3));
      addCommonRemoveNotFoundTests('arrayLike when value not strictly equal', fnUnderTest, obj,
                                   makeArrayLike({foo: 1}, {foo: 42}, {foo: 3}));
      testAdder('arrayLike when value strictly equal', obj, makeArrayLike({foo: 1}, obj, {foo: 3}));
    };


    var addCommonRemoveWithTests = function(testAdder, fnUnderTest) {
      testAdder('array', fooIs42, [{foo: 1}, {foo: 42}, {foo: 3}]);
      testAdder('array when value matches last entry', function(x) {return x >= 3;}, [1, 2, 3]);
      testAdder('array when value matches first entry', function(x) {return x < 2;}, [1, 2, 3]);
      testAdder('singleton array when value matches', equals(1), [1]);
      testAdder('array with multiple matches', function(x) {return x < 10;}, [1, 2, 3, 1]);

      testAdder('arrayLike', fooIs42, makeArrayLike({foo: 1}, {foo: 42}, {foo: 3}));
      testAdder('arrayLike when value matches last entry', function(x) {return x >= 3;}, makeArrayLike(1, 2, 3));
      testAdder('arrayLike when value matches first entry', function(x) {return x < 2;}, makeArrayLike(1, 2, 3));
      testAdder('singleton arrayLike when value matches', equals(1), makeArrayLike(1));
      testAdder('arrayLike with multiple matches', function(x) {return x < 10;}, makeArrayLike(1, 2, 3, 1));

      addCommonRemoveNotFoundTests('array when value not found', fnUnderTest,
                             function(x) {return x.foo === 4;}, [{foo: 1}, {foo: 42}, {foo: 3}]);
      addCommonRemoveNotFoundTests('arrayLike when value not found', fnUnderTest,
                             function(x) {return x.foo === 4;}, makeArrayLike({foo: 1}, {foo: 42}, {foo: 3}));
    };


    var addCommonRemoveOneTests = function(fnUnderTest, message, val, originalData, isWith) {
      addSameLengthTest(fnUnderTest, 'Returned value is the correct length for ' + message, [val], originalData, -1);
      isWith = isWith || false;
      var occurrencesFn = isWith ? array.occurrencesWith : array.occurrences;


      it('Returned value has correct elements for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var newVal = fnUnderTest(val, data);

        var f = isWith ? val : function(x) {return x === val;};
        var deletionFound = false;
        var elementsCorrect = newVal.every(function(v, i) {
          if (deletionFound || f(data[i])) {
            deletionFound = true;
            return v === data[i + 1];
          }

          return v === data[i];
        });

        expect(elementsCorrect).to.equal(true);
      });


      // Any errors that would be caught by the next two tests should be caught by the previous test, however I prefer
      // these behavious to be explicit
      it('Returned value has one less occurrence of value for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var originalCount = occurrencesFn(val, data).length;
        var newVal = fnUnderTest(val, data);
        var newCount = occurrencesFn(val, newVal).length;

        expect(newCount).to.equal(originalCount - 1);
      });


      it('Removes first occurrence of value for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var originalOcc = occurrencesFn(val, data);
        var newVal = fnUnderTest(val, data);
        var newOcc = occurrencesFn(val, newVal);

        if (originalOcc.length === 1)
          expect(newOcc).to.deep.equal([]);
        else
          expect(newOcc[0]).to.equal(originalOcc[1] - 1);
      });
    };


    var removeOneSpec = {
      name: 'removeOne',
      restrictions: [[], ['strictarrayLike']],
      validArguments: [[2], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(removeOneSpec, array.removeOne, function(removeOne) {
      addNoModificationOfOriginalTests(removeOne, [0]);
      addReturnsSameTypeTests(removeOne, [0], true);


      var addTests = function(message, val, originalData) {
        addCommonRemoveOneTests(removeOne, message, val, originalData);
      };
      addCommonRemoveValTests(addTests, removeOne);
    });


    var removeOneWithSpec = {
      name: 'removeOneWith',
      restrictions: [['function: arity 1'], ['strictarrayLike']],
      validArguments: [[alwaysTrue], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(removeOneWithSpec, array.removeOneWith, function(removeOneWith) {
      addNoModificationOfOriginalTests(removeOneWith, [alwaysTrue]);
      addReturnsSameTypeTests(removeOneWith, [alwaysTrue], true);
      addFuncCalledWithSpecificArityTests(removeOneWith, 1, [], true);


      var addTests = function(message, f, originalData) {
        addCommonRemoveOneTests(removeOneWith, message, f, originalData, true);
      };
      addCommonRemoveWithTests(addTests, removeOneWith);
    });


    var addCommonRemoveAllTests = function(fnUnderTest, message, val, originalData, isWith) {
      isWith = isWith || false;
      var occurrencesFn = isWith ? array.occurrencesWith : array.occurrences;


      it('Returned value is the correct length for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var occurrences = occurrencesFn(val, data);
        var length = fnUnderTest(val, data).length;

        expect(length).to.equal(data.length - occurrences.length);
      });


      it('Returned value has correct elements for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var newVal = fnUnderTest(val, data);

        var f = isWith ? val : function(x) {return x === val;};
        var offset = 0;
        var elementsCorrect = newVal.every(function(v, i) {
          while (f(data[i + offset]))
             offset += 1;

          return data[i + offset] === v;
        });

        expect(elementsCorrect).to.equal(true);
      });


      // Any errors that would be caught by the next two tests should be caught by the previous test, however I prefer
      // these behavious to be explicit
      it('Returned value has no occurrences of value for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var newVal = fnUnderTest(val, data);
        var newCount = occurrencesFn(val, newVal).length;

        expect(newCount).to.equal(0);
      });
    };


    var removeAllSpec = {
      name: 'removeAll',
      restrictions: [[], ['strictarrayLike']],
      validArguments: [[2], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(removeAllSpec, array.removeAll, function(removeAll) {
      addNoModificationOfOriginalTests(removeAll, [0]);
      addReturnsSameTypeTests(removeAll, [0], true);


      var addTests = function(message, val, originalData) {
        addCommonRemoveAllTests(removeAll, message, val, originalData);
      };


      addCommonRemoveValTests(addTests, removeAll);
      addTests('array with all matches', 1, [1, 1, 1, 1]);
      addTests('arrayLike with all matches', 1, makeArrayLike(1, 1, 1, 1));
    });


    var removeAllWithSpec = {
      name: 'removeAllWith',
      restrictions: [['function: arity 1'], ['strictarrayLike']],
      validArguments: [[alwaysTrue], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(removeAllWithSpec, array.removeAllWith, function(removeAllWith) {
      addNoModificationOfOriginalTests(removeAllWith, [alwaysTrue]);
      addReturnsSameTypeTests(removeAllWith, [alwaysTrue], true);
      addFuncCalledWithSpecificArityTests(removeAllWith, 1, [], true);


      var addTests = function(message, f, originalData) {
        addCommonRemoveAllTests(removeAllWith, message, f, originalData, true);
      };


      addCommonRemoveWithTests(addTests, removeAllWith);
      addTests('array where every value matches', alwaysTrue, [1, 2, 3, 4]);
      addTests('arrayLike where every value matches', alwaysTrue, makeArrayLike(1, 2, 3, 4));
    });


    var addCommonReplaceNotFoundTests = function(message, fnUnderTest, val, newVal, originalData) {
      addSameLengthTest(fnUnderTest, message, [val, newVal], originalData);


      it('Returned value has correct elements for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var replaced = fnUnderTest(val, newVal, data);

        // Can't use chai's deepEqual: it won't equal(true) for arrayLike
        var allCorrect = replaced.every(function(v, i) {
          return v === data[i];
        });

        expect(allCorrect).to.equal(true);
      });
    };


    var addCommonReplaceValTests = function(testAdder, fnUnderTest) {
      testAdder('array', 2, 4, [1, 2, 3]);
      testAdder('array with multiple matches', 1, 4, [1, 2, 3, 1]);
      testAdder('arrayLike', 2, 4, makeArrayLike(1, 2, 3));
      testAdder('arrayLike with multiple matches', 1, 4, makeArrayLike(1, 2, 3, 1));

      addCommonReplaceNotFoundTests('array when value not found', fnUnderTest, 4, 5, [1, 2, 3]);
      var obj = {foo: 42};
      addCommonReplaceNotFoundTests('array when value not strictly equal', fnUnderTest, obj, {foo: 52},
                       [{foo: 1}, {foo: 42}, {foo: 3}]);
      testAdder('array when value strictly equal', obj, {foo: 62}, [{foo: 1}, obj, {foo: 3}]);

      addCommonReplaceNotFoundTests('arrayLike when value not found', fnUnderTest, 4, 5, makeArrayLike(1, 2, 3));
      addCommonReplaceNotFoundTests('arrayLike when value not strictly equal', fnUnderTest, obj, {foo: 52},
                       makeArrayLike({foo: 1}, {foo: 42}, {foo: 3}));
      testAdder('arrayLike when value strictly equal', obj, {foo: 62}, makeArrayLike({foo: 1}, obj, {foo: 3}));
    };


    var addCommonReplaceWithTests = function(testAdder, fnUnderTest) {
      testAdder('array', fooIs42, {foo: 52}, [{foo: 1}, {foo: 42}, {foo: 3}]);
      testAdder('array with multiple matches', function(x) {return x < 10;}, 11, [1, 2, 3, 1]);

      testAdder('arrayLike', fooIs42, {foo: 52}, makeArrayLike({foo: 1}, {foo: 42}, {foo: 3}));
      testAdder('arrayLike with multiple matches', function(x) {return x < 10;}, 11, makeArrayLike(1, 2, 3, 1));

      addCommonReplaceNotFoundTests('array when value not found', fnUnderTest,
                             function(x) {return x.foo === 4;}, {foo: 52}, [{foo: 1}, {foo: 42}, {foo: 3}]);
      addCommonReplaceNotFoundTests('arrayLike when value not found', fnUnderTest,
                             function(x) {return x.foo === 4;}, {foo: 52}, makeArrayLike({foo: 1}, {foo: 42}));
    };


    var addCommonReplaceOneTests = function(fnUnderTest, message, val, newVal, originalData, isWith) {
      isWith = isWith || false;
      var occurrencesFn = isWith ? array.occurrencesWith : array.occurrences;
      addSameLengthTest(fnUnderTest, message, [val, newVal], originalData);


      it('Returned value has correct elements for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var replaced = fnUnderTest(val, newVal, data);

        var found = false;
        var f = isWith ? val : function(x) {return x === val;};
        var elementsCorrect = replaced.every(function(v, i) {
          if (!found && f(data[i])) {
            found = true;
            return v === newVal;
          }

          return v === data[i];
        });

        expect(elementsCorrect).to.equal(true);
      });


      // Any errors that would be caught by the next two tests should be caught by the previous test, however I prefer
      // these behavious to be explicit
      it('Returned value has one less occurrence of old value for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var originalCount = occurrencesFn(val, data).length;
        var replaced = fnUnderTest(val, newVal, data);
        var newCount = occurrencesFn(val, replaced).length;

        expect(newCount).to.equal(originalCount - 1);
      });


      it('Replaces first occurrence of value with new for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var originalOcc = occurrencesFn(val, data);
        var replaced = fnUnderTest(val, newVal, data);
        var newSearch = isWith ? base.strictEquals(newVal) : newVal;
        var newOcc = occurrencesFn(newSearch, replaced);

        expect(newOcc[0]).to.equal(originalOcc[0]);
      });
    };


    var replaceOneSpec = {
      name: 'replaceOne',
      restrictions: [[], [], ['strictarrayLike']],
      validArguments: [[2], [4], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(replaceOneSpec, array.replaceOne, function(replaceOne) {
      addNoModificationOfOriginalTests(replaceOne, [0, 1]);
      addReturnsSameTypeTests(replaceOne, [0, 1], true);


      var addTests = function(message, val, newVal, originalData) {
        addCommonReplaceOneTests(replaceOne, message, val, newVal, originalData);
      };
      addCommonReplaceValTests(addTests, replaceOne);
    });


    var replaceOneWithSpec = {
      name: 'replaceOneWith',
      restrictions: [['function: arity 1'], [], ['strictarrayLike']],
      validArguments: [[alwaysTrue], [1], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(replaceOneWithSpec, array.replaceOneWith, function(replaceOneWith) {
      addNoModificationOfOriginalTests(replaceOneWith, [alwaysTrue, 1]);
      addReturnsSameTypeTests(replaceOneWith, [alwaysTrue, 'a'], true);
      addFuncCalledWithSpecificArityTests(replaceOneWith, 1, ['a'], true);


      var addTests = function(message, f, newVal, originalData) {
        addCommonReplaceOneTests(replaceOneWith, message, f, newVal, originalData, true);
      };
      addCommonReplaceWithTests(addTests, replaceOneWith);
    });


    var addCommonReplaceAllTests = function(fnUnderTest, message, val, newVal, originalData, isWith) {
      isWith = isWith || false;
      var occurrencesFn = isWith ? array.occurrencesWith : array.occurrences;
      addSameLengthTest(fnUnderTest, message, [val, newVal], originalData);


      it('Returned value has correct elements for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var replaced = fnUnderTest(val, newVal, data);

        var f = isWith ? val : function(x) {return x === val;};
        var elementsCorrect = replaced.every(function(v, i) {
          if (f(data[i]))
             return v === newVal;

          return data[i] === v;
        });

        expect(elementsCorrect).to.equal(true);
      });


      // Any errors that would be caught by the next two tests should be caught by the previous test, however I prefer
      // these behavious to be explicit
      it('Returned value has no occurrences of value for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var replaced = fnUnderTest(val, newVal, data);
        var newCount = occurrencesFn(val, replaced).length;

        expect(newCount).to.equal(0);
      });


      it('Replaces all occurrences of value for ' + message, function() {
        var data = sliceIfNecessary(originalData);
        var originalOcc = occurrencesFn(val, data);
        var replaced = fnUnderTest(val, newVal, data);
        var newSearch = isWith ? base.strictEquals(newVal) : newVal;
        var newOcc = occurrencesFn(newSearch, replaced);
        var result = newOcc.every(function(idx, i) {
          return idx === originalOcc[i];
        });

        expect(result).to.equal(true);
      });
    };


    var replaceAllSpec = {
      name: 'replaceAll',
      restrictions: [[], [], ['strictarrayLike']],
      validArguments: [[2], [4], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(replaceAllSpec, array.replaceAll, function(replaceAll) {
      addNoModificationOfOriginalTests(replaceAll, [0, 1]);
      addReturnsSameTypeTests(replaceAll, [0, 1], true);


      var addTests = function(message, val, newVal, originalData) {
        addCommonReplaceAllTests(replaceAll, message, val, newVal, originalData);
      };
      addCommonReplaceValTests(addTests, replaceAll);
    });


    var replaceAllWithSpec = {
      name: 'replaceAllWith',
      restrictions: [['function: arity 1'], [], ['strictarrayLike']],
      validArguments: [[alwaysTrue], ['e'], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(replaceAllWithSpec, array.replaceAllWith, function(replaceAllWith) {
      addNoModificationOfOriginalTests(replaceAllWith, [alwaysTrue, 'e']);
      addReturnsSameTypeTests(replaceAllWith, [alwaysTrue, 'e'], true);
      addFuncCalledWithSpecificArityTests(replaceAllWith, 1, ['e'], true);


      var addTests = function(message, f, newVal, originalData) {
        addCommonReplaceAllTests(replaceAllWith, message, f, newVal, originalData, true);
      };
      addCommonReplaceWithTests(addTests, replaceAllWith);

      var lessThanFive = function(x) {return x < 5;};
      addTests('array where every value matches', lessThanFive, 5, [1, 2, 3, 4]);
      addTests('arrayLike where every value matches', lessThanFive, 5, makeArrayLike(1, 2, 3, 4));
    });
    */


    var joinSpec = {
      name: 'join',
      restrictions: [[], ['strictarrayLike']],
      validArguments: [[' '], [[1, 2, 3], makeArrayLike(2, 3, 4)]]
    };


    checkFunction(joinSpec, array.join, function(join) {
      it('Works correctly for empty array', function() {
        expect(join('-', [])).to.equal('');
      });


      it('Works correctly for empty arrayLike', function() {
        expect(join('-', makeArrayLike())).to.equal('');
      });


      it('Works correctly for singleton array', function() {
        var arr = [1];

        expect(join('-', arr)).to.equal(arr[0].toString());
      });


      it('Works correctly for singleton arrayLike', function() {
        var arr = makeArrayLike(2);

        expect(join('-', arr)).to.equal(arr[0].toString());
      });


      var addTests = function(message, str, originalData) {
        it('Returns a string ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = join(str, data);

          expect(result).to.be.a('string');
        });


        it('Returned value is correct ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var joined = join(str, data);
          var s = str.toString();
          var l = s.length;
          var offset = 0;

          var result = data.every(function(val, i) {
            var valString = val.toString();

            if (joined.slice(offset, offset + valString.length) !== valString)
              return false;

            if (i === data.length - 1)
              return true;

            offset += valString.length;
            if (joined.slice(offset, offset + l) !== s)
              return false;

            offset += l;
            return true;
          });

          expect(result).to.equal(true);
        });
      };


      addTests('in normal case (array)', ':', ['a', 'b', 'c']);
      addTests('when array values are not strings', '_', [1, 2, 3]);
      addTests('when join value is not a string (array)', {toString: function() {return '-';}}, [1, 2, 3]);
      addTests('in normal case (arrayLike)', ':', makeArrayLike('a', 'b', 'c'));
      addTests('when arrayLike values are not strings', '_', makeArrayLike(true, false, 1));
      addTests('when join value is not a string (arrayLike)', {toString: function() {return '-';}}, makeArrayLike(1, 2, 3));
    });


    var flattenSpec = {
      name: 'flatten',
      restrictions: [['strictarrayLike']],
      validArguments: [[[[1, 2], [3, 4]], makeArrayLike([1, 2], [3, 4])]]
    };


    checkFunction(flattenSpec, array.flatten, function(flatten) {
      var notArray = [3, true, undefined, null, {}, function() {}];


      notArray.forEach(function(val, i) {
        var testBogus = function(type, arr, j) {
          it('Throws if any element not an ' + type + ' (' + (3 * i + j + 1) + ')', function() {
            var fn = function() {
              flatten(arr);
            };

            expect(fn).to.throw(TypeError);
          });
        };


        var bogusArr = [[val, [1, 2], [3, 4]],
                        [[1, 2], val, [3, 4]],
                        [[1, 2], [3, 4], val]];
        var bogusArrLike = [makeArrayLike(val, [1, 2], [3, 4]),
                            makeArrayLike([1, 2], val, [3, 4]),
                            makeArrayLike([1, 2], [3, 4], val)];
        bogusArr.forEach(testBogus.bind(null, 'array'));
        bogusArr.forEach(testBogus.bind(null, 'arrayLike'));
      });


      it('Returns empty array when supplied empty array', function() {
        expect(flatten([])).to.deep.equal([]);
      });


      it('Returns empty array when supplied empty arrayLike', function() {
        expect(flatten(makeArrayLike())).to.deep.equal([]);
      });


      var addTests = function(message, originalData) {
        it('Result is an array ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var result = flatten(data);

          expect(isArray(result)).to.equal(true);
        });


        it('Result has correct length ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var expected = array.sum(array.map(array.length, data.slice()));
          var flattened = flatten(data);

          expect(flattened.length).to.equal(expected);
        });


        it('Result has correct contents ' + message, function() {
          var data = sliceIfNecessary(originalData);
          var flattened = flatten(data);
          var offset = 0;

          var result = data.every(function(val) {
            val = splitIfNecessary(val);
            var result = val.every(function(val2, j) {
              return flattened[offset + j] === val2;
            });

            offset += val.length;
            return result;
          });
        });
      };


      addTests('for normal case (array)', [[1, 2], [3, 4], [5, 6]]);
      addTests('for singleton (array)', [[1]]);
      addTests('when some values are strings for array', [[1, 2], 'abc', 'funkier', [5, 6]]);
      addTests('when all values are strings for array', ['funkierJS', 'is', 'the', 'best']);
      addTests('when some values are arrayLikes', [[1, 2], makeArrayLike(3, 4), makeArrayLike(5, 6), [7, 8]]);
      addTests('when all values are arrayLikes', [makeArrayLike(1, 2), makeArrayLike(3, 4, 5)]);
      addTests('for normal case (arrayLike)', makeArrayLike(makeArrayLike(1, 2), makeArrayLike(3, 4)));

      // We can't make the singleton "arrayLike" in the normal fashion, as our makeArrayLike utility returns a copy if passed a single
      // arrayLike
      var arrayLikeSingleton = {'0': makeArrayLike(1), 'length': 1, slice: function() {return makeArrayLike(this);},
                                every: function(p) {return [].every.call(this, p);}};
      addTests('for singleton (arrayLike)', arrayLikeSingleton);
      addTests('when some values are strings for arrayLike', makeArrayLike(makeArrayLike(1, 2), 'abc', 'funkier'));
      addTests('when all values are strings for arrayLike', makeArrayLike('funkierJS', 'is', 'the', 'best'));
      addTests('when some values are arrays', makeArrayLike([1, 2], makeArrayLike(3, 4), makeArrayLike(5, 6), [7, 8]));
      addTests('when all values are arrays', makeArrayLike([1, 2], [3, 4], [5, 6, 7]));


      var addOnlyRemovesOneLayerTest = function(message, data) {
        it('Only removes one layer for ' + message, function() {
          var flattened = flatten(data);
          var result = flattened.every(function(val, i) {
            var sameType = isArray(val) === isArray(data[0][0]) && typeof(val) === typeof(data[0][0]);
            return sameType && val === data[Math.floor(i / 2)][i % 2];
          });

          expect(result).to.equal(true);
        });
      };


      addOnlyRemovesOneLayerTest('array (1)', [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]);
      addOnlyRemovesOneLayerTest('array (2)', [['funkier', 'is'], ['the', 'best']]);
      addOnlyRemovesOneLayerTest('array (3)', [makeArrayLike(1, 4), makeArrayLike(2, 3)]);
      addOnlyRemovesOneLayerTest('arrayLike (1)', makeArrayLike([[1, 2], [3, 4]], [[5, 6], [7, 8]]));
      addOnlyRemovesOneLayerTest('arrayLike (2)', makeArrayLike(['funkier', 'is'], ['the', 'best']));
      addOnlyRemovesOneLayerTest('arrayLike (3)', makeArrayLike(makeArrayLike(1, 5), makeArrayLike(2, 3)));
    });


    var flattenMapSpec = {
      name: 'flattenMap',
      restrictions: [['function: arity 1'], ['arrayLike']],
      validArguments: [[array.replicate(2)], [[1, 2, 3], 'abc', makeArrayLike(2, 3, 4)]]
    };


    checkFunction(flattenMapSpec, array.flattenMap, function(flattenMap) {
      var addTest = function(message, f, data) {
        it('Works correctly ' + message, function() {
          var result = flattenMap(f, data);

          expect(result).to.deep.equal(array.flatten(array.map(f, data)));
        });
      };


      addTest('(1)', array.range(1), [2, 3, 4, 5]);
      addTest('(2)', array.replicate(2), 'abc');
      addTest('(3)', array.range(2), makeArrayLike(4, 5, 6));
      addTest('for singleton', array.replicate(1), [1]);


      it('Throws if the function does not return an array/string', function() {
        var fn = function() {
          flattenMap(function(x) {return x + 1;}, [2, 3, 4]);
        };

        expect(fn).to.throw(TypeError);
      });
    });
  });
})();

},{"../../lib/components/array":10,"../../lib/components/base":11,"../../lib/components/curry":13,"../../lib/components/pair":20,"../../lib/components/types":23,"./testingUtilities":63,"chai":64}],48:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var base = require('../../lib/components/base');


  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;
  var ANYVALUE = testUtils.ANYVALUE;
  var NO_RESTRICTIONS = testUtils.NO_RESTRICTIONS;
  var addCurryStyleTests = testUtils.addCurryStyleTests;
  var addDoubleCurryStyleTests = testUtils.addDoubleCurryStyleTests;


  var curryModule = require('../../lib/components/curry');
  var curry = curryModule.curry;
  var objectCurry = curryModule.objectCurry;
  var arityOf = curryModule.arityOf;


  describe('base', function() {
    var expectedObjects = [];
    var expectedFunctions = ['compose', 'composeMany', 'composeOn', 'constant', 'constant0', 'flip', 'id',
                             'sectionLeft', 'sectionRight'];
    checkModule('base', base, expectedObjects, expectedFunctions);


    // Many of the tests use id: let's pull it out
    var id = base.id;


    var composeSpec = {
      name: 'compose',
      restrictions: [['function: minarity 1'], ['function: minarity 1']],
      validArguments: [[function(x) {}], [function(x) {}]]
    };


    checkFunction(composeSpec, base.compose, function(compose) {
      it('Composes two functions correctly (1)', function() {
        var f = function(x) {return x + 2;};
        var g = function(x) {return x + 1;};
        var composition = compose(f, g);

        expect(composition(1)).to.equal(f(g(1)));
      });


      it('Composes two functions correctly (2)', function() {
        var f = function(x) {return x + 3;};
        var g = function(x) {return x + 2;};
        var composition = compose(f, g);

        expect(composition(1)).to.equal(f(g(1)));
      });


      it('Calls the second function first', function() {
        var f = function(x) {return x * 2;};
        var g = function(x) {return x + 1;};
        var composition = compose(f, g);

        expect(composition(1)).to.not.equal(g(f(1)));
        expect(composition(1)).to.equal(f(g(1)));
      });


      it('Curries first function if it has arity > 1', function() {
        var f = function(a, b) {return a + b;};
        var g = function(x) {return x + 1;};
        var composition = compose(f, g);

        expect(composition(1)).to.be.a('function');
        expect(arityOf(composition(1))).to.equal(1);
      });


      it('Partially applies first function correctly if it has arity > 1 (1)', function() {
        var f = function(a, b) {return a + b;};
        var g = function(x) {return x + 1;};
        var expected = f(g(1), 1);
        var composition = compose(f, g);

        expect(composition(1)(1)).to.equal(expected);
      });


      it('Partially applies first function correctly if it has arity > 1 (2)', function() {
        var f = curry(function(a, b) {return a + b;});
        var g = function(x) {return x + 1;};
        var expected = f(g(1), 1);
        var composition = compose(f, g);

        expect(composition(1)(1)).to.equal(expected);
      });


      it('Applies first function when all arguments supplied and first function has arity > 1 (1)', function() {
        var f = function(a, b) {return a + b;};
        var g = function(x) {return x + 1;};
        var expected = f(g(1), 1);
        var composition = compose(f, g);

        expect(composition(1, 1)).to.equal(expected);
      });


      it('Applies first function when all arguments supplied and first function has arity > 1 (2)', function() {
        var f = curry(function(a, b) {return a + b;});
        var g = function(x) {return x + 1;};
        var expected = f(g(1), 1);
        var composition = compose(f, g);

        expect(composition(1, 1)).to.equal(expected);
      });


      it('Curries second function if it has arity > 1', function() {
        var id = function(x) {return x;};
        var g = function(x, y) {return x + 1;};
        var composition = compose(id, g);

        expect(composition(1)).to.be.a('function');
        expect(arityOf(composition(1))).to.equal(1);
      });


      it('Partially applies second function correctly if it has arity > 1', function() {
        var id = function(x) {return x;};
        var g = function(x, y) {return x + 1;};
        var composition = compose(id, g);

        expect(composition(1)(2)).to.equal(g(1, 2));
      });


      it('When both functions have arity > 1 and multiple arguments given to composition, only first argument passed to ' +
         ' second function', function() {
        var f = function(x, y, z) {return [].slice.call(arguments, 1);};
        var g = function(x, y) {return x + 1;};
        var composition = compose(f, g);

        expect(composition(1, 2, 3)).to.deep.equal([2, 3]);
        expect(composition(3, 10, 17)).to.deep.equal([10, 17]);
      });


      it('When original function is object curried, result passes context to first function', function() {
        var obj = {};
        var f = objectCurry(function(x) { return this; });
        var composition = compose(id, f);
        obj.composition = composition;

        expect(obj.composition(1)).to.equal(obj);
      });


      addDoubleCurryStyleTests(function(f, g) { return compose(f, g); });
    });


    var composeOnSpec = {
      name: 'composeOn',
      restrictions: [['positive'], ['function: minarity 1'], ['function: minarity 1']],
      validArguments: ANYVALUE
    };


    checkFunction(composeOnSpec, base.composeOn, function(composeOn) {
      it('Composes two functions correctly (1)', function() {
        var f = function(x) {return x + 2;};
        var g = function(x) {return x + 1;};
        var composition = composeOn(1, f, g);

        expect(composition(1)).to.equal(f(g(1)));
      });


      it('Composes two functions correctly (2)', function() {
        var f = function(h, x) {return 3 * h(x);};
        var g = curry(function(x, y, z) {return x + y + z;});
        var composition = composeOn(2, f, g);

        expect(composition(1, 2, 3)).to.equal(f(g(1, 2), 3));
      });


      it('Calls the second function first', function() {
        var times7 = function(x) {return x * 7;};
        var f = curry(function(x, y) {return x(y) * 2;});
        var g = curry(function(x, y) {return x(y) + 3;});
        var composition = composeOn(1, f, g);

        expect(composition(times7, 2)).to.not.equal(g(f(times7), 2));
        expect(composition(times7, 2)).to.equal(f(g(times7), 2));
      });


      it('Returned function has the correct arity (1)', function() {
        var f = function(x) {};
        var g = function(x, y) {};
        var composition = composeOn(1, f, g);

        expect(arityOf(composition)).to.equal(1);
      });


      it('Returned function has the correct arity (2)', function() {
        var f = function(x) {};
        var g = function(x, y) {};
        var composition = composeOn(2, f, g);

        expect(arityOf(composition)).to.equal(2);
      });


      it('Returned function has the correct arity (3)', function() {
        var f = function(x, y) {};
        var g = function(x, y) {};
        var composition = composeOn(1, f, g);

        expect(arityOf(composition)).to.equal(2);
      });


      it('Returned function has the correct arity (4)', function() {
        var f = function(x, y) {};
        var g = function(x, y) {};
        var composition = composeOn(2, f, g);

        expect(arityOf(composition)).to.equal(3);
      });


      it('Throws if the given arity exceeds the first function\'s arity (1)', function() {
        var f = function(x) {};
        var g = function() {};

        var fn = function() {
          composeOn(1, f, g);
        };

        expect(fn).to.throw(TypeError);
      });


      it('Throws if the given arity exceeds the function\'s arity (2)', function() {
        var f = function(x) {};
        var g = function(x) {};

        var fn = function() {
          composeOn(3, f, g);
        };

        expect(fn).to.throw(TypeError);
      });


      it('Throws if the outer function has arity 0', function() {
        var f = function() {};
        var g = function(x) {};

        var fn = function() {
          composeOn(1, f, g);
        };

        expect(fn).to.throw(TypeError);
      });


      it('Throws if the inner function has arity 0', function() {
        var f = function(x) {};
        var g = function() {};

        var fn = function() {
          composeOn(1, f, g);
        };

        expect(fn).to.throw(TypeError);
      });


      it('Curries first function if it has arity > 1', function() {
        var f = function(a, b) {return a(b);};
        var g = function(x, y, z) {return x * y * z + 1;};
        var composition = composeOn(2, f, g);

        expect(composition(1, 2)).to.be.a('function');
        expect(arityOf(composition(1, 2))).to.equal(1);
      });


      it('Curries second function if it has arity > 1', function() {
        var f = function(a, b) {return a;};
        var g = function(x, y, z) {return x * y * z + 1;};
        var composition = composeOn(2, f, g);

        expect(composition(1)).to.be.a('function');
        expect(composition(1, 2)).to.be.a('function');
        expect(composition(1, 2)(1)).to.be.a('function');
        expect(arityOf(composition(1, 2)(1))).to.equal(1);
      });


      addDoubleCurryStyleTests(function(f, g) { return composeOn(1, f, g); });
    });


    var idSpec = {
      name: 'id',
    };


    checkFunction(idSpec, base.id, function(id) {
      var tests = [
        {name: 'null', value: null},
        {name: 'undefined', value: undefined},
        {name: 'number', value: 42},
        {name: 'string', value: 'functional'},
        {name: 'boolean', value: true},
        {name: 'array', value: [1, 2, 3]},
        {name: 'object', value: {foo: 1, bar: 'a'}},
        {name: 'function', value: function(a, b) {}}
      ];

      tests.forEach(function(test) {
        var name = test.name;
        var value = test.value;

        it('Works correctly for value of type ' + name, function() {
          expect(id(value)).to.equal(value);
        });

        it('Ignores superfluous arguments for value of type ' + name, function() {
          expect(id(value, 'x')).to.equal(value);
        });
      });
    });


    var constantSpec = {
      name: 'constant',
    };


    checkFunction(constantSpec, base.constant, function(constant) {
      var tests = [
        {name: 'null', value: null},
        {name: 'undefined', value: undefined},
        {name: 'number', value: 42},
        {name: 'string', value: 'functional'},
        {name: 'boolean', value: 'true'},
        {name: 'array', value: [1, 2, 3]},
        {name: 'object', value: {foo: 1, bar: 'a'}},
        {name: 'function', value: function(a, b) {}}
      ];


      tests.forEach(function(test) {
        var name = test.name;
        var value = test.value;

        it('Works correctly for value of type ' + name, function() {
          tests.forEach(function(test) {
            expect(constant(value, test.value)).to.equal(value);
          });
        });

        it('Ignores superfluous arguments for value of type ' + name, function() {
          var fn = constant(value);
          expect(fn(value, 'x')).to.equal(value);
        });

        it('Returns value immediately when called with two arguments, with first of type ' + name, function() {
          expect(constant(value, 'x')).to.equal(value);
        });
      });
    });


    var constant0Spec = {
      name: 'constant0',
    };


    checkFunction(constant0Spec, base.constant0, function(constant0) {
      var tests = [
        {name: 'null', value: null},
        {name: 'undefined', value: undefined},
        {name: 'number', value: 42},
        {name: 'string', value: 'functional'},
        {name: 'boolean', value: 'true'},
        {name: 'array', value: [1, 2, 3]},
        {name: 'object', value: {foo: 1, bar: 'a'}},
        {name: 'function', value: function(a, b) {}}
      ];

      it('Returns a function of arity 0', function() {
        tests.forEach(function(test) {
          expect(arityOf(constant0(test.value))).to.equal(0);
        });
      });


      tests.forEach(function(test) {
        var name = test.name;
        var value = test.value;

        it('Works correctly for value of type ' + name, function() {
          var fn = constant0(value);

          tests.forEach(function(test) {
            expect(fn()).to.equal(value);
          });
        });

        it('Ignores superfluous arguments for value of type ' + name, function() {
          var fn = constant0(value);
          expect(fn('x')).to.equal(value);
        });
      });
    });


    var composeManySpec = {
      name: 'composeMany',
      arity: 1,
      restrictions: [['strictArrayLike']],
      validArguments: [[[function(a) {}, function() {}], testUtils.makeArrayLike(function(a) {}, function() {})]]
    };


    checkFunction(composeManySpec, base.composeMany, function(composeMany) {
      it('Throws if called with empty array', function() {
        var fn = function() {
          var composition = composeMany([]);
        };

        expect(fn).to.throw(TypeError);
      });


      var makeZeroArityTest = function(i) {
        return function() {
          var args = [id, id, id, id];
          args[i] = function() {return 3;};

          var fn = function() {
            var composition = composeMany(args);
          };

          expect(fn).to.throw(TypeError);
        };
      };


      for (var i = 0; i < 4; i++)
        it('Throws if any function has zero arity ' + (i + 1),
           makeZeroArityTest(i));


      it('Returns curried original function if supplied one function of arity 1', function() {
        var f = function(x) { return [].slice.call(arguments); };
        var g = composeMany([f]);

        expect(g.length).to.equal(1);
        expect(arityOf(g)).to.equal(1);
        expect(g).to.not.equal(f);
        expect(g(42)).to.deep.equal(f(42));
        expect(g(42, 'x')).to.deep.equal([42]);
      });


      it('Returns original function if supplied curried function of arity 1', function() {
        var f = curry(function(x) {});
        var g = composeMany([f]);

        expect(g).to.equal(f);
      });


      it('Returns curried original function if supplied one function of arity > 1', function() {
        var f = function(x, y) {return x + y;};
        var g = composeMany([f]);

        expect(g.length).to.equal(1);
        expect(arityOf(g)).to.equal(2);
        expect(g(1)(2)).to.equal(f(1, 2));
        expect(g(1, 2)).to.equal(f(1, 2));
      });


      it('Returns original function if supplied one curried function of real arity > 1', function() {
        var f = curry(function(x, y) {return x + y;});
        var g = composeMany([f]);

        expect(g).to.equal(f);
      });


      it('Acts like compose when called with two functions (1)', function() {
        var compose = base.compose;
        var f = function(x) {return x + 1;};
        var g = function(x) {return x * 2;};
        var composeM = composeMany([f, g]);
        var composed = compose(f, g);

        expect(composeM.length).to.equal(composed.length);
        expect(arityOf(composeM)).to.equal(arityOf(composed));
        expect(composeM(1)).to.equal(composed(1));
      });


      it('Acts like compose when called with two functions (2)', function() {
        var compose = base.compose;
        var f = function(x, y) {return x + y + 1;};
        var g = function(x) {return x * 2;};
        var composeM = composeMany([f, g]);
        var composed = compose(f, g);

        expect(composeM.length).to.equal(composed.length);
        expect(arityOf(composeM)).to.equal(arityOf(composed));
        expect(composeM(1)(2)).to.equal(composed(1)(2));
        expect(composeM(1, 2)).to.equal(composed(1, 2));
      });


      it('Works correctly (1)', function() {
        var composed = composeMany([id, id, id]);

        expect(composed.length).to.equal(1);
        expect(composed(1)).to.equal(id(id(id(1))));
      });


      it('Works correctly (2)', function() {
        var args = [
          function(x) {return x + 3;},
          function(x) {return x + 2;},
          function(x) {return x + 1;}
        ];
        var composed = composeMany(args);

        expect(composed.length).to.equal(1);
        expect(composed(1)).to.equal(args[0](args[1](args[2](1))));
      });


      it('Composes in right direction (1)', function() {
        var args = [
          function(x) {return x + 'three';},
          function(x) {return x + 'two';},
          function(x) {return 'one';}
        ];
        var composed = composeMany(args);

        expect(composed('a')).to.equal('onetwothree');
      });


      it('Composes in right direction (2)', function() {
        var args = [
          function(x) {return x.concat([3]);},
          function(x) {return x.concat([2]);},
          function(x) {return [x].concat([1]);}
        ];
        var composed = composeMany(args);

        expect(composed(0)).to.deep.equal([0, 1, 2, 3]);
      });


      it('Returns function with correct arity (1)', function() {
        var args = [
          function(x) {return x + 1;},
          id,
          function(x) {return 3;}
        ];
        var composed = composeMany(args);

        expect(arityOf(composed)).to.equal(1);
      });


      it('Returns function with correct arity (1)', function() {
        var args = [
          function(x, y, z) {return x + 1;},
          id,
          function(x) {return 3;}
        ];
        var composed = composeMany(args);

        expect(composed.length).to.equal(1);
        expect(arityOf(composed)).to.equal(3);
      });


      it('Only one argument fed to first composed function: remaining fed to last (1)', function() {
        var args = [
          function(x, y, z) {return [].slice.call(arguments, 1);},
          id,
          function(x) {return x;}
        ];
        var composed = composeMany(args);

        expect(composed(1, 2, 3)).to.deep.equal([2, 3]);
      });


      it('Only one argument fed to first composed function: remaining fed to last (2)', function() {
        var args = [
          id,
          function(x, y, z) {return [].slice.call(arguments);},
          id
        ];

        var composed = composeMany(args);
        var result = composed(1, 2, 3);

        expect(result).to.be.a('function');
        expect(result(2)).to.be.a('function');
        expect(result(2)(3)).to.deep.equal([1, 2, 3]);
      });


      addDoubleCurryStyleTests(function(f, g) { return composeMany([f, g]); });
    });


    var flipSpec = {
      name: 'flip',
      restrictions: [['function: maxarity 2']],
      validArguments: ANYVALUE
    };


    checkFunction(flipSpec, base.flip, function(flip) {
      it('Returns a curried version of original function when called with function of length 0', function() {
        var f = function() {return [].slice.call(arguments);};
        var flipped = flip(f);

        expect(arityOf(flipped)).to.equal(0);
        expect(flipped()).to.deep.equal([]);
        expect(flipped(42)).to.deep.equal([]);
      });


      it('Returns original function when called with curried function of length 0', function() {
        var f = curry(function() {return [].slice.call(arguments);});
        var flipped = flip(f);

        expect(flipped).to.equal(f);
      });


      it('Returns a curried version of original function when called with function of length 1', function() {
        var f = function(x) {return [].slice.call(arguments);};
        var flipped = flip(f);

        expect(arityOf(flipped)).to.equal(1);
        expect(flipped(42)).to.deep.equal(f(42));
        expect(flipped(42, 'x')).to.deep.equal([42]);
      });


      it('Returns original function when called with curried function of length 1', function() {
        var f = curry(function(x) {return [].slice.call(arguments);});
        var flipped = flip(f);

        expect(flipped).to.equal(f);
      });


      var addThrowsArityGT2Test = function(message, f) {
        it('Throws if called with a function of arity > 2 ' + message, function() {
          var fn = function() {
            var flipped = flip(f);
          };

          expect(fn).to.throw(TypeError);
        });
      };


      addThrowsArityGT2Test('(normal function)', function(x, y, z) {return 42;});
      addThrowsArityGT2Test('(curried function)', curry(function(x, y, z) {return 42;}));


      var addReturnsCurriedTest = function(message, f) {
        it('Returns a curried function ' + message, function() {
          var flipped = flip(f);

          expect(flipped.length).to.equal(1);
          expect(arityOf(flipped)).to.equal(2);
        });
      };


      addReturnsCurriedTest('(normal function)', function(x, y) {});
      addReturnsCurriedTest('(curried function)', curry(function(x, y) {}));


      it('Works correctly', function() {
        var f = function(x, y) {return [].slice.call(arguments);};
        var flipped = flip(f);

        expect(flipped(1, 2)).to.deep.equal(f(2, 1));
        expect(flipped('a', 'b')).to.deep.equal(f('b', 'a'));
      });


      addCurryStyleTests(function(f) { return flip(f); }, {arity: 2});
    });


    var sectionLeftSpec = {
      name: 'sectionLeft',
      restrictions: [['function: arity 2'], NO_RESTRICTIONS],
      validArguments: ANYVALUE
    };


    checkFunction(sectionLeftSpec, base.sectionLeft, function(sectionLeft) {
      it('Calls f with x (1)', function() {
        var f = function(x, y) {f.args = [x];};
        f.args = null;
        var val = 42;
        var g = sectionLeft(f, val);
        g(1);

        expect(f.args).to.deep.equal([val]);
      });


      it('Calls f with x (2)', function() {
        var f = function(x, y) {f.args = [x];};
        f.args = null;
        var val = 'mozilla';
        var g = sectionLeft(f, val);
        g(1);

        expect(f.args).to.deep.equal([val]);
      });


      it('Returns f(x) (1)', function() {
        var val = 42;
        var f = curry(function(x, y) {return x + y;});
        var result = sectionLeft(f, val);

        expect(result).to.be.a('function');
        expect(result.length).to.equal(1);
        expect(result(10)).to.equal(f(val, 10));
      });


      it('Returns f(x) (2)', function() {
        var val = 42;
        var f = curry(function(x, y) {return x * y;});
        var result = sectionLeft(f, val);

        expect(result).to.be.a('function');
        expect(result.length).to.equal(1);
        expect(result(10)).to.equal(f(val, 10));
      });


      it('Curries f if necessary', function() {
        var val = 42;
        var f = function(x, y) {return x + y;};
        var result = sectionLeft(f, val);

        expect(result).to.be.a('function');
        expect(result.length).to.equal(1);
        expect(result(10)).to.equal(f(val, 10));
      });


      addCurryStyleTests(function(f) { return sectionLeft(f); }, {arity: 2});
    });


    var sectionRightSpec = {
      name: 'sectionRight',
      restrictions: [['function: arity 2'], NO_RESTRICTIONS],
      validArguments: ANYVALUE
    };


    checkFunction(sectionRightSpec, base.sectionRight, function(sectionRight) {
      var addPartiallyAppliedRightTest = function(message, f, val1, val2) {
        it('Partially applies to the right (1)', function() {
          var sectioned = sectionRight(f, val1);

          expect(sectioned).to.be.a('function');
          expect(sectioned.length).to.equal(1);
          expect(sectioned(val2)).to.deep.equal(f(val2, val1));
        });
      };


      addPartiallyAppliedRightTest('(1)', curry(function(a, b) {return a - b;}), 1, 2);
      addPartiallyAppliedRightTest('(2)', function(a, b) {return [a, b];}, 3, 4);


      it('Curries f if necessary', function() {
        var f = function(a, b) {return [].slice.call(arguments);};
        var val1 = 32;
        var val2 = 10;
        var sectioned = sectionRight(f, val1);

        expect(sectioned).to.be.a('function');
        expect(sectioned.length).to.equal(1);
        expect(sectioned(val2)).to.deep.equal([val2, val1]);
      });


      addCurryStyleTests(function(f) { return sectionRight(f); }, {arity: 2});
    });
  });
})();

},{"../../lib/components/base":11,"../../lib/components/curry":13,"./testingUtilities":63,"chai":64}],49:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var curryModule = require('../../lib/components/curry');

  // Import utility functions
  var testUtils = require('./testingUtilities');
  var ANYVALUE = testUtils.ANYVALUE;
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;


  describe('curry', function() {
    var expectedObjects = [];
    var expectedFunctions = ['arityOf', 'bind', 'bindWithContextAndArity', 'curry', 'curryWithArity', 'objectCurry',
                             'objectCurryWithArity'];
    checkModule('curry', curryModule, expectedObjects, expectedFunctions);


    // The functions in this module are used in the tests for other functions. Pull them out now, to avoid an endless need to prefix
    var arityOf = curryModule.arityOf;
    var curry = curryModule.curry;
    var curryWithArity = curryModule.curryWithArity;
    var bind = curryModule.bind;
    var bindWithContextAndArity = curryModule.bindWithContextAndArity;
    var objectCurry = curryModule.objectCurry;
    var objectCurryWithArity = curryModule.objectCurryWithArity;


    /*
     * Helper for generating tests examining the basic qualities that we want a curried function to have: it should
     * be a function of length 1, and for each possible way of invoking it, it should be extensionally equal to the
     * original function.
     *
     */

    var testCurriedFunction = function(curried, original, typicalArgs, message, ctx, expected) {
      ctx = ctx || null;
      expected = expected || original.apply(ctx, typicalArgs);

      it(message + ' is a function', function() {
        expect(curried).to.be.a('function');
      });


      it(message + ' has length 1', function() {
        expect(curried.length).to.equal(1);
      });


      it(message + (/arguments?$/.test(message) ? ' then' : '') +
         ' called with all available arguments equals original function\'s result', function() {
        expect(curried.apply(ctx, typicalArgs)).to.deep.equal(expected);
      });


      // Now to test the possible combinations. We stop recursing when we are down to the last argument
      for (var i = 0, l = typicalArgs.length - 1; i < l; i++) {
        var next = curried.apply(ctx, typicalArgs.slice(0, i + 1));
        var remainingArgs = typicalArgs.slice(i + 1);
        var newMessage = message + (message.slice(-('arguments'.length)) === 'arguments' ? ' and ' : '') +
                         ' then partially applied with ' + (i + 1) + ' argument' + (i > 0 ? 's' : '');
        testCurriedFunction(next, original, remainingArgs, newMessage, ctx, expected);
      }
    };


    var aritySpec = {
      name: 'arityOf',
      restrictions: [['function']],
      validArguments: ANYVALUE
    };


    checkFunction(aritySpec, curryModule.arityOf, function(arityOf) {
      it('Works correctly for an uncurried function (1)', function() {
        var fn = function() {};

        expect(arityOf(fn)).to.equal(fn.length);
      });


      it('Works correctly for an uncurried function (2)', function() {
        var fn = function(x) {};

        expect(arityOf(fn)).to.equal(fn.length);
      });


      it('Works correctly for an uncurried function (3)', function() {
        var fn = function(x, y) {};

        expect(arityOf(fn)).to.equal(fn.length);
      });


      it('Works correctly for a curried function (1)', function() {
        var fn = function(x, y) {};
        var curried = curry(fn);

        expect(arityOf(curried)).to.equal(fn.length);
      });


      it('Works correctly for a curried function (2)', function() {
        var fn = function(x, y) {};
        var curryTo = 0;
        var curried = curryWithArity(curryTo, fn);

        expect(arityOf(curried)).to.equal(curryTo);
      });


      it('Works correctly for a curried function (3)', function() {
        var fn = function(x, y) {};
        var curried = bind({}, fn);

        expect(arityOf(curried)).to.equal(fn.length);
      });


      it('Works correctly for a curried function (4)', function() {
        var fn = function(x, y) {};
        var curryTo = 1;
        var curried = bindWithContextAndArity(curryTo, {}, fn);

        expect(arityOf(curried)).to.equal(curryTo);
      });


      it('Works correctly for a curried function (5)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y) {};
        proto.curried = objectCurry(fn);

        expect(arityOf(proto.curried)).to.equal(fn.length);
      });


      it('Works correctly for a curried function (6)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y) {};
        var curryTo = 1;
        proto.curried = objectCurryWithArity(curryTo, fn);

        expect(arityOf(proto.curried)).to.equal(curryTo);
      });


      it('Reports arguments outstanding for partially applied function (1)', function() {
        var fn = function(x, y, z) {};
        var curried = curry(fn);

        expect(arityOf(curried(1))).to.equal(fn.length - 1);
      });


      it('Reports arguments outstanding for partially applied function (2)', function() {
        var fn = function(x, y, z) {};
        var curried = curry(fn);

        expect(arityOf(curried(1)(1))).to.equal(fn.length - 2);
      });


      it('Reports arguments outstanding for partially applied function (3)', function() {
        var fn = function(x, y, z) {};
        var curried = curry(fn);

        expect(arityOf(curried(1, 1))).to.equal(fn.length - 2);
      });


      it('Reports arguments outstanding for partially applied function (4)', function() {
        var fn = function(x, y) {};
        var curried = curryWithArity(3, fn);

        expect(arityOf(curried(1))).to.equal(2);
      });


      it('Reports arguments outstanding for partially applied function (5)', function() {
        var fn = function(x, y) {};
        var curried = curryWithArity(3, fn);

        expect(arityOf(curried(1)(1))).to.equal(1);
      });


      it('Reports arguments outstanding for partially applied function (6)', function() {
        var fn = function(x, y) {};
        var curried = curryWithArity(3, fn);

        expect(arityOf(curried(1, 1))).to.equal(1);
      });


      it('Reports arguments outstanding for partially applied function (7)', function() {
        var fn = function(x, y, z) {};
        var curried = bind({}, fn);

        expect(arityOf(curried(1))).to.equal(fn.length - 1);
      });


      it('Reports arguments outstanding for partially applied function (8)', function() {
        var fn = function(x, y, z) {};
        var curried = bind({}, fn);

        expect(arityOf(curried(1)(1))).to.equal(fn.length - 2);
      });


      it('Reports arguments outstanding for partially applied function (9)', function() {
        var fn = function(x, y, z) {};
        var curried = bind({}, fn);

        expect(arityOf(curried(1, 1))).to.equal(fn.length - 2);
      });


      it('Reports arguments outstanding for partially applied function (10)', function() {
        var fn = function(x, y) {};
        var curried = bindWithContextAndArity(3, {}, fn);

        expect(arityOf(curried(1))).to.equal(2);
      });


      it('Reports arguments outstanding for partially applied function (11)', function() {
        var fn = function(x, y) {};
        var curried = bindWithContextAndArity(3, {}, fn);

        expect(arityOf(curried(1)(1))).to.equal(1);
      });


      it('Reports arguments outstanding for partially applied function (12)', function() {
        var fn = function(x, y) {};
        var curried = bindWithContextAndArity(3, {}, fn);

        expect(arityOf(curried(1, 1))).to.equal(1);
      });


      it('Reports arguments outstanding for partially applied function (13)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y, z) {};
        proto.curried = objectCurry(fn);

        expect(arityOf(obj.curried(1))).to.equal(2);
      });


      it('Reports arguments outstanding for partially applied function (14)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y, z) {};
        proto.curried = objectCurry(fn);

        expect(arityOf(obj.curried(1)(1))).to.equal(1);
      });


      it('Reports arguments outstanding for partially applied function (16)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y, z) {};
        proto.curried = objectCurry(fn);

        expect(arityOf(obj.curried(1, 1))).to.equal(1);
      });


      it('Reports arguments outstanding for partially applied function (17)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y) {};
        proto.curried = objectCurryWithArity(3, fn);

        expect(arityOf(obj.curried(1))).to.equal(2);
      });


      it('Reports arguments outstanding for partially applied function (18)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y) {};
        proto.curried = objectCurryWithArity(3, fn);

        expect(arityOf(obj.curried(1)(1))).to.equal(1);
      });


      it('Reports arguments outstanding for partially applied function (19)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y) {};
        proto.curried = objectCurryWithArity(3, fn);

        expect(arityOf(obj.curried(1, 1))).to.equal(1);
      });


      /*
       * Although _isCurried is not part of the public API, other tests need to be sure it works correctly
       *
       */

      it('Recognises when a function is not curried (1)', function() {
        var fn = function() {};

        expect(arityOf._isCurried(fn)).to.equal(false);
      });


      it('Recognises when a function is not curried (2)', function() {
        var fn = function(x) {};

        expect(arityOf._isCurried(fn)).to.equal(false);
      });


      it('Recognises when a function is not curried (3)', function() {
        var fn = function(x, y) {};

        expect(arityOf._isCurried(fn)).to.equal(false);
      });


      it('Recognises when a function is curried (1)', function() {
        var fn = curry(function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (2)', function() {
        var fn = curry(function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (3)', function() {
        var fn = curry(function(x, y) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (4)', function() {
        var fn = curry(function(x, y) {})(1);

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (5)', function() {
        var fn = curryWithArity(0, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (6)', function() {
        var fn = curryWithArity(1, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (7)', function() {
        var fn = curryWithArity(2, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (8)', function() {
        var fn = curryWithArity(2, function() {})(1);

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (9)', function() {
        var fn = curryWithArity(1, function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (10)', function() {
        var fn = curryWithArity(0, function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (11)', function() {
        var fn = curryWithArity(2, function(x, y) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (12)', function() {
        var fn = curryWithArity(2, function(x, y) {})(1);

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (13)', function() {
        var fn = bind({}, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (14)', function() {
        var fn = bind({}, function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (15)', function() {
        var fn = bind({}, function(x, y) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (16)', function() {
        var fn = bind({}, function(x, y) {})(1);

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (17)', function() {
        var fn = bindWithContextAndArity(1, {}, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (18)', function() {
        var fn = bindWithContextAndArity(2, {}, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (19)', function() {
        var fn = bindWithContextAndArity(2, {}, function() {})(1);

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (20)', function() {
        var fn = bindWithContextAndArity(1, {}, function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (21)', function() {
        var fn = bindWithContextAndArity(0, {}, function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (22)', function() {
        var fn = bindWithContextAndArity(2, {}, function(x, y) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (23)', function() {
        var fn = bindWithContextAndArity(2, {}, function(x, y) {})(1);

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (24)', function() {
        var fn = objectCurry(function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (25)', function() {
        var fn = objectCurry(function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (26)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y) {};
        proto.curried = objectCurry(fn);
        var f = obj.curried(1);

        expect(arityOf._isCurried(f)).to.equal(true);
      });


      it('Recognises when a function is curried (27)', function() {
        var fn = objectCurryWithArity(1, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (28)', function() {
        var fn = objectCurryWithArity(2, function() {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (29)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function() {};
        proto.curried = objectCurryWithArity(2, fn);
        var f = obj.curried(1);

        expect(arityOf._isCurried(f)).to.equal(true);
      });


      it('Recognises when a function is curried (30)', function() {
        var fn = objectCurryWithArity(1, function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (31)', function() {
        var fn = objectCurryWithArity(0, function(x) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (32)', function() {
        var fn = objectCurryWithArity(2, function(x, y) {});

        expect(arityOf._isCurried(fn)).to.equal(true);
      });


      it('Recognises when a function is curried (33)', function() {
        var proto = {};
        var obj = Object.create(proto);
        var fn = function(x, y) {};
        proto.curried = objectCurryWithArity(2, fn);
        var f = obj.curried(1);

        expect(arityOf._isCurried(f)).to.equal(true);
      });
    });


    var currySpec = {
      name: 'curry',
      arity: 1,
      restrictions: [['function']],
      validArguments: [ANYVALUE]
    };


    checkFunction(currySpec, curry, function(curry) {
      // We shall test curry with binary, ternary, and quarternary functions
      var testFuncs = [
        {f: function(a) {return 'foo' + a;}, args: [2], message: 'Curried unary function'},
        {f: function(a, b) {return a + b;}, args: [2, 3], message: 'Curried binary function'},
        {f: function(a, b, c) {return a * b * c;}, args: [4, 5, 6], message: 'Curried ternary function'},
        {f: function(a, b, c, d) {return a - b - c - d;}, args: [10, 9, 8, 7], message: 'Curried quarternary function'}
      ];


      testFuncs.forEach(function(testData) {
        var fn = testData.f;
        var args = testData.args;
        var message = testData.message;

        var curried = curry(fn);
        testCurriedFunction(curried, fn, args, message);
      });


      it('Underlying function called with specified argument count when invoked with superfluous arguments', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var curried = curry(f);
        var args = [1, 2, 4, 'a'];
        curried(args[0], args[1], args[2], args[3]);

        expect(invokedArgs).to.deep.equal(args.slice(0, f.length));
      });


      it('Currying a function of length 0 returns a function of length 0', function() {
        var f = function() {};
        var curried = curry(f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Currying a function of length 1 returns a function of length 1', function() {
        var f = function(x) {};
        var curried = curry(f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Previously curried function not recurried', function() {
        var f = curry(function(a, b) {});

        expect(curry(f)).to.equal(f);
      });


      it('Currying binds to null execution context (1)', function() {
        var f = curry(function(a, b) {return this;});
        var context = {f: f};
        var result = context.f(1, 2);

        expect(result).to.equal(null);
      });


      it('Currying binds to null execution context (2)', function() {
        var f = curry(function(a, b) {return this;});
        var context = {f: f};
        var result = context.f(1)(2);

        expect(result).to.equal(null);
      });


      it('Currying binds to null execution context (3)', function() {
        var f = curry(function() {return this;});
        var context = {f: f};
        var result = context.f();

        expect(result).to.equal(null);
      });


      it('Calling a curried function that expects no arguments does not throw', function() {
        var f = curry(function() {return 42;});
        var fn = function() {
          f();
        };

        expect(f).to.not.throw();
      });


      it('Calling a curried function that expects no arguments works correctly', function() {
        var expected = 'funkier';
        var f = curry(function() { return expected; });

        expect(curry(f)()).to.equal(expected);
      });


      it('Calling a curried function that awaits further arguments with no arguments throws', function() {
        var f = curry(function(x) {return 42;});
        var fn = function() {
          f();
        };

        expect(f).to.throw();
      });


      it('Functions cannot be recurried if curried with bind', function() {
        var curried = bind({}, function(x, y) {});
        var fn = function() {
          curry(curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with bindWithContextAndArity', function() {
        var curried = bindWithContextAndArity(2, {}, function() {});
        var fn = function() {
          curry(curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurry (1)', function() {
        var curried = objectCurry(function() {});
        var fn = function() {
          curry(curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurry (2)', function() {
        var curried = objectCurry(function(x, y) {});
        var obj = {foo: curried};
        var fn = function() {
          curry(obj.foo(1));
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (1)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var fn = function() {
          curry(curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (2)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var obj = {foo: curried};
        var fn = function() {
          curry(obj.foo(1));
        };

        expect(fn).to.throw();
      });
    });


    var curryWithAritySpec = {
      name: 'curryWithArity',
      restrictions: [['strictNatural'], ['function']],
      validArguments: [[1], [function() {}]]
    };


    checkFunction(curryWithAritySpec, curryWithArity, function(curryWithArity) {
      var fromCharCodes = String.fromCharCode;


      it('Currying a function of length 0 to 0 returns a function of length 0', function() {
        var f = function() {};
        var curried = curryWithArity(0, f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Currying a function of length 1 to 1 returns a function of length 1', function() {
        var f = function(x) {};
        var curried = curryWithArity(1, f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Returns a function of length 1 when a function of length 0 is curried to a length > 0', function() {
        var f = function() {};
        var curried = curryWithArity(1, f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Returns a function of length 0 when a function of length > 0 is curried to length 0', function() {
        var f = function(a, b, c) {};
        var curried = curryWithArity(0, f);

        expect(arityOf(curried)).to.equal(0);
      });


      // curryWithArity was partly motivated by the need to handle ambiguous methods on standard global objects that
      // can accept more or less arguments than their reported length, possibly exhibiting different behaviour.
      // For example, Array.reduce has a standard mandated length of 1, but is normally called with 2 parameters.
      //
      // We use String.fromCharCode in our tests. String.fromCharCode accepts any number of parameters
      // and shouldn't depend on the equation this === String holding.
      it('Sanity check: String.fromCharCode has length 1', function() {
        expect(String.fromCharCode.length).to.equal(1);
      });


      it('Sanity check: String.fromCharCode can be called without an execution context', function() {
        var code = 65;
        var fn = function() {
          return fromCharCodes(code);
        };

        expect(fn).to.not.throw(Error);
        expect(fn()).to.equal(String.fromCharCode(code));
      });


      // We shall test curryWithArity with binary, and ternary versions
      var testFuncs = [
        {f: fromCharCodes, args: [65, 66], message: 'Arbitrary length function curried as a binary function'},
        {f: fromCharCodes, args: [65, 66, 67], message: 'Arbitrary length function curried as a ternary function'}
      ];


      testFuncs.forEach(function(testData) {
        var fn = testData.f;
        var args = testData.args;
        var message = testData.message;
        var curried = curryWithArity(args.length, fn);
        testCurriedFunction(curried, fn, args, message);
      });


      it('Underlying function called with specified argument count when invoked with superfluous arguments', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var args = [1, 2, 4, 'a'];

        var curried = curryWithArity(2, f);
        curried(args[0], args[1], args[2], args[3]);

        expect(invokedArgs).to.deep.equal(args.slice(0, f.length));
      });


      it('Underlying function can be curried to a higher arity than its length', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var args = [1, 2, 4, 'a', null];

        var curried = curryWithArity(5, f);
        curried(args[0])(args[1])(args[2])(args[3])(args[4]);

        expect(invokedArgs).to.deep.equal(args);
      });


      it('Calling with curried function and function\'s arity returns original (1)', function() {
        var f = curryWithArity(2, function(a, b) {});

        expect(curryWithArity(2, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (2)', function() {
        var f = curryWithArity(1, function(a, b) {});

        expect(curryWithArity(1, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (3)', function() {
        var f = curryWithArity(0, function(a, b) {});

        expect(curryWithArity(0, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (4)', function() {
        var f = curryWithArity(1, function(a) {});

        expect(curryWithArity(1, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (5)', function() {
        var f = curryWithArity(0, function() {});

        expect(curryWithArity(0, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (6)', function() {
        var f = curry(function() {});

        expect(curryWithArity(0, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (7)', function() {
        var f = curry(function(x) {});

        expect(curryWithArity(1, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (8)', function() {
        var f = curry(function(x, y) {});

        expect(curryWithArity(2, f)).to.equal(f);
      });


      it('Curried function bound to null execution context (1)', function() {
        var f = curryWithArity(1, function(a, b) { return this; });
        var context = {foo: 42, f: f};
        var result = context.f(1, 2);

        expect(result).to.equal(null);
      });


      it('Curried function bound to null execution context (2)', function() {
        var f = curryWithArity(3, function(a, b) {return this;});
        var context = {foo: 42, f: f};
        var result = context.f(1)(2)(3);

        expect(result).to.equal(null);
      });


      it('Curried function bound to null execution context (3)', function() {
        var f = curryWithArity(0, function() {return this;});
        var context = {foo: 42, f: f};
        var result = context.f(1, 2, 3);

        expect(result).to.equal(null);
      });


      it('Calling a curried function that expects no arguments does not throw', function() {
        var f = curryWithArity(0, function(x) {return 42;});
        var fn = function() {
          f();
        };

        expect(f).to.not.throw();
      });


      it('Calling a curried function that expects no arguments works correctly', function() {
        var f = curryWithArity(0, function(x) {return 42;});
        expect(f()).to.equal(42);
      });


      it('Calling a curried function awaiting further arguments without any arguments throws', function() {
        var f = curryWithArity(1, function() {return 42;});
        var fn = function() {
          f();
        };

        expect(f).to.throw();
      });


      it('Functions can be recurried when not partially applied (1)', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var args = [1, 'x', 4, 'a', null];

        var intermediate = curryWithArity(3, f);
        intermediate.apply(null, args);
        // Sanity check
        expect(invokedArgs).to.deep.equal(args.slice(0, 3));
        invokedArgs = [];
        var curried = curryWithArity(5, intermediate);
        curried(args[0])(args[1])(args[2])(args[3])(args[4]);

        expect(invokedArgs).to.deep.equal(args);
      });


      it('Functions can be recurried when not partially applied (2)', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var args = [1, 'x', 4, 'a', null];

        var intermediate = curry(f);
        intermediate.apply(null, args);
        // Sanity check
        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
        invokedArgs = [];
        var curried = curryWithArity(5, intermediate);
        curried(args[0])(args[1])(args[2])(args[3])(args[4]);

        expect(invokedArgs).to.deep.equal(args);
      });


      it('Functions cannot be recurried if curried with bind', function() {
        var curried = bind({}, function(x, y, z) {});
        var fn = function() {
          curryWithArity(2, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with bindWithContextAndArity', function() {
        var curried = bindWithContextAndArity(2, {}, function() {});
        var fn = function() {
          curryWithArity(2, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurry (1)', function() {
        var curried = objectCurry(function() {});
        var fn = function() {
          curryWithArity(2, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurry (2)', function() {
        var curried = objectCurry(function(x, y) {});
        var obj = {foo: curried};
        var fn = function() {
          curryWithArity(2, obj.foo(1));
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (1)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var fn = function() {
          curryWithArity(3, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (2)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var obj = {foo: curried};
        var fn = function() {
          curry(obj.foo(1));
        };

        expect(fn).to.throw();
      });
    });


    var bindSpec = {
      name: 'bind',
      restrictions: [['objectlike'], ['function']],
      validArguments: ANYVALUE
    };


    checkFunction(bindSpec, bind, function(bind) {
      it('Currying a function of length 0 returns a function of length 0', function() {
        var f = function() {};
        var curried = bind({}, f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Currying a function of length 1 returns a function of length 1', function() {
        var f = function(x) {};
        var curried = bind({}, f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Underlying function called with specified argument count when invoked with superfluous arguments', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var args = [1, 2, 4, 'a'];

        var curried = bind({}, f);
        curried(args[0], args[1], args[2], args[3]);

        expect(invokedArgs).to.deep.equal(args.slice(0, f.length));
      });


      it('Calling a curried function that expects no arguments does not throw', function() {
        var f = bind({}, function() {return 42;});
        var fn = function() {
          f();
        };

        expect(f).to.not.throw();
      });


      it('Calling a curried function that expects no arguments works correctly', function() {
        var expected = 'hello, world';
        var f = bind({foo: expected}, function() { return this.foo; });
        expect(f()).to.equal(expected);
      });


      it('Calling a curried function awaiting further arguments without any arguments throws', function() {
        var f = bind({}, function(x) { return 42; });
        var fn = function() {
          f();
        };

        expect(f).to.throw();
      });


      var testFuncs = [
        {f: function(a, b) {return this.foo + a + b;}, args: [2, 3], message: 'Binary function'},
        {f: function(a) {return this.foo + a;}, args: [2], message: 'Unary function'},
        {f: function(a, b, c) {return this.foo * a * b * c;}, args: [4, 5, 6], message: 'Ternary function'},
      ];


      testFuncs.forEach(function(testData, i) {
        var fn = testData.f;
        var args = testData.args;
        var message = testData.message;
        var obj = {foo: 10};
        var curried = bind(obj, fn);
        var nativelyBound = fn.bind(obj);
        testCurriedFunction(curried, nativelyBound, args, message, obj);
      });


      it('Binds to context', function() {
        var f = function() { return this; };
        var obj = {};
        var arity = 0;
        var result = bind(obj, f)();

        expect(result).to.equal(obj);
      });


      it('Functions can be recurried when not partially applied if context is the same (1)', function() {
        var context = null;
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); context = this; };
        var args = [1, 'x', 4, 'a', null];

        var ctx = {};
        var intermediate = bind(ctx, f);
        intermediate(args[0], args[1]);
        // Sanity check
        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
        expect(context).to.equal(ctx);
        invokedArgs = [];
        context = null;

        var curried = bind(ctx, intermediate);
        curried(args[0])(args[1]);

        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
        expect(context).to.equal(ctx);
      });


      it('Functions can be recurried when not partially applied if context is the same (2)', function() {
        var context = null;
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); context = this; };
        var args = [1, 'x', 4, 'a', null];

        var ctx = {};
        var intermediate = bindWithContextAndArity(3, ctx, f);
        intermediate(args[0], args[1], args[2]);
        // Sanity check
        expect(invokedArgs).to.deep.equal(args.slice(0, 3));
        expect(context).to.equal(ctx);
        invokedArgs = [];
        context = null;

        var curried = bind(ctx, intermediate);
        curried(args[0])(args[1], args[2]);

        expect(invokedArgs).to.deep.equal(args.slice(0, 3));
        expect(context).to.equal(ctx);
      });


      it('Binding a previously bound function with the same execution context returns the same function', function() {
        var obj = {};
        var f = bind(obj, function(x) { return 42; });
        var g = bind(obj, f);

        expect(f).to.equal(g);
      });


      it('Functions cannot be bound to a different context (1)', function() {
        var ctx = {};
        var f = function(a, b) { return this; };

        var intermediate = bind(ctx, f);
        var fn = function() {
          bind({}, intermediate);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be bound to a different context (2)', function() {
        var ctx = {};
        var f = function(a, b) { return this; };

        var intermediate = bindWithContextAndArity(2, ctx, f);
        var fn = function() {
          bind({}, intermediate);
        };

        expect(fn).to.throw();
      });


      it('Functions bound to a null context by curry cannot be rebound to a different context', function() {
        var curried = curry(function(x, y) {});
        var fn = function() {
          bind({}, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions bound to a null context by curryWithArity cannot be rebound to a different context', function() {
        var curried = curryWithArity(3, function(x, y) {});
        var fn = function() {
          bind({}, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurry (1)', function() {
        var curried = objectCurry(function() {});
        var fn = function() {
          bind({}, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurry (2)', function() {
        var curried = objectCurry(function(x, y) {});
        var obj = {foo: curried};
        var fn = function() {
          bind({}, obj.foo(1));
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (1)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var fn = function() {
          bind({}, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (2)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var obj = {foo: curried};
        var fn = function() {
          bind({}, obj.foo(1));
        };

        expect(fn).to.throw();
      });
    });


    var bindWithContextAndAritySpec = {
      name: 'bindWithContextAndArity',
      restrictions: [['objectlike'], ['natural'], ['function']],
      validArguments: ANYVALUE
    };


    checkFunction(bindWithContextAndAritySpec, bindWithContextAndArity, function(bindWithContextAndArity) {
      it('Currying a function of length 0 to 0 returns a function of length 0', function() {
        var f = function() {};
        var curried = bindWithContextAndArity(0, {}, f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Currying a function of length 1 to 1 returns a function of length 1', function() {
        var f = function(x) {};
        var curried = bindWithContextAndArity(1, {}, f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Returns a function of length 1 when a function of length 0 is curried to a length > 0', function() {
        var f = function() {};
        var curried = bindWithContextAndArity(1, {}, f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Returns a function of length 0 when a function of length > 0 is curried to length 0', function() {
        var f = function(a, b, c) {};
        var curried = bindWithContextAndArity(0, {}, f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Underlying function called with specified argument count when invoked with superfluous arguments', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var args = [1, 2, 4, 'a'];

        var curried = bindWithContextAndArity(2, {}, f);
        curried(args[0], args[1], args[2], args[3]);

        expect(invokedArgs).to.deep.equal(args.slice(0, f.length));
      });


      it('Underlying function can be curried to a higher arity than its length', function() {
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); };
        var args = [1, 2, 4, 'a', null];

        var curried = bindWithContextAndArity(5, {}, f);
        curried(args[0])(args[1])(args[2])(args[3])(args[4]);

        expect(invokedArgs).to.deep.equal(args);
      });


      it('Calling a curried function that expects no arguments does not throw', function() {
        var f = bindWithContextAndArity(0, {}, function(x) {return 42;});
        var fn = function() {
          f();
        };

        expect(f).to.not.throw();
      });


      it('Calling a curried function that expects no arguments works correctly', function() {
        var expected = 'rust';
        var f = bindWithContextAndArity(0, {}, function(a, b, c) {return expected; });
        expect(f()).to.equal(expected);
      });


      it('Calling a curried function awaiting further arguments without any arguments throws', function() {
        var f = bindWithContextAndArity(1, {}, function() {return 42;});
        var fn = function() {
          f();
        };

        expect(f).to.throw();
      });


      var testFuncs = [
        {f: function(a, b) {return this.foo + a;}, args: [2, 3], message: 'Binary function curried to binary'},
        {f: function(a, b) {return this.foo + a;}, args: [2], message: 'Binary function curried to unary'},
        {f: function(a) {return this.foo * a;}, args: [4, 5, 6], message: 'Unary function curried to ternary'},
      ];


      testFuncs.forEach(function(testData) {
        var fn = testData.f;
        var args = testData.args;
        var message = testData.message;
        var obj = {foo: 10};
        var curried = bindWithContextAndArity(args.length, obj, fn);
        testCurriedFunction(curried, fn.bind(obj), args, message, obj);
      });


      it('Binds to context', function() {
        var f = function() { return this; };
        var obj = {};
        var arity = 0;
        var result = bindWithContextAndArity(arity, obj, f)();

        expect(result).to.equal(obj);
      });


      it('Functions can be recurried when not partially applied if context is the same (1)', function() {
        var context = null;
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); context = this; };
        var args = [1, 'x', 4, 'a', null];

        var ctx = {};
        var intermediate = bindWithContextAndArity(3, ctx, f);
        intermediate(args[0], args[1], args[2]);
        // Sanity check
        expect(invokedArgs).to.deep.equal(args.slice(0, 3));
        expect(context).to.equal(ctx);
        invokedArgs = [];
        context = null;

        var curried = bindWithContextAndArity(5, ctx, intermediate);
        curried(args[0])(args[1])(args[2])(args[3])(args[4]);

        expect(invokedArgs).to.deep.equal(args);
        expect(context).to.equal(ctx);
      });


      it('Functions can be recurried when not partially applied if context is the same (2)', function() {
        var context = null;
        var invokedArgs = [];
        var f = function(a, b) { invokedArgs = [].slice.call(arguments); context = this; };
        var args = [1, 'x', 4, 'a', null];

        var ctx = {};
        var intermediate = bind(ctx, f);
        intermediate(args[0], args[1]);
        // Sanity check
        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
        expect(context).to.equal(ctx);
        invokedArgs = [];
        context = null;

        var curried = bindWithContextAndArity(5, ctx, intermediate);
        curried(args[0])(args[1])(args[2])(args[3])(args[4]);

        expect(invokedArgs).to.deep.equal(args);
        expect(context).to.equal(ctx);
      });


      it('Functions cannot be bound to a different context (1)', function() {
        var ctx = {};
        var f = function(a, b) { return this; };

        var intermediate = bindWithContextAndArity(2, ctx, f);
        var fn = function() {
          bindWithContextAndArity(2, {}, intermediate);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be bound to a different context (2)', function() {
        var ctx = {};
        var f = function(a, b) { return this; };

        var intermediate = bind(ctx, f);
        var fn = function() {
          bindWithContextAndArity(2, {}, intermediate);
        };

        expect(fn).to.throw();
      });


      it('Functions bound to a null context by curry cannot be rebound to a different context', function() {
        var curried = curry(function(x, y) {});
        var fn = function() {
          bindWithContextAndArity(2, {}, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions bound to a null context by curryWithArity cannot be rebound to a different context', function() {
        var curried = curryWithArity(3, function(x, y) {});
        var fn = function() {
          bindWithContextAndArity(2, {}, curried);
        };

        expect(fn).to.throw();
      });


      it('Recurrying with same function and arity returns same function (1)', function() {
        var context = {};
        var f = function() {};
        var curried = bindWithContextAndArity(1, context, f);

        expect(bindWithContextAndArity(1, context, curried)).to.equal(curried);
      });


      it('Recurrying with same function and arity returns same function (2)', function() {
        var context = {};
        var f = function() {};
        var curried = bindWithContextAndArity(2, context, f);

        expect(bindWithContextAndArity(2, context, curried)).to.equal(curried);
      });


      it('Recurrying with same function and arity returns same function (3)', function() {
        var context = {};
        var f = function(x, y) {};
        var curried = bindWithContextAndArity(0, context, f);

        expect(bindWithContextAndArity(0, context, curried)).to.equal(curried);
      });


      it('Recurrying with same function and arity returns same function (4)', function() {
        var context = {};
        var f = function() {};
        var curried = bind(context, f);

        expect(bindWithContextAndArity(0, context, curried)).to.equal(curried);
      });


      it('Recurrying with same function and arity returns same function (5)', function() {
        var context = {};
        var f = function(x) {};
        var curried = bind(context, f);

        expect(bindWithContextAndArity(1, context, curried)).to.equal(curried);
      });


      it('Recurrying with same function and arity returns same function (6)', function() {
        var context = {};
        var f = function(x, y) {};
        var curried = bind(context, f);

        expect(bindWithContextAndArity(2, context, curried)).to.equal(curried);
      });


      it('Functions cannot be recurried if curried with objectCurry (1)', function() {
        var curried = objectCurry(function() {});
        var fn = function() {
          bindWithContextAndArity({}, 2, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurry (2)', function() {
        var curried = objectCurry(function(x, y) {});
        var obj = {foo: curried};
        var fn = function() {
          bindWithContextAndArity({}, 3, obj.foo(1));
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (1)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var fn = function() {
          bindWithContextAndArity(4, {}, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with objectCurryWithArity (2)', function() {
        var curried = objectCurryWithArity(2, function() {});
        var obj = {foo: curried};
        var fn = function() {
          bindWithContextAndArity({}, 4, obj.foo(1));
        };

        expect(fn).to.throw();
      });
    });


    var objectCurrySpec = {
      name: 'objectCurry',
      restrictions: [['function']],
      validArguments: ANYVALUE
    };


    checkFunction(objectCurrySpec, objectCurry, function(objectCurry) {
      it('Currying a function of length 0 returns a function of length 0', function() {
        var f = function() {};
        var curried = objectCurry(f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Currying a function of length 1 returns a function of length 1', function() {
        var f = function(x) {};
        var curried = objectCurry(f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Works as expected when currying a function of arity 0', function() {
        var called = false;
        var obj = {};
        obj.f = objectCurry(function() { called = true; });
        obj.f();

        expect(called).to.equal(true);
      });


      it('Works as expected when currying a function of arity 1 (1)', function() {
        var called = false;
        var obj = {};
        obj.f = objectCurry(function(x) { called = true; });
        obj.f(1);

        expect(called).to.equal(true);
      });


      it('Works as expected when currying a function of arity 1 (2)', function() {
        var called = false;
        var param = null;
        var obj = {};
        obj.f = objectCurry(function(x) { param = x; called = true; });
        obj.f(1);

        expect(called).to.equal(true);
        expect(param).to.equal(1);
      });


      it('Works as expected when currying a function of arity 2 (1)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurry(function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1, 2);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2]);
      });


      it('Works as expected when currying a function of arity 2 (2)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurry(function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1);
        expect(called).to.equal(false);
        obj.f(1)(2);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2]);
      });


      it('Works as expected when currying a function of arity 3 (1)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurry(function(x, y, z) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1, 2, 3);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2, 3]);
      });


      it('Works as expected when currying a function of arity 3 (2)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurry(function(x, y, z) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1);
        expect(called).to.equal(false);
        obj.f(1)(2);
        expect(called).to.equal(false);
        obj.f(1)(2)(3);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2, 3]);
      });


      it('Works as expected when currying a function of arity 3 (3)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurry(function(x, y, z) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(4)(5, 6);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([4, 5, 6]);
      });


      it('Works as expected when currying a function of arity 3 (4)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurry(function(x, y, z) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(4, 5)(6);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([4, 5, 6]);
      });


      it('Underlying function called with specified argument count when invoked with superfluous arguments', function() {
        var invokedArgs = [];
        var obj = {};
        obj.f = objectCurry(function(x, y) { invokedArgs = [].slice.call(arguments); });
        var args = [1, 2, 4, 'a'];
        obj.f(args[0], args[1], args[2], args[3]);

        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
      });


      it('Calling with curried function returns original (1)', function() {
        var f = objectCurry(function(a, b) {});

        expect(objectCurry(f)).to.equal(f);
      });


      it('Calling with curried function returns original (2)', function() {
        var f = objectCurryWithArity(1, function(a, b) {});

        expect(objectCurry(f)).to.equal(f);
      });


      it('Calling with curried function returns original (3)', function() {
        var f = objectCurry(function() {});

        expect(objectCurry(f)).to.equal(f);
      });


      it('Curried function bound to first invocation\'s execution context (1)', function() {
        var obj = {};
        var invoked = null;
        obj.f = objectCurry(function(x, y) { invoked = this; });
        obj.f(1, 2);

        expect(invoked).to.equal(obj);
      });


      it('Curried function bound to first invocation\'s execution context (2)', function() {
        var obj = {};
        var invoked = null;
        obj.f = objectCurry(function(x, y) { invoked = this; });
        obj.f(1)(2);

        expect(invoked).to.equal(obj);
      });


      it('Curried function bound to first invocation\'s execution context (3)', function() {
        var obj = {};
        var obj2 = {};
        var invoked = null;
        obj.f = objectCurry(function(x, y) { invoked = this; });
        obj2.f = obj.f;
        obj2.f(1)(2);

        expect(invoked).to.equal(obj2);
      });


      it('Curried function bound to first invocation\'s execution context (4)', function() {
        var obj = {};
        var invoked = null;
        obj.f = objectCurry(function() { invoked = this; });
        obj.f();

        expect(invoked).to.equal(obj);
      });


      it('Execution context isn\'t permanently bound to initial function', function() {
        var obj = {};
        var obj2 = {};
        var invoked = null;
        obj.f = objectCurry(function(x, y) { invoked = this; });
        obj.f(1, 2);
        obj2.f = obj.f;
        var fn = function() {
          obj2.f(1)(2);
        };

        expect(fn).to.not.throw();
        expect(invoked).to.equal(obj2);
      });


      it('Throws if called with no execution context', function() {
        var f = objectCurry(function(x, y) {});
        var fn = function() {
          f();
        };

        expect(fn).to.throw();
      });


      it('Calling a curried function awaiting further arguments without any establishes execution context', function() {
        var context = {};
        var f = objectCurry(function(x) {context = this;});
        var obj = {};
        var fn = function() {
          var g = f.apply(obj);
          g(1);
        };

        expect(fn).to.not.throw();
        expect(context).to.equal(obj);
      });


      it('Once execution context established, functions requiring arguments cannot be called without any', function() {
        var context = {};
        var f = objectCurry(function(x) {context = this;});
        var g = f.apply({});
        var fn = function() {
          g();
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried when not partially applied (1)', function() {
        var invoked = null;
        var invokedArgs = [];
        var obj = {};
        obj.f = objectCurry(function(x, y) { invoked = this; invokedArgs = [].slice.call(arguments); });

        var g = obj.f(1);
        var fn = function() {
          objectCurry(g);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with curry', function() {
        var curried = curry(function() {});
        var fn = function() {
          objectCurryWithArity(3, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with curryWithArity', function() {
        var curried = curryWithArity(2, function() {});
        var fn = function() {
          objectCurry(curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with bind', function() {
        var curried = bind({}, function(x, y, z) {});
        var fn = function() {
          objectCurry(curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with bindWithContextAndArity', function() {
        var curried = bindWithContextAndArity(2, {}, function() {});
        var fn = function() {
          objectCurry(curried);
        };

        expect(fn).to.throw();
      });
    });


    var objectCurryWithAritySpec = {
      name: 'objectCurryWithArity',
      restrictions: [['strictNatural'], ['function']],
      validArguments: ANYVALUE
    };


    checkFunction(objectCurryWithAritySpec, objectCurryWithArity, function(objectCurryWithArity) {
      it('Currying a function of length 0 to 0 returns a function of length 0', function() {
        var f = function() {};
        var curried = objectCurryWithArity(0, f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Currying a function of length 1 to 1 returns a function of length 1', function() {
        var f = function(x) {};
        var curried = objectCurryWithArity(1, f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Returns a function of length 1 when a function of length 0 is curried to a length > 0', function() {
        var f = function() {};
        var curried = objectCurryWithArity(1, f);

        expect(arityOf(curried)).to.equal(1);
      });


      it('Returns a function of length 0 when a function of length > 0 is curried to length 0', function() {
        var f = function(a, b, c) {};
        var curried = objectCurryWithArity(0, f);

        expect(arityOf(curried)).to.equal(0);
      });


      it('Works as expected when curried to arity 0 (1)', function() {
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(0, function() { called = true; });
        obj.f();

        expect(called).to.equal(true);
      });


      it('Works as expected when curried to arity 0 (2)', function() {
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(0, function() { called = true; });
        obj.f();

        expect(called).to.equal(true);
      });


      it('Works as expected when curried to arity 1 (1)', function() {
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(1, function() { called = true; });
        obj.f(1);

        expect(called).to.equal(true);
      });


      it('Works as expected when curried to arity 1 (2)', function() {
        var called = false;
        var param = null;
        var obj = {};
        obj.f = objectCurryWithArity(1, function(x) { param = x; called = true; });
        obj.f(1);

        expect(called).to.equal(true);
        expect(param).to.equal(1);
      });


      it('Works as expected when curried to arity 2 (1)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(2, function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1, 2);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2]);
      });


      it('Works as expected when curried to arity 2 (2)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(2, function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1)(2);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2]);
      });


      it('Works as expected when curried to arity 3 (1)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(3, function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1, 2, 3);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2, 3]);
      });


      it('Works as expected when curried to arity 3 (2)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(3, function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(1)(2)(3);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([1, 2, 3]);
      });


      it('Works as expected when curried to arity 3 (3)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(3, function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(4)(5, 6);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([4, 5, 6]);
      });


      it('Works as expected when curried to arity 3 (4)', function() {
        var invokedArgs = [];
        var called = false;
        var obj = {};
        obj.f = objectCurryWithArity(3, function(x, y) { invokedArgs = [].slice.call(arguments); called = true; });
        obj.f(4, 5)(6);

        expect(called).to.equal(true);
        expect(invokedArgs).to.deep.equal([4, 5, 6]);
      });


      it('Underlying function called with specified argument count when invoked with superfluous arguments', function() {
        var invokedArgs = [];
        var obj = {};
        obj.f = objectCurryWithArity(2, function(x, y) { invokedArgs = [].slice.call(arguments); });
        var args = [1, 2, 4, 'a'];
        obj.f(args[0], args[1], args[2], args[3]);

        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
      });


      it('Calling with curried function and function\'s arity returns original (1)', function() {
        var f = objectCurryWithArity(2, function(a, b) {});

        expect(objectCurryWithArity(2, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (2)', function() {
        var f = objectCurryWithArity(1, function(a, b) {});

        expect(objectCurryWithArity(1, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (3)', function() {
        var f = objectCurryWithArity(0, function(a, b) {});

        expect(objectCurryWithArity(0, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (4)', function() {
        var f = objectCurryWithArity(1, function(a) {});

        expect(objectCurryWithArity(1, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (5)', function() {
        var f = objectCurryWithArity(0, function() {});

        expect(objectCurryWithArity(0, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (6)', function() {
        var f = objectCurry(function() {});

        expect(objectCurryWithArity(0, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (7)', function() {
        var f = objectCurry(function(a) {});

        expect(objectCurryWithArity(1, f)).to.equal(f);
      });


      it('Calling with curried function and function\'s arity returns original (8)', function() {
        var f = objectCurry(function(x, y) {});

        expect(objectCurryWithArity(2, f)).to.equal(f);
      });


      it('Curried function bound to first invocation\'s execution context (1)', function() {
        var obj = {};
        var invoked = null;
        obj.f = objectCurryWithArity(2, function(x, y) { invoked = this; });
        obj.f(1, 2);

        expect(invoked).to.equal(obj);
      });


      it('Curried function bound to first invocation\'s execution context (2)', function() {
        var obj = {};
        var invoked = null;
        obj.f = objectCurryWithArity(3, function(x, y) { invoked = this; });
        obj.f(1)(2)(3);

        expect(invoked).to.equal(obj);
      });


      it('Curried function bound to first invocation\'s execution context (3)', function() {
        var obj = {};
        var obj2 = {};
        var invoked = null;
        obj.f = objectCurryWithArity(3, function(x, y) { invoked = this; });
        obj2.f = obj.f;
        obj2.f(1)(2, 3);

        expect(invoked).to.equal(obj2);
      });


      it('Curried function bound to first invocation\'s execution context (4)', function() {
        var obj = {};
        var invoked = null;
        obj.f = objectCurryWithArity(0, function(x, y) { invoked = this; });
        obj.f();

        expect(invoked).to.equal(obj);
      });


      it('Execution context isn\'t permanently bound to initial function', function() {
        var obj = {};
        var obj2 = {};
        var invoked = null;
        obj.f = objectCurryWithArity(3, function(x, y) { invoked = this; });
        obj.f(1, 2, 3);
        obj2.f = obj.f;
        var fn = function() {
          obj2.f(1)(2, 3);
        };

        expect(fn).to.not.throw();
        expect(invoked).to.equal(obj2);
      });


      it('Throws if called with no execution context', function() {
        var f = objectCurryWithArity(1, function(x, y) {});
        var fn = function() {
          f();
        };

        expect(fn).to.throw();
      });


      it('Calling a curried function awaiting further arguments without any establishes execution context', function() {
        var context = {};
        var f = objectCurryWithArity(1, function(x) {context = this;});
        var obj = {};
        var fn = function() {
          var g = f.apply(obj);
          g(1);
        };

        expect(fn).to.not.throw();
        expect(context).to.equal(obj);
      });


      it('Once execution context established, functions requiring arguments cannot be called without any', function() {
        var context = {};
        var f = objectCurryWithArity(1, function(x) {context = this;});
        var g = f.apply({});
        var fn = function() {
          g();
        };

        expect(fn).to.throw();
      });


      it('Functions can be recurried when not partially applied (1)', function() {
        var invoked = null;
        var invokedArgs = [];
        var obj = {};
        obj.f = objectCurryWithArity(2, function(x, y) { invoked = this; invokedArgs = [].slice.call(arguments); });
        var args = [1, 'x', 4, 'a', null];

        // Sanity check
        obj.f(args[0], args[1]);
        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
        expect(invoked).to.equal(obj);

        var obj2 = {};
        obj2.f = objectCurryWithArity(args.length, obj.f);
        obj2.f(args[0], args[1], args[2], args[3], args[4]);

        expect(invokedArgs).to.deep.equal(args);
        expect(invoked).to.equal(obj2);
      });


      it('Functions can be recurried when not partially applied (2)', function() {
        var invoked = null;
        var invokedArgs = [];
        var obj = {};
        obj.f = objectCurry(function(x, y) { invoked = this; invokedArgs = [].slice.call(arguments); });
        var args = [1, 'x', 4, 'a', null];

        // Sanity check
        obj.f(args[0], args[1]);
        expect(invokedArgs).to.deep.equal(args.slice(0, 2));
        expect(invoked).to.equal(obj);

        var obj2 = {};
        obj2.f = objectCurryWithArity(args.length, obj.f);
        obj2.f(args[0], args[1], args[2], args[3], args[4]);

        expect(invokedArgs).to.deep.equal(args);
        expect(invoked).to.equal(obj2);
      });


      it('Functions cannot be recurried when partially applied (1)', function() {
        var invoked = null;
        var invokedArgs = [];
        var obj = {};
        obj.f = objectCurryWithArity(1, function(x, y) { invoked = this; invokedArgs = [].slice.call(arguments); });

        var g = obj.f(1);
        var fn = function() {
          objectCurryWithArity(3, g);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried when partially applied (2)', function() {
        var invoked = null;
        var invokedArgs = [];
        var obj = {};
        obj.f = objectCurry(function(x, y) { invoked = this; invokedArgs = [].slice.call(arguments); });

        var g = obj.f(1);
        var fn = function() {
          objectCurryWithArity(3, g);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with curry', function() {
        var curried = curry(function() {});
        var fn = function() {
          objectCurryWithArity(3, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with curryWithArity', function() {
        var curried = curryWithArity(2, function() {});
        var fn = function() {
          objectCurryWithArity(3, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with bind', function() {
        var curried = bind({}, function(x, y, z) {});
        var fn = function() {
          objectCurryWithArity(2, curried);
        };

        expect(fn).to.throw();
      });


      it('Functions cannot be recurried if curried with bindWithContextAndArity', function() {
        var curried = bindWithContextAndArity(2, {}, function() {});
        var fn = function() {
          objectCurryWithArity(2, curried);
        };

        expect(fn).to.throw();
      });
    });
  });
})();

},{"../../lib/components/curry":13,"./testingUtilities":63,"chai":64}],50:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var date = require('../../lib/components/date');

  // Import utility functions
  var testingUtilities = require('./testingUtilities');
  var checkModule = testingUtilities.checkModule;
  var checkFunction = testingUtilities.checkFunction;


  describe('date', function() {
    var expectedObjects = [];
    var expectedFunctions = ['getCurrentTimeString', 'getDayOfMonth', 'getDayOfWeek', 'getFullYear', 'getHours',
                             'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTimezoneOffset',
                             'getUTCDayOfMonth', 'getUTCDayOfWeek', 'getUTCFullYear', 'getUTCHours',
                             'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth', 'getUTCSeconds',
                             'makeDateFromMilliseconds', 'makeDateFromString', 'makeDayDate', 'makeHourDate',
                             'makeMillisecondDate', 'makeMinuteDate', 'makeMonthDate', 'makeSecondDate',
/* TODO: I'm not yet convinced these functions are sufficiently testes
                             'safeSetDayOfMonth', 'safeSetHours', 'safeSetMilliseconds', 'safeSetMinutes',
                             'safeSetMonth', 'safeSetSeconds', 'safeSetUTCDayOfMonth', 'safeSetUTCHours',
                             'safeSetUTCMilliseconds', 'safeSetUTCMinutes', 'safeSetUTCMonth', 'safeSetUTCSeconds',
*/
                             'setDayOfMonth', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth',
                             'setSeconds', 'setTimeSinceEpoch', 'setUTCDayOfMonth', 'setUTCFullYear', 'setUTCHours',
                             'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'toDateString',
                             'toEpochMilliseconds', 'toISOString', 'toLocaleDateString', 'toTimeString', 'toUTCString'];

    checkModule('date', date, expectedObjects, expectedFunctions);


    var makeUnaryDateTest = function(desc, fnUnderTest, verifier) {
      var spec = {
        name: desc,
        restrictions: [[Date]],
        validArguments: [[new Date()]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        var addOne = function(message, date) {
          it('Works correctly ' + message, function() {
            var result = fnUnderTest(date);

            expect(result).to.equal(date[verifier]());
          });
        };


        addOne('(1)', new Date(2000, 0, 1, 0, 0, 0, 0));
        addOne('(2)', new Date());
      });
    };


    makeUnaryDateTest('getDayOfMonth', date.getDayOfMonth, 'getDate');
    makeUnaryDateTest('getDayOfWeek', date.getDayOfWeek, 'getDay');
    makeUnaryDateTest('getFullYear', date.getFullYear, 'getFullYear');
    makeUnaryDateTest('getHours', date.getHours, 'getHours');
    makeUnaryDateTest('getMilliseconds', date.getMilliseconds, 'getMilliseconds');
    makeUnaryDateTest('getMinutes', date.getMinutes, 'getMinutes');
    makeUnaryDateTest('getMonth', date.getMonth, 'getMonth');
    makeUnaryDateTest('getSeconds', date.getSeconds, 'getSeconds');
    makeUnaryDateTest('toEpochMilliseconds', date.toEpochMilliseconds, 'getTime');
    makeUnaryDateTest('getTimezoneOffset', date.getTimezoneOffset, 'getTimezoneOffset');
    makeUnaryDateTest('getUTCDayOfMonth', date.getUTCDayOfMonth, 'getUTCDate');
    makeUnaryDateTest('getUTCDayOfWeek', date.getUTCDayOfWeek, 'getUTCDay');
    makeUnaryDateTest('getUTCFullYear', date.getUTCFullYear, 'getUTCFullYear');
    makeUnaryDateTest('getUTCHours', date.getUTCHours, 'getUTCHours');
    makeUnaryDateTest('getUTCMilliseconds', date.getUTCMilliseconds, 'getUTCMilliseconds');
    makeUnaryDateTest('getUTCMinutes', date.getUTCMinutes, 'getUTCMinutes');
    makeUnaryDateTest('getUTCMonth', date.getUTCMonth, 'getUTCMonth');
    makeUnaryDateTest('getUTCSeconds', date.getUTCSeconds, 'getUTCSeconds');
    makeUnaryDateTest('toLocaleDateString', date.toLocaleDateString, 'toLocaleDateString');
    makeUnaryDateTest('toDateString', date.toDateString, 'toDateString');
    makeUnaryDateTest('toTimeString', date.toTimeString, 'toTimeString');
    makeUnaryDateTest('toISOString', date.toISOString, 'toISOString');
    makeUnaryDateTest('toUTCString', date.toUTCString, 'toUTCString');


    var makeBasicSetterTests = function(fnUnderTest, verifier) {
      it('Returns the date', function() {
        var testDate = new Date(2000, 0, 1, 0, 0, 0, 0);
        var result = fnUnderTest(2, testDate);

        expect(result).to.equal(testDate);
      });


      var addOne = function(message, date) {
        it('Works correctly ' + message, function() {
          var current = verifier(date);
          var newVal = current > 1 ? current - 1 : current + 1;
          var result = fnUnderTest(newVal, date);

          expect(verifier(result)).to.equal(newVal);
        });
      };


      addOne('(1)', new Date(2000, 0, 1, 0, 0, 0, 0));


      // fnUnderTest should have arity 2, so should be curried
      var makeDate = function() {return new Date(2000, 0, 1, 0, 0, 0);};
    };


    var makeDateSetterTests = function(desc, fnUnderTest, verifier) {
      var spec = {
        name: desc,
        arity: 2,
        restrictions: [[], [Date]],
        validArguments: [[2], [new Date()]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        makeBasicSetterTests(fnUnderTest, verifier);
      });
    };


    makeDateSetterTests('setDayOfMonth', date.setDayOfMonth, date.getDayOfMonth);
    makeDateSetterTests('setFullYear', date.setFullYear, date.getFullYear);
    makeDateSetterTests('setHours', date.setHours, date.getHours);
    makeDateSetterTests('setMilliseconds', date.setMilliseconds, date.getMilliseconds);
    makeDateSetterTests('setMinutes', date.setMinutes, date.getMinutes);
    makeDateSetterTests('setMonth', date.setMonth, date.getMonth);
    makeDateSetterTests('setSeconds', date.setSeconds, date.getSeconds);
    makeDateSetterTests('setTimeSinceEpoch', date.setTimeSinceEpoch, date.toEpochMilliseconds);
    makeDateSetterTests('setUTCDayOfMonth', date.setUTCDayOfMonth, date.getUTCDayOfMonth);
    makeDateSetterTests('setUTCFullYear', date.setUTCFullYear, date.getUTCFullYear);
    makeDateSetterTests('setUTCHours', date.setUTCHours, date.getUTCHours);
    makeDateSetterTests('setUTCMilliseconds', date.setUTCMilliseconds, date.getUTCMilliseconds);
    makeDateSetterTests('setUTCMinutes', date.setUTCMinutes, date.getUTCMinutes);
    makeDateSetterTests('setUTCMonth', date.setUTCMonth, date.getUTCMonth);
    makeDateSetterTests('setUTCSeconds', date.setUTCSeconds, date.getUTCSeconds);


/*
    var makeDateSafeSetterTests = function(desc, fnUnderTest, verifier, bounds) {
      var spec = {
        name: desc,
        restrictions: [[], [Date]],
        validArguments: [[2], [new Date()]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        makeBasicSetterTests(fnUnderTest, verifier);


        bounds.forEach(function(bound, i) {
          it('Throws for invalid values (' + (i + 1) + ')', function() {
            var testDate = new Date(2000, 0, 1, 0, 0, 0, 0);
            var fn = function() {
              fnUnderTest(bound, testDate);
            };

            expect(fn).to.throw(TypeError);
          });
        });
      });
    };


    makeDateSafeSetterTests('safeSetHours', date.safeSetHours, date.getHours, [-1, 60]);
    makeDateSafeSetterTests('safeSetMilliseconds', date.safeSetMilliseconds, date.getMilliseconds, [-1, 1000]);
    makeDateSafeSetterTests('safeSetMinutes', date.safeSetMinutes, date.getMinutes, [-1, 60]);
    makeDateSafeSetterTests('safeSetSeconds', date.safeSetSeconds, date.getSeconds, [-1, 60]);
    makeDateSafeSetterTests('safeSetUTCHours', date.safeSetUTCHours, date.getUTCHours, [-1, 60]);
    makeDateSafeSetterTests('safeSetUTCMilliseconds', date.safeSetUTCMilliseconds, date.getUTCMilliseconds, [-1, 1000]);
    makeDateSafeSetterTests('safeSetUTCMinutes', date.safeSetUTCMinutes, date.getUTCMinutes, [-1, 60]);
    makeDateSafeSetterTests('safeSetUTCSeconds', date.safeSetUTCSeconds, date.getUTCSeconds, [-1, 60]);


    // day of month is trickier, so we break it out separately
    var makeSafeDayOfMonthTests = function(desc, fnUnderTest, monthSetter, verifier) {
      var spec = {
        name: desc,
        restrictions: [[], [Date]],
        validArguments: [[2], [new Date()]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        makeBasicSetterTests(fnUnderTest, verifier);


        // Tackle some obvious invalid values first
        it('Throws for invalid values (1)', function() {
          var testDate = new Date(2000, 0, 1, 0, 0, 0, 0);
          var fn = function() {
            fnUnderTest(-1, testDate);
          };

          expect(fn).to.throw(TypeError);
        });


        it('Throws for invalid values (2)', function() {
          var testDate = new Date(2000, 0, 1, 0, 0, 0, 0);
          var fn = function() {
            fnUnderTest(32, testDate);
          };

          expect(fn).to.throw(TypeError);
        });


        // Set day to 31 in a 30 day month
        it('Throws for invalid values (3)', function() {
          var testDate = new Date(2000, 0, 1, 0, 0, 0, 0);
          monthSetter(3, testDate);
          var fn = function() {
            fnUnderTest(31, testDate);
          };

          expect(fn).to.throw(TypeError);
        });


        // Set day to 29 in a non leap-year...
        it('Throws for invalid values (4)', function() {
          var testDate = new Date(2014, 0, 1, 0, 0, 0, 0);
          monthSetter(2, testDate);
          var fn = function() {
            fnUnderTest(29, testDate);
          };

          expect(fn).to.throw(TypeError);
        });


        // ... and a real leap year
        it('Throws for invalid values (5)', function() {
          var testDate = new Date(2012, 0, 1, 0, 0, 0, 0);
          monthSetter(2, testDate);
          var fn = function() {
            fnUnderTest(29, testDate);
          };

          expect(fn).to.not.throw(TypeError);
        });
      });
    };


    makeSafeDayOfMonthTests('safeSetDayOfMonth', date.safeSetDayOfMonth,
      date.safeSetMonth, date.getDayOfMonth);
    makeSafeDayOfMonthTests('safeSetUTCDayOfMonth', date.safeSetUTCDayOfMonth,
      date.safeSetUTCMonth, date.getUTCDayOfMonth);
*/


    // Can't really write meaningful tests for this
    var gctsSpec = {name: 'getCurrentTimeString', arity: 0};
    checkFunction(gctsSpec, date.getCurrentTimeString, function() {});


    var addDateMakerTests = function(fnUnderTest, sourceFields) {
      var addOne = function(message, field, date) {
        it('Works correctly ' + message, function() {
          var result = fnUnderTest(date[field]());

          expect(result).to.be.an.instanceOf(Date);
          expect(result).to.deep.equal(date);
        });
      };

      sourceFields.forEach(function(field, i) {
        // Hack to allow deep equal checks: Dates created with toString have ms at 0
        var d = new Date();
        d.setMilliseconds(0);

        [new Date(2000, 0, 1, 0, 0, 0, 0), d].forEach(function(date, j) {
          addOne('(' + (2 * i + j + 1) + ')', field, date);
        });
      });
    };


    var mdfsSpec = {
      name: 'makeDateFromString',
      restrictions: [['string']],
      validArguments: [[new Date().toUTCString()]]
    };


    checkFunction(mdfsSpec, date.makeDateFromString, function(makeDateFromString) {
      addDateMakerTests(makeDateFromString, ['toString', 'toISOString']);


      it('Throws for unparsable string', function() {
        var fn = function() {
          makeDateFromString('a');
        };

        expect(fn).to.throw(TypeError);
      });
    });


    var mdfnSpec = {
      name: 'makeDateFromMilliseconds',
      restrictions: [['number']],
      validArguments: [[1000]]
    };


    checkFunction(mdfnSpec, date.makeDateFromMilliseconds, function(makeDateFromMilliseconds) {
      addDateMakerTests(makeDateFromMilliseconds, ['getTime']);


      it('Throws for invalid value', function() {
        var fn = function() {
          makeDateFromMilliseconds(Number.POSITIVE_INFINITY);
        };

        expect(fn).to.throw(TypeError);
      });
    });


    var testDates = [[2000, 0, 1, 0, 0, 0, 0], [2014, 11, 31, 23, 59, 59, 999]];
    var fields = ['year', 'month', 'day', 'hours', 'minutes', 'seconds', 'milliseconds'];
    var verifiers = [date.getFullYear, date.getMonth, date.getDayOfMonth, date.getHours,
                     date.getMinutes, date.getSeconds, date.getMilliseconds];

    var makeDateConstructorTests = function(desc, fnUnderTest, arity) {
      var spec = {
        name: desc,
        arity: arity
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        testDates.forEach(function(testDate, i) {
          var message = ' (' + (i + 1) + ')';
          var args = testDate.slice(0, arity);


          it('Returns a date' + message, function() {
            var result = fnUnderTest.apply(null, args);

            expect(result).to.be.an.instanceOf(Date);
          });


          verifiers.forEach(function(verifier, i) {
            it('Returned Date has correct ' + fields[i] + message, function() {
              var expected = i < arity ? args[i] : i === 2 ? 1 : 0;
              var result = fnUnderTest.apply(null, args);

              expect(verifier(result)).to.equal(expected);
            });
          });


          var makeDiscardTest = function(i) {
            return function() {
              var args = testDate.slice(0, i);
              var d = fnUnderTest.apply(null, args);
              var result = verifiers.every(function(v, j) {
                // We're not concerned about the values that aren't ignored here
                if (j < arity) return true;

                // If the arity is 2, the day will default to 1
                if (j === 2)
                  return v(d) === 1;

                // If the argument was ignored, the field should be zero
                return v(d) === 0;
              });

              expect(result).to.equal(true);
            };
          };


          for (var k = arity; k < fields.length; k++) {
            var m = ' (' + (k - arity + 1) + ')';
            it('Ignores superfluous arguments' + message + m,
                makeDiscardTest(k));
          }
        });
      });
    };


    var dateConstructors = ['makeMonthDate', 'makeDayDate', 'makeHourDate', 'makeMinuteDate',
                            'makeSecondDate', 'makeMillisecondDate'];
    dateConstructors.forEach(function(c, i) {
      makeDateConstructorTests(c, date[c], i + 2);
    });
  });
})();

},{"../../lib/components/date":14,"./testingUtilities":63,"chai":64}],51:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;


  var fn = require('../../lib/components/fn');


  var curryModule = require('../../lib/components/curry');
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;
  var bind = curryModule.bind;
  var objectCurry = curryModule.objectCurry;
  var arityOf = curryModule.arityOf;


  var base = require('../../lib/components/base');
  var id = base.id;


  var testingUtilities = require('./testingUtilities');
  var checkModule = testingUtilities.checkModule;
  var checkFunction = testingUtilities.checkFunction;
  var makeArrayLike = testingUtilities.makeArrayLike;
  var addCurryStyleTests = testingUtilities.addCurryStyleTests;


  describe('fn', function() {
    var expectedObjects = [];
    var expectedFunctions = ['apply', 'permuteLeft', 'permuteRight', 'post', 'pre', 'wrap'];
    checkModule('fn', fn, expectedObjects, expectedFunctions);


    var applySpec = {
      name: 'apply',
      restrictions: [['strictarraylike'], ['function']],
      validArguments: [[[1, 2], makeArrayLike([1, 2])], [function(x) {}]]
    };


    checkFunction(applySpec, fn.apply, function(apply) {
      it('Calls f', function() {
        var called = false;
        var f = function() {called = true;};
        apply([], f);

        expect(called).to.equal(true);
      });


      it('Calls uncurried f with null execution context (1)', function() {
        var context;
        var f = function() {context = this;};
        apply([], f);

        expect(context).to.equal(null);
      });


      it('Calls object curried f with extant execution context (2)', function() {
        var context;
        var f = objectCurry(function() {context = this;});
        apply([], f);

        expect(context).to.equal(null);
      });


      it('Calls f with given arguments (1)', function() {
        var args = null;
        var f = function(x) {args = [].slice.call(arguments);};
        var fArgs = [1];
        apply(fArgs, f);

        expect(args).to.deep.equal(fArgs);
      });


      it('Calls f with given arguments (2)', function() {
        var args = null;
        var f = function(x, y) {args = [].slice.call(arguments);};
        var fArgs = ['foo', 42];
        apply(fArgs, f);

        expect(args).to.deep.equal(fArgs);
      });


      it('Returns value of f when applied to given arguments (1)', function() {
        var f = function(x) {return x + 1;};
        var arg = 1;
        var result = apply([arg], f);

        expect(result).to.deep.equal(f(arg));
      });


      it('Returns value of f when applied to given arguments (2)', function() {
        var f = function(x, y) {return x * y;};
        var arg1 = 2;
        var arg2 = 42;
        var result = apply([arg1, arg2], f);

        expect(result).to.deep.equal(f(arg1, arg2));
      });


      it('Curries f if necessary', function() {
        var f = function(x, y) {return x + y;};
        var arg = 42;
        var result = apply([arg], f);

        expect(result).to.be.a('function');
        expect(result.length).to.equal(1);
        expect(result(10)).to.equal(f(arg, 10));
      });


      it('Curries f using curry necessary', function() {
        var f = function(x, y) {return x + y;};
        var arg = 42;
        var result = apply([arg], f);

        expect(result).to.be.a('function');
        expect(curry(result)).to.equal(result);
      });
    });


    var addCommonPermuteTests = function(fnUnderTest) {
      // Generate the same arity tests
      var fns = [function() {}, function(a) {}, function(a, b) {}, function(a, b, c) {}, function(a, b, c, d) {}];

      var addSameArityTest = function(f, i) {
        it('Returns function with correct \'real\' arity if called with uncurried function of arity ' + i, function() {
          var permuted = fnUnderTest(f);

          expect(arityOf(permuted)).to.equal(arityOf(f));
        });
      };


      var addCurriedSameArityTest = function(f, i) {
        it('Returns function with correct \'real\' arity if called with curried function of arity ' + i, function() {
          f = curry(f);
          var permuted = fnUnderTest(f);

          expect(arityOf(permuted)).to.equal(arityOf(f));
        });
      };


      fns.forEach(function(f, i) {
        addSameArityTest(f, i);
        addCurriedSameArityTest(f, i);
      });


      it('Returns original function if original is curried with arity 0', function() {
        var f = curry(function() {});
        var g = fnUnderTest(f);

        expect(g).to.equal(f);
      });


      it('Returns curried original function if original is not curried and has arity 0', function() {
        var f = function() {return [].slice.call(arguments);};
        var g = fnUnderTest(f);

        expect(g).to.not.equal(f);
        // The curried function should ignore superfluous arguments
        expect(g(1, 2, 3)).to.deep.equal([]);
      });


      it('Returns original function if original is curried with arity 1', function() {
        var f = curry(function(x) {});
        var g = fnUnderTest(f);

        expect(g).to.equal(f);
      });


      it('Returns curried original function if original is not curried and has arity 1', function() {
        var f = function(x) {return [].slice.call(arguments);};
        var g = fnUnderTest(f);

        expect(g).to.not.equal(f);
        // The curried function should ignore superfluous arguments
        expect(g(1, 2, 3)).to.deep.equal([1]);
      });


      it('New function returns same result as original when called with uncurried function of arity 2', function() {
        var f = function(x, y) {return x - y;};
        var permuted = fnUnderTest(f);

        expect(permuted(1, 2)).to.equal(f(2, 1));
      });


      it('New function returns same result as original when called with curried function of arity 2', function() {
        var f = curry(function(x, y) {return x - y;});
        var permuted = fnUnderTest(f);

        expect(permuted(1, 2)).to.equal(f(2, 1));
      });


      it('Equivalent to flip when called with an uncurried function of arity 2', function() {
        var f = function(x, y) {return x - y;};
        var flipped = base.flip(f);
        var permuted = fnUnderTest(f);

        expect(permuted(1, 2)).to.equal(flipped(1, 2));
      });


      it('Equivalent to flip when called with an curried function of arity 2', function() {
        var f = curry(function(x, y) {return x - y;});
        var flipped = base.flip(f);
        var permuted = fnUnderTest(f);

        expect(permuted(1, 2)).to.equal(flipped(1, 2));
      });


      addCurryStyleTests(function(f) { return fnUnderTest(f); });


      it('Execution context supplied to any objectCurried inputs', function() {
        var context;
        var f = objectCurry(function() { context = this; });
        var g = fnUnderTest(f);
        var obj = {};
        g.apply(obj);

        expect(context).to.equal(obj);
      });
    };


    var permuteLeftSpec = {
      name: 'permuteLeft',
      restrictions: [['function']],
      validArguments: [[function() {}]]
    };


    checkFunction(permuteLeftSpec, fn.permuteLeft, function(permuteLeft) {
      addCommonPermuteTests(permuteLeft);


      // To test higher arities, we will generate a series of tests for arities 3 and 4
      var params = [1, 'a', undefined, true];
      var baseFunc = function() {return [].slice.call(arguments);};


      var addCallsOriginalTest = function(i) {
        it('Calls original function for function of arity ' + i, function() {
          var called = false;
          var args = params.slice(0, i);
          var fn = curryWithArity(i, function() {called = true;});
          var permuted = permuteLeft(fn);
          permuted.apply(null, args);

          expect(called).to.equal(true);
        });
      };


      var addPermutesArgsTest = function(i) {
        it('Correctly permutes arguments for function of arity ' + i, function() {
          var args = params.slice(0, i);
          var fn = curryWithArity(i, baseFunc);
          var permuted = permuteLeft(fn);
          var result = permuted.apply(null, args);
          var expected = [args[i - 1]].concat(args.slice(0, i - 1));

          expect(result).to.deep.equal(expected);
        });
      };


      var addSameResultTest = function(i) {
        it('Returns same result as original for function of arity ' + i, function() {
          var args = params.slice(0, i);
          var fn = curryWithArity(i, function() {return [].slice.call(arguments).sort();});
          var permuted = permuteLeft(fn);
          var originalResult = fn.apply(null, args.slice(1).concat([args[0]]));
          var result = permuted.apply(null, args);

          expect(result).to.deep.equal(originalResult);
        });
      };


      for (var i = 3; i < 5; i++) {
        addCallsOriginalTest(i);
        addPermutesArgsTest(i);
        addSameResultTest(i);
      }
    });


    var permuteRightSpec = {
      name: 'permuteRight',
      restrictions: [['function']],
      validArguments: [[function() {}]]
    };


    checkFunction(permuteRightSpec, fn.permuteRight, function(permuteRight) {
      addCommonPermuteTests(permuteRight);


      // For higher arities, we will generate a series of tests for arities 3 and 4
      var params = [1, 'a', undefined, true];
      var baseFunc = function() {return [].slice.call(arguments);};


      var addCallsOriginalTest = function(i) {
        it('Calls original function for function of arity ' + i, function() {
          var called = false;
          var args = params.slice(0, i);
          var fn = curryWithArity(i, function() {called = true;});
          var permuted = permuteRight(fn);
          // Lack of assignment is deliberate: we only care about the side-effect
          permuted.apply(null, args);

          expect(called).to.equal(true);
        });
      };


      var addPermutesArgsTest = function(i) {
        it('Correctly permutes arguments for function of arity ' + i, function() {
          var args = params.slice(0, i);
          var fn = curryWithArity(i, baseFunc);
          var permuted = permuteRight(fn);
          var result = permuted.apply(null, args);
          var expected = args.slice(1).concat([args[0]]);

          expect(result).to.deep.equal(expected);
        });
      };


      var addSameResultTest = function(i) {
        it('Returns same result as original for function of arity ' + i, function() {
          var args = params.slice(0, i);
          var fn = curryWithArity(i, function() {return [].slice.call(arguments).sort();});
          var permuted = permuteRight(fn);
          var originalResult = fn.apply(null, args.slice(1).concat([args[0]]));
          var result = permuted.apply(null, args);

          expect(result).to.deep.equal(originalResult);
        });
      };


      for (var i = 3; i < 5; i++) {
        addCallsOriginalTest(i);
        addPermutesArgsTest(i);
        addSameResultTest(i);
      }
    });


    var addReturnsFunctionTest = function(fnUnderTest, args) {
      it('Returns a function', function() {
        var result = fnUnderTest.apply(null, args);

        expect(result).to.be.a('function');
      });
    };


    var addCommonWrapTests = function(fnUnderTest, isWrap) {
      isWrap = isWrap || false;


      addReturnsFunctionTest(fnUnderTest, isWrap ? [function() {}, function() {}, function() {}] :
                                                   [function() {}, function() {}]);


      var addCorrectArityTest = function(message, g, f) {
        it('Returned function has correct arity ' + message, function() {
          var result = isWrap ? fnUnderTest(g, g, f) : fnUnderTest(g, f);

          expect(arityOf(result)).to.equal(f.length);
        });
      };


      addCorrectArityTest('(1)', function() {}, function() {});
      addCorrectArityTest('(2)', function() {}, function(x) {});
      addCorrectArityTest('(3)', function(x) {}, function(x, y) {});


      var addCallsOriginalWithArgsTest = function(message, args) {
        it('Calls the original function with the given arguments ' + message, function() {
          var fArgs = null;
          var f = args.length === 2 ? function(x, y) {fArgs = [].slice.call(arguments);} :
                                      function(x) {fArgs = [].slice.call(arguments);};
          var g = function() {};
          var newFn = isWrap ? fnUnderTest(g, g, f) : fnUnderTest(g, f);
          newFn.apply(null, args);

          expect(fArgs).to.deep.equal(args);
        });
      };


      addCallsOriginalWithArgsTest('(1)', [1, 2]);
      addCallsOriginalWithArgsTest('(2)', ['funkier']);


      it('Calls the original function with preserved execution context', function() {
        var exc;
        var f = objectCurry(function(x, y) {exc = this;});
        var g = function() {};
        var newFn = isWrap ? fnUnderTest(g, g, f) : fnUnderTest(g, f);
        var args = ['a', 'b'];
        var obj = {};
        newFn.apply(obj, args);

        expect(exc).to.equal(obj);
      });


      var addReturnsOriginalsValueTest = function(message, f, args) {
        it('Returns the original function\'s return value ' + message, function() {
          var g = function() {};
          var newFn = isWrap ? fnUnderTest(g, g, f) : fnUnderTest(g, f);
          var result = newFn.apply(null, args);

          expect(result).to.equal(f.apply(null, args));
        });
      };


      addReturnsOriginalsValueTest('(1)', function(x, y) {return x + y;}, [1, 2]);
      addReturnsOriginalsValueTest('(2)', function(x, y) {return 42;}, [1, 2]);
    };


    var addCommonPreTests = function(fnUnderTest, isWrap) {
      isWrap = isWrap || false;


      var addCallsPreWithArgsTest = function(message, f, args) {
        it('Calls the pre function with the given arguments ' + message, function() {
          var preArgs = null;
          var pre = function(args) {preArgs = args;};
          var post = function() {};
          var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(pre, f);
          newFn.apply(null, args);

          expect(preArgs).to.deep.equal(args);
        });
      };


      addCallsPreWithArgsTest('(1)', function(x, y) {}, [1, 2]);
      addCallsPreWithArgsTest('(2)', function(x) {}, ['funkier']);


      it('Calls the pre function with preserved execution context', function() {
        var preExc;
        var pre = function() {preExc = this;};
        var post = function() {};
        var f = objectCurry(function() {});
        var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(pre, f);
        var args = ['a', 'b'];
        var obj = {};
        newFn.apply(obj, args);

        expect(preExc).to.equal(obj);
      });


      it('Calls the pre function before the original function', function() {
        var origCalled = false;
        var preCalledBefore = false;

        var f = function() {origCalled = true;};
        var pre = function() {preCalledBefore = !origCalled;};
        var post = function() {};
        var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(pre, f);
        var args = ['funkier'];
        newFn.apply(null, args);

        expect(preCalledBefore).to.equal(true);
      });


      it('Disregards the fnUnderTest function\'s return value', function() {
        var f = function(x, y) {return x + y;};
        var pre = function() {return 42;};
        var post = function() {};
        var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(pre, f);
        var args = [1, 2];
        var result = newFn.apply(null, args);

        expect(result).to.not.equal(pre.apply(null, args));
        expect(result).to.equal(f.apply(null, args));
      });
    };


    var preSpec = {
      name: 'pre',
      restrictions: [['function'], ['function']],
      validArguments: [[function() {}], [function() {}]]
    };


    checkFunction(preSpec, fn.pre, function(pre) {
      addCommonWrapTests(pre);
      addCommonPreTests(pre);
    });


    var addCommonPostTests = function(fnUnderTest, isWrap) {
      isWrap = isWrap || false;


      it('Calls the post function with preserved execution context', function() {
        var postExc;
        var post = function() {postExc = this;};
        var f = objectCurry(function() {});
        var pre = function() {};
        var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(post, f);
        var args = ['a', 'b'];
        var obj = {};
        newFn.apply(obj, args);

        expect(postExc).to.equal(obj);
      });


      it('Calls the post function after the original function', function() {
        var origCalled = false;
        var postCalledAfter = false;

        var f = function() {origCalled = true;};
        var pre = function() {};
        var post = function() {postCalledAfter = origCalled;};
        var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(post, f);
        var args = ['funkier'];
        newFn.apply(null, args);

        expect(postCalledAfter).to.equal(true);
      });


      var addCallsPostWithArgsAndResultTest = function(message, f, args) {
        it('Calls the pre function with the given arguments ' + message, function() {
          var postArgs = null;
          var postResult = null;
          var post = function(args, result) {postArgs = args; postResult = result;};
          var pre = function() {};
          var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(post, f);
          newFn.apply(null, args);

          expect(postArgs).to.deep.equal(args);
          expect(postResult).to.deep.equal(f.apply(null, args));
        });
      };


      addCallsPostWithArgsAndResultTest('(1)', function(x, y) {return x + y;}, [1, 2]);
      addCallsPostWithArgsAndResultTest('(2)', id, ['funkier']);


      it('Disregards the post function\'s return value', function() {
        var f = function(x, y) {return x + y;};
        var pre = function() {};
        var post = function() {return 42;};
        var newFn = isWrap ? fnUnderTest(pre, post, f) : fnUnderTest(post, f);
        var args = [1, 2];
        var result = newFn.apply(null, args);

        expect(result).to.not.equal(post.apply(null, [args, f.apply(null, args)]));
        expect(result).to.equal(f.apply(null, args));
      });
    };


    var postSpec = {
      name: 'post',
      restrictions: [['function'], ['function']],
      validArguments: [[function() {}], [function() {}]]
    };


    checkFunction(postSpec, fn.post, function(post) {
      addCommonWrapTests(post);
      addCommonPostTests(post);
    });


    var wrapSpec = {
      name: 'wrap',
      restrictions: [['function'], ['function'], ['function']],
      validArguments: [[function() {}], [function() {}], [function() {}]]
    };


    checkFunction(wrapSpec, fn.wrap, function(wrap) {
      addCommonWrapTests(wrap, true);
      addCommonPreTests(wrap, true);
      addCommonPostTests(wrap, true);
    });
  });
})();

},{"../../lib/components/base":11,"../../lib/components/curry":13,"../../lib/components/fn":15,"./testingUtilities":63,"chai":64}],52:[function(require,module,exports){
(function() {
  "use strict";

  var expect = require('chai').expect;

  var funcUtils = require('../../lib/funcUtils');
  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;


  describe('funcUtils', function() {
    var expectedObjects = [];
    var expectedFunctions = ['checkFunction'];
    checkModule('funcUtils', funcUtils, expectedObjects, expectedFunctions);


    var nonFunctions = [
      {name: 'number', value: 1},
      {name: 'boolean', value: true},
      {name: 'string', value: 'a'},
      {name: 'object', value: {}},
      {name: 'array', value: [1, 2]},
      {name: 'undefined', value: undefined},
      {name: 'null', value: null}
    ];


    var funcs = [
      function() {},
      function(x) {},
      function(x, y) {},
      function(x, y, z) {}
    ];


    // We cannot use checkFunction from testUtils due to the optional parameter
    describe('checkFunction', function() {
      var checkFunction = funcUtils.checkFunction;


      nonFunctions.forEach(function(test) {
        it('Throws for value of type ' + test.name, function() {
          var fn = function() {
            checkFunction(test.value);
          };

          expect(fn).to.throw(TypeError);
        });


        it('Throws with correct message value of type ' + test.name, function() {
          var message = 'That ain\'t no stinking function!';
          var fn = function() {
            checkFunction(test.value, {message: message});
          };

          expect(fn).to.throw(message);
        });
      });


      funcs.forEach(function(f) {
        it('Works correctly for function of arity ' + f.length, function() {
          var g = checkFunction(f);

          expect(g).to.equal(f);
        });
      });


      var addBadArityTest = function(arity, f) {
        it('Throws for function of arity ' + f.length + ' when arity is ' + arity, function() {
          var fn = function() {
            checkFunction(f, {arity: arity});
          };

          expect(fn).to.throw(TypeError);
        });


        it('Throws with correct message for disallowed arity ' + f.length, function() {
          var message = 'That ain\'t the right stinking function!';
          var fn = function() {
            checkFunction(f, {arity: arity, message: message});
          };

          expect(fn).to.throw(message);
        });
      };


      var addBadMinArityTest = function(arity, f) {
        it('Throws for function of arity ' + f.length + ' when minimum arity is ' + arity, function() {
          var fn = function() {
            checkFunction(f, {arity: arity, minimum: true});
          };

          expect(fn).to.throw(TypeError);
        });


        it('Throws with correct message for disallowed arity ' + f.length + ' below minimum ' + arity, function() {
          var message = 'That ain\'t the right stinking function!';
          var fn = function() {
            checkFunction(f, {arity: arity, message: message, minimum: true});
          };

          expect(fn).to.throw(message);
        });
      };


      var addBadMaxArityTest = function(arity, f) {
        it('Throws for function of arity ' + f.length + ' when maximum arity is ' + arity, function() {
          var fn = function() {
            checkFunction(f, {arity: arity, maximum: true});
          };

          expect(fn).to.throw(TypeError);
        });


        it('Throws with correct message for disallowed arity ' + f.length + ' above maximum ' + arity, function() {
          var message = 'That ain\'t the right stinking function!';
          var fn = function() {
            checkFunction(f, {arity: arity, message: message, maximum: true});
          };

          expect(fn).to.throw(message);
        });
      };


      var addGoodArityTest = function(arity, f, isMin, isMax) {
        isMin = isMin || false;
        isMax = isMax || false;
        var message = isMin ? 'minimum' : isMax ? 'maximum' : '';


        it('Doesn\'t throw for function of arity ' + f.length + ' when ' + message + ' arity is ' + arity, function() {
          var result = null;
          var fn = function() {
            var options = isMin ? {arity: arity, minimum: true} : isMax ? {arity: arity, maximum: true} : {arity: arity};
            result = checkFunction(f, options);
          };

          expect(fn).to.not.throw(TypeError);
          expect(result).to.equal(f);
        });
      };


      funcs.forEach(function(_, arity) {
        funcs.forEach(function(f) {
          if (f.length === arity)
            addGoodArityTest(arity, f);
          else
            addBadArityTest(arity, f);

          if (arity > 0) {
            if (f.length >= arity) {
              addGoodArityTest(arity, f, true);
              if (f.length > arity)
                addBadMaxArityTest(arity, f);
              else
                addGoodArityTest(arity, f, false, true);
            } else {
              addBadMinArityTest(arity, f);
              addGoodArityTest(arity, f, false, true);
            }
          }
        });
      });
    });
  });
})();

},{"../../lib/funcUtils":24,"./testingUtilities":63,"chai":64}],53:[function(require,module,exports){
//(function() {
//  "use strict";
//
//
//  var testFixture = function(require, exports) {
//    var chai = require('chai');
//    var expect = chai.expect;
//
//    var funkier = require('../../funkier');
//
//    // Import utility functions
//    var testUtils = require('./testUtils');
//    var exportsProperty = testUtils.exportsProperty;
//
//    var utils = require('../utils');
//
//    // Import submodules
//    var curry = require('../curry');
//    var base = require('../base');
//    var logical = require('../logical');
//    var maths = require('../maths');
//    var object = require('../object');
//    var string = require('../string');
//    var fn = require('../fn');
//    var date = require('../date');
//    var pair = require('../pair');
//    var maybe = require('../maybe');
//    var result = require('../result');
//    var combinators = require('../combinators');
//    var array = require('../array');
//
//
//    var imports = [{name: 'curry', val: curry},
//                   {name: 'base', val: base},
//                   {name: 'logical', val: logical},
//                   {name: 'maths', val: maths},
//                   {name: 'object', val: object},
//                   {name: 'string', val: string},
//                   {name: 'fn', val: fn},
//                   {name: 'date', val: date},
//                   {name: 'pair', val: pair},
//                   {name: 'maybe', val: maybe},
//                   {name: 'result', val: result},
//                   {name: 'combinators', val: combinators},
//                   {name: 'array', val: array}];
//
//
//    describe('Funkier exports', function() {
//      var makeExportCorrectTest = function(key, module) {
//        return function() {
//          expect(funkier[key]).to.equal(module[key]);
//        };
//      };
//
//
//      imports.forEach(function(importedModule) {
//        var name = importedModule.name;
//        var module = importedModule.val;
//
//        // We want to check that funkier exports everything exported by the original submodule, and indeed that it
//        // exports the original version. This also implicitly tests that no two components export a function with
//        // the same name: one of these tests would fail in that case.
//        for (var k in module) {
//          if (!module.hasOwnProperty(k))
//            continue;
//
//          it('funkier.js exports ' + k, exportsProperty(funkier, k));
//          it('funkier.js exports ' + k + ' from ' + name, makeExportCorrectTest(k, module));
//        }
//      });
//
//
//      it('Exports help from utils', function() {
//        expect(funkier.help).to.equal(utils.help);
//      });
//    });
//  };
//
//
//  // AMD/CommonJS foo: aim to allow running testsuite in browser with require.js (TODO)
//  if (typeof(define) === "function") {
//    define(function(require, exports, module) {
//      testFixture(require, exports, module);
//    });
//  } else {
//    testFixture(require, exports, module);
//  }
//})();

},{}],54:[function(require,module,exports){
(function() {
  "use strict";


  var internalUtilities = require('../../lib/internalUtilities');
  var expect = require('chai').expect;
  var checkModule = require('./testingUtilities').checkModule;


  describe('internalUtilities', function() {
    checkModule('internalUtilities', internalUtilities, {
                expectedFunctions: ['checkArrayLike', 'checkIntegral', 'checkObjectLike', 'checkPositiveIntegral',
                                    'isArrayLike', 'valueStringifier']});


    /*
     * The tests for checkPositiveIntegral and checkIntegral have broadly the same shape: they must both either return
     * the given argument, or throw an exception. This function automatically installs those tests with the correct
     * expectations based on the function under tests. This test generation function will exercise the function under
     * test in both its strict (accepts only numbers) and relaxed (accepts values that coerce to numbers) forms.
     *
     */

    var addNumericTests = function(fnUnderTest, options) {
      options = options || {};
      var acceptOnlyPositive = options.positiveOnly;

      var addSingleTest = function(type, value, shouldAcceptValue, functionOptions) {
        functionOptions = functionOptions || {};

        // Confirm that the function under test either returns the given value or throws a type error
        it('Behaves correctly for ' + type, function() {
          var result = null;
          var fn = function() {
            result = fnUnderTest(value, functionOptions);
          };

          if (shouldAcceptValue) {
            expect(fn).to.not.throw(TypeError);
            // Coerce the value for comparison when necessary
            expect(result).to.equal(value - 0);
          } else {
            expect(fn).to.throw(TypeError);
          }
        });

        if (shouldAcceptValue)
          return;

        // Confirm that the exception thrown is a TypeError
        it('Returns correct exception for ' + type, function() {
          var message = 'This was an error';
          // Be mindful of the existing options: keep them in the prototype chain
          var opts = Object.create(functionOptions);
          opts.errorMessage = message;
          var fn = function() {
            fnUnderTest(value, opts);
          };

          expect(fn).to.throw(message);
        });
      };

      var checkAcceptsValue = function(type, value, options) {
        addSingleTest(type, value, true, options);
      };

      var checkRejectsValue = function(type, value, options) {
        addSingleTest(type, value, false, options);
      };

      var notNumericTests = [
        {type: 'string', value: 'a'},
        {type: 'function', value: function() {}},
        {type: 'object', value: {}},
        {type: 'array', value: [1, 2]},
        {type: 'undefined', value: undefined}
      ];

      var nonIntegralTests = [
        {type: 'NaN', value: NaN},
        {type: 'negative infinity', value: Number.NEGATIVE_INFINITY},
        {type: 'positive infinity', value: Number.POSITIVE_INFINITY},
        {type: 'negative float', value: -1.1},
        {type: 'float', value: 2.2},
        {type: 'string containing float', value: '0.1'},
        {type: 'object evaluating to float', value: {valueOf: function() {return 1.1;}}},
        {type: 'object evaluating to float via string', value: {valueOf: function() {return '1.1';}}}
      ];

      var positiveIntegralTests = [
        {type: 'integer', value: 2},
        {type: 'integer expressed as a float', value: 3.0},
        {type: 'negative zero', value: -0.0}
      ];

      var coerciblePositiveTests = [
        {type: 'null', value: null}, // null coerces to 0
        {type: 'true', value: true}, // booleans should coerce to numbers
        {type: 'false', value: false},
        {type: 'string containing positive integer', value: '1'},
        {type: 'object evaluating to positive integer', value: {valueOf: function() {return 2;}}},
        {type: 'object evaluating to positive integer via string', value: {valueOf: function() {return '2';}}},
        {type: 'object evaluating to positive integer via boolean', value: {valueOf: function() {return true;}}},
        {type: 'object evaluating to positive integer via null', value: {valueOf: function() {return null;}}}
      ];

      var negativeIntegralTests = [
        {type: 'negative integer', value: -5}
      ];

      var coercibleNegativeTests = [
        {type: 'string containing negative integer', value: '-1'},
        {type: 'object evaluating to negative integer', value: {valueOf: function() {return -3;}}},
        {type: 'object evaluating to negative integer via string', value: {valueOf: function() {return '-2';}}}
      ];


      // Neither function should accept values that are not numbers
      notNumericTests.forEach(function(t) {
        checkRejectsValue(t.type, t.value);
      });


      // Neither function should accept values that are not integral numbers
      nonIntegralTests.forEach(function(t) {
        checkRejectsValue(t.type, t.value);
      });


      // Both functions should accept positive integers
      positiveIntegralTests.forEach(function(t) {
        checkAcceptsValue(t.type, t.value);
      });


      // Both functions should accept values coercible to positive integers when called in relaxed mode
      coerciblePositiveTests.forEach(function(t) {
        checkAcceptsValue(t.type, t.value);
      });


      // Both functions should reject values coercible to positive integers when called in strict mode
      coerciblePositiveTests.forEach(function(t) {
        checkRejectsValue(t.type + ' (strict mode)', t.value, {strict: true});
      });


      // Only checkIntegral should accept negative values
      negativeIntegralTests.forEach(function(t) {
        var testAdder = acceptOnlyPositive ? checkRejectsValue : checkAcceptsValue;
        testAdder(t.type, t.value);
      });


      // checkIntegral should accept objects coercible to negative values
      coercibleNegativeTests.forEach(function(t) {
        var testAdder = acceptOnlyPositive ? checkRejectsValue : checkAcceptsValue;
        testAdder(t.type, t.value);
      });


      // All functions should reject objects coercible to negative values in strict mode
      coercibleNegativeTests.forEach(function(t) {
        checkRejectsValue(t.type + ' (strict mode)', t.value, {strict: true});
      });
    };


    describe('checkIntegral', function() {
      var checkIntegral = internalUtilities.checkIntegral;

      addNumericTests(checkIntegral);
    });


    describe('checkPositiveIntegral', function() {
      var checkPositiveIntegral = internalUtilities.checkPositiveIntegral;


      addNumericTests(checkPositiveIntegral, {positiveOnly: true});
    });


    var objectLikeTests = [
      {name: 'number', value: 1, result: false},
      {name: 'boolean', value: true, result: false},
      {name: 'string', value: 'a', result: true},
      {name: 'function', value: function() {}, result: true},
      {name: 'object', value: {}, result: true},
      {name: 'array', value: [1, 2], result: true},
      {name: 'undefined', value: undefined, result: false},
      {name: 'null', value: null, result: false}
    ];


    describe('isObjectLike', function() {
      var isObjectLike = internalUtilities.isObjectLike;


      objectLikeTests.forEach(function(t) {
        var name = t.name;

        it('Behaves correctly for ' + name, function() {
          var b = isObjectLike(t.value);
          var expected = t.result;

          expect(b).to.equal(expected);
        });
      });


      var addOptionTests = function(allowNull, strict) {
        it('Behaves correctly for null when allowNull ' + allowNull + ' and strict ' + strict, function() {
          expect(isObjectLike(null, {allowNull: allowNull, strict: strict})).to.equal(allowNull);
        });


        it('Behaves correctly for function when allowNull ' + allowNull + ' and strict ' + strict, function() {
          expect(isObjectLike(function() {}, {allowNull: allowNull, strict: strict})).to.equal(!strict);
        });


        it('Behaves correctly for string when allowNull ' + allowNull + ' and strict ' + strict, function() {
          expect(isObjectLike('a', {allowNull: allowNull, strict: strict})).to.equal(!strict);
        });


        it('Behaves correctly for array when allowNull ' + allowNull + ' and strict ' + strict, function() {
          expect(isObjectLike([1], {allowNull: allowNull, strict: strict})).to.equal(!strict);
        });


        it('Behaves correctly for object when allowNull ' + allowNull + ' and strict ' + strict, function() {
          expect(isObjectLike({}, {allowNull: allowNull, strict: strict})).to.equal(true);
        });
      };


      addOptionTests(false, false);
      addOptionTests(false, true);
      addOptionTests(true, false);
      addOptionTests(true, true);
    });


    describe('checkObjectLike', function() {
      var checkObjectLike = internalUtilities.checkObjectLike;


      var shouldFail = objectLikeTests.filter(function(test) {return test.result === false;});
      var shouldPass = objectLikeTests.filter(function(test) {return test.result === true;});

      shouldFail.forEach(function(test) {
        var name = test.name;


        it('Behaves correctly for ' + name, function() {
          var fn = function() {
            checkObjectLike(test.value);
          };

          expect(fn).to.throw(TypeError);
        });


        it('Returns correct exception for ' + name, function() {
          var message = 'This was an error';
          var fn = function() {
            checkObjectLike(test.value, {message: message});
          };

          expect(fn).to.throw(message);
        });
      });


      shouldPass.forEach(function(test) {
        var name = test.name;


        it('Doesn\'t throw for ' + name, function() {
          var fn = function() {
            checkObjectLike(test.value);
          };

          expect(fn).to.not.throw(TypeError);
        });


        it('Returns its argument for ' + name, function() {
          expect(checkObjectLike(test.value)).to.equal(test.value);
        });
      });


      it('Doesn\'t accept null when relevant parameter explicitly passed in (1)', function() {
        var fn = function() {
          checkObjectLike(null, {allowNull: false});
        };

        expect(fn).to.throw(TypeError);
      });


      it('Doesn\'t accept null when relevant parameter explicitly passed in (2)', function() {
        var message = 'Noooo, no null here!';
        var fn = function() {
          checkObjectLike(null, {allowNull: false, message: message});
        };

        expect(fn).to.throw(message);
      });


      it('Accepts null when relevant parameter passed in', function() {
        var o = checkObjectLike(null, {allowNull: true});

        expect(o).to.equal(null);
      });


      var addStrictTests = function(type, val) {
        it('Accepts ' + type + ' when strict parameter explicitly false', function() {
          var o = checkObjectLike(val, {strict: false});

          expect(o).to.equal(val);
        });


        it('Doesn\'t accept ' + type + ' when strict parameter true (1)', function() {
          var fn = function() {
            checkObjectLike(val, {strict: true});
          };

          expect(fn).to.throw(TypeError);
        });


        it('Doesn\'t accept ' + type + ' when relevant strict parameter true (2)', function() {
          var message = 'Noooo, only objects here!';
          var fn = function() {
            checkObjectLike(val, {strict: true, message: message});
          };

          expect(fn).to.throw(message);
        });
      };


      addStrictTests('function', function() {});
      addStrictTests('string', 'abc');
    });


    var arrayLikeTests = [
      {name: 'number', value: 1, result: false},
      {name: 'boolean', value: true, result: false},
      {name: 'string', value: 'a', result: true},
      {name: 'function', value: function() {}, result: false},
      {name: 'object', value: {}, result: false},
      {name: 'array', value: [1, 2], result: true},
      {name: 'undefined', value: undefined, result: false},
      {name: 'null', value: null, result: false},
      {name: 'arrayLike', value: {'0': 'a', '1': 'b', 'length': 2}, result: true}
    ];


    describe('isArrayLike', function() {
      var isArrayLike = internalUtilities.isArrayLike;


      arrayLikeTests.forEach(function(t) {
        var name = t.name;

        it('Behaves correctly for ' + name, function() {
          var b = isArrayLike(t.value);
          var expected = t.result;

          expect(b).to.equal(expected);
        });
      });


      it('Behaves correctly with string when noStrings parameter explicitly false', function() {
        expect(isArrayLike('a', false)).to.equal(true);
      });


      it('Behaves correctly with string when noStrings parameter explicitly true', function() {
        expect(isArrayLike('a', true)).to.equal(false);
      });
    });


    describe('checkArrayLike', function() {
      var checkArrayLike = internalUtilities.checkArrayLike;


      var shouldFail = arrayLikeTests.filter(function(test) {return test.result === false;});
      var shouldPass = arrayLikeTests.filter(function(test) {return test.result === true;});

      shouldFail.forEach(function(test) {
        var name = test.name;


        it('Behaves correctly for ' + name, function() {
          var fn = function() {
            checkArrayLike(test.value);
          };

          expect(fn).to.throw(TypeError);
        });


        it('Returns correct exception for ' + name, function() {
          var message = 'This was an error';
          var fn = function() {
            checkArrayLike(test.value, {message: message});
          };

          expect(fn).to.throw(message);
        });
      });


      shouldPass.forEach(function(test) {
        var name = test.name;


        it('Doesn\'t throw for ' + name, function() {
          var fn = function() {
            checkArrayLike(test.value);
          };

          expect(fn).to.not.throw(TypeError);
        });


        it('Behaves correctly when dontSlice in options ' + name, function() {
          var v = checkArrayLike(test.value, {dontSlice: true});

          expect(v).to.equal(test.value);
        });


        it('Behaves correctly when dontSlice explicitly false in options ' + name, function() {
          var v = checkArrayLike(test.value, {dontSlice: false});

          if (name === 'string') {
            expect(v).to.equal(test.value);
          } else {
            expect(v).to.not.equal(test.value);
            // Need to manually check deep equality due to arraylikes being transformed to arrays
            for (var i = 0, l = test.value.length; i < l; i++)
              expect(v[i]).to.equal(test.value[i]);
          }
        });


        it('Behaves correctly when dontSlice not in options ' + name, function() {
          var v = checkArrayLike(test.value);

          if (name === 'string') {
            expect(v).to.equal(test.value);
          } else {
            expect(v).to.not.equal(test.value);
            // Need to manually check deep equality due to arraylikes being transformed to arrays
            for (var i = 0, l = test.value.length; i < l; i++)
              expect(v[i]).to.equal(test.value[i]);
          }
        });
      });


      it('Doesn\'t accept strings when relevant parameter passed in (1)', function() {
        var fn = function() {
          checkArrayLike('abc', {noStrings: true});
        };

        expect(fn).to.throw(TypeError);
      });


      it('Doesn\'t accept strings when relevant parameter passed in (2)', function() {
        var message = 'Noooo, no strings here!';
        var fn = function() {
          checkArrayLike('abc', {noStrings: true, message: message});
        };

        expect(fn).to.throw(message);
      });


      it('Accepts strings when relevant parameter explicitly passed in', function() {
        var s = checkArrayLike('abc', {noStrings: false});

        expect(s).to.equal('abc');
      });
    });


    describe('valueStringifier', function() {
      var valueStringifier = internalUtilities.valueStringifier;


      var f = function() {};
      var o = {};
      var tests = [
        {name: 'number', value: 1, result: '1'},
        {name: 'boolean', value: true, result: 'true'},
        {name: 'string', value: 'a', result: '\'a\''},
        {name: 'function', value: f, result: f.toString()},
        {name: 'object', value: o, result: '{' + o.toString() + '}'},
        {name: 'object with toString', value: {toString: function() {return '***';}},
                                       result: '{***}'},
        {name: 'array', value: [1, 2], result: '[1, 2]'},
        {name: 'undefined', value: undefined, result: 'undefined'},
        {name: 'null', value: null, result: 'null'}
      ];


      tests.forEach(function(t) {
        var name = t.name;

        it('Behaves correctly for ' + name, function() {
          var s = valueStringifier(t.value);
          var expected = t.result;

          expect(s).to.equal(expected);
        });
      });
    });
  });
})();

},{"../../lib/internalUtilities":27,"./testingUtilities":63,"chai":64}],55:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var curry = require('../../lib/components/curry');
  var objectCurry = curry.objectCurry;

  var base = require('../../lib/components/base');
  var constant = base.constant;
  var constantFalse = constant(false);
  var constantTrue = constant(true);

  var logical = require('../../lib/components/logical');

  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;
  var addCurryStyleTests = testUtils.addCurryStyleTests;
  var addDoubleCurryStyleTests = testUtils.addDoubleCurryStyleTests;


  describe('Logical', function() {
    var expectedObjects = [];
    var expectedFunctions = ['not', 'and', 'or', 'xor', 'notPred', 'andPred', 'orPred', 'xorPred'];
    checkModule('logical', logical, expectedObjects, expectedFunctions);


    var notSpec = {
      name: 'not',
    };


    checkFunction(notSpec, logical.not, function(not) {
      it('Works as expected (1)', function() {
        expect(not(true)).to.equal(false);
      });


      it('Works as expected (2)', function() {
        expect(not(false)).to.equal(true);
      });
    });


    // Utility function for test generation
    var makeBinaryBooleanTest = function(fn, val1, val2, expected) {
      return function() {
        expect(fn(val1, val2)).to.equal(expected);
      };
    };


    // All the boolean operator tests have the same template
    var makeBinaryBooleanTestFixture = function(desc, fnUnderTest, truthTable) {
      var spec = {
        name: desc,
      };

      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        truthTable.forEach(function(test, i) {
          var indexString = ' (' + (i + 1) + ')';
          it('Works as expected' + indexString,
              makeBinaryBooleanTest(fnUnderTest, test.val1, test.val2, test.expected));
        });
      });
    };


    var makeTruthTable = function(ff, ft, tf, tt) {
      return [
        {val1: false, val2: false, expected: ff},
        {val1: false, val2: true, expected: ft},
        {val1: true, val2: false, expected: tf},
        {val1: true, val2: true, expected: tt}
      ];
    };


    var andTruthTable = makeTruthTable(false, false, false, true);
    makeBinaryBooleanTestFixture('and', logical.and, andTruthTable);


    var orTruthTable = makeTruthTable(false, true, true, true);
    makeBinaryBooleanTestFixture('or', logical.or, orTruthTable);


    var xorTruthTable = makeTruthTable(false, true, true, false);
    makeBinaryBooleanTestFixture('xor', logical.xor, xorTruthTable);


    var notPredSpec = {
      name: 'notPred',
      restrictions: [['function: arity 1']],
      validArguments: [[function(x) {return true;}]]
    };


    checkFunction(notPredSpec, logical.notPred, function(notPred) {
      it('notPred works as expected (1)', function() {
        var negated = notPred(constantTrue);

        expect(negated).to.be.a('function');
        expect(negated.length).to.equal(1);
        expect(negated('a')).to.equal(false);
      });


      it('notPred works as expected (2)', function() {
        var negated = notPred(constantFalse);

        expect(negated).to.be.a('function');
        expect(negated.length).to.equal(1);
        expect(negated('a')).to.equal(true);
      });


      it('notPred passes execution context', function() {
        var context;
        var fn = objectCurry(function(x) { context = this; return true; });
        var negated = notPred(fn);

        var obj = function() {};
        negated.apply(obj, [1]);
        expect(context).to.equal(obj);
      });


      addCurryStyleTests(function(p) { return notPred(p); }, true, 1);
    });


    // Utility functions for test generation
    var makeBinaryPredicateTest = function(funcUnderTest, pred1, pred2, expected) {
      return function() {
        expect(funcUnderTest(pred1, pred2)('a')).to.equal(expected);
      };
    };


    var makePredicateShortCircuitTest = function(funcUnderTest, val1, val2) {
      var pred1 = function(x) {
        return val1;
      };

      var pred2 = function(x) {
        pred2.called = true;
        return val2;
      };

      return function() {
        pred2.called = false;
        funcUnderTest(pred1, pred2)('a');
        expect(pred2.called).to.equal(false);
      };
    };


    // All the boolean operator tests have the same template
    var makeBinaryPredicateTestFixture = function(desc, fnUnderTest, truthTable) {
      var spec = {
        name: desc,
        restrictions: [['function: arity 1'], ['function: arity 1']],
        validArguments: [[function(x) {return true;}], [function(x) {return true;}]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        truthTable.forEach(function(test, i) {
          var indexString = ' (' + (i + 1) + ')';
          it('Works as expected' + indexString,
              makeBinaryPredicateTest(fnUnderTest, test.pred1, test.pred2, test.expected));

          if (test.shortCircuits) {
            // Note, we deliberately call the predicate functions nowwe need the values they return
            it('Correctly short-circuits' + indexString,
                makePredicateShortCircuitTest(fnUnderTest, test.pred1(), test.pred2()));
          }
        });


        // Watch out for short-circuiting when testing the curry style
        var f1Return = fnUnderTest === logical.andPred ? true : false;

        addDoubleCurryStyleTests(function(p1, p2) {
          return fnUnderTest(p1, p2);
        }, f1Return);


        it('Passes execution context', function() {
          var context1;
          var context2;
          var fn1 = objectCurry(function(x) { context1 = this; return fnUnderTest === logical.andPred; });
          var fn2 = objectCurry(function(x) { context2 = this; return true; });
          var combined = fnUnderTest(fn1, fn2);

          var obj = function() {};
          combined.apply(obj, [1]);
          expect(context1).to.equal(obj);
          expect(context2).to.equal(obj);
        });
      });
    };


    var makePredTruthTable = function(ff, ft, tf, tt) {
      return [
        {pred1: constantFalse, pred2: constantFalse, expected: ff.expected, shortCircuits: ff.shortCircuits},
        {pred1: constantFalse, pred2: constantTrue, expected: ft.expected, shortCircuits: ft.shortCircuits},
        {pred1: constantTrue, pred2: constantFalse, expected: tf.expected, shortCircuits: tf.shortCircuits},
        {pred1: constantTrue, pred2: constantTrue, expected: tt.expected, shortCircuits: tt.shortCircuits}
      ];
    };


    var andPredTruthTable = makePredTruthTable({expected: false, shortCircuits: true}, {expected: false, shortCircuits: true},
                                           {expected: false, shortCircuits: false}, {expected: true, shortCircuits: false});
    makeBinaryPredicateTestFixture('andPred', logical.andPred, andPredTruthTable);


    var orPredTruthTable = makePredTruthTable({expected: false, shortCircuits: false}, {expected: true, shortCircuits: false},
                                          {expected: true, shortCircuits: true}, {expected: true, shortCircuits: true});
    makeBinaryPredicateTestFixture('orPred', logical.orPred, orPredTruthTable);


    var xorPredTruthTable = makePredTruthTable({expected: false, shortCircuits: false}, {expected: true, shortCircuits: false},
                                           {expected: true, shortCircuits: false}, {expected: false, shortCircuits: false});
    makeBinaryPredicateTestFixture('xorPred', logical.xorPred, xorPredTruthTable);
  });
})();

},{"../../lib/components/base":11,"../../lib/components/curry":13,"../../lib/components/logical":16,"./testingUtilities":63,"chai":64}],56:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;
  var maths = require('../../lib/components/maths');

  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;


  describe('maths', function() {
    var expectedObjects = [];
    var expectedFunctions = ['add', 'bitwiseAnd', 'bitwiseNot', 'bitwiseOr', 'bitwiseXor', 'div', 'divide', 'even',
                             'exp', 'greaterThan', 'greaterThanEqual', 'leftShift', 'lessThan', 'lessThanEqual', 'log',
                             'max', 'min', 'multiply', 'odd', 'parseInt', 'rem', 'rightShift', 'rightShiftZero',
                             'stringToInt', 'subtract', 'toBaseAndString', 'toExponential', 'toFixed', 'toPrecision'];
    checkModule('maths', maths, expectedObjects, expectedFunctions);


    // The tests for the binary functions will have a similar structure. Generate them automatically.
    var binaryTests = [
      {func: 'add', test1: {val1: 1, val2: 2, result: 1 + 2},
       test2: {val1: 32, val2: 10, result: 32 + 10}},
      {func: 'subtract', test1: {val1: 1, val2: 2, result: 1 - 2},
       test2: {val1: 52, val2: 10, result: 52 - 10}},
      {func: 'multiply', test1: {val1: 1, val2: 2, result: 1 * 2},
       test2: {val1: 7, val2: 6, result: 7 * 6}},
      {func: 'divide', test1: {val1: 1, val2: 2, result: 1 / 2},
       test2: {val1: 210, val2: 5, result: 210 / 5}},
      {func: 'exp', test1: {val1: 2, val2: 3, result: Math.pow(2, 3)},
       test2: {val1: 3, val2: 4, result: Math.pow(3, 4)}},
      {func: 'log', test1: {val1: 2, val2: 8, result: 3},
       test2: {val1: 10, val2: 100, result: 2}},
      {func: 'div', test1: {val1: 4, val2: 2, result: 2},
       test2: {val1: 85, val2: 2, result: 42}},
      {func: 'rem', test1: {val1: 4, val2: 2, result: 0},
       test2: {val1: 42, val2: 43, result: 42}},
      {func: 'lessThan', test1: {val1: 2, val2: 3, result: 2 < 3},
       test2: {val1: 42, val2: 41, result: 42 < 41}},
      {func: 'lessThanEqual', test1: {val1: 3, val2: 2, result: 3 <= 2},
       test2: {val1: 42, val2: 42, result: 42 <= 42}},
      {func: 'greaterThan', test1: {val1: 2, val2: 3, result: 2 > 3},
       test2: {val1: 42, val2: 41, result: 42 > 41}},
      {func: 'greaterThanEqual', test1: {val1: 2, val2: 3, result: 2 >= 3},
       test2: {val1: 42, val2: 42, result: 42 >= 42}},
      {func: 'leftShift', test1: {val1: 1, val2: 2, result: 1 << 2},
       test2: {val1: 21, val2: 1, result: 21 << 1}},
      {func: 'rightShift', test1: {val1: 2, val2: 1, result: 2 >> 1},
       test2: {val1: 168, val2: 2, result: 168 >> 2}},
      {func: 'rightShiftZero', test1: {val1: 168, val2: 2, result: 168 >>> 2},
       test2: {val1: -15, val2: 1, result: -15 >>> 1}},
      {func: 'bitwiseAnd', test1: {val1: 1, val2: 0, result: 1 & 0},
       test2: {val1: 0x3a, val2: 0x4b, result: 0x3a & 0x4b}},
      {func: 'bitwiseOr', test1: {val1: 1, val2: 0, result: 1 | 0},
       test2: {val1: 0x20, val2: 0x0a, result: 0x20 | 0xa}},
      {func: 'bitwiseXor', test1: {val1: 1, val2: 1, result: 1 ^ 1},
       test2: {val1: 0x26, val2: 0x0c, result: 0x26 ^ 0xc}}
    ];


    binaryTests.forEach(function(test) {
      var spec = {
        name: test.func,
      };


      checkFunction(spec, maths[test.func], function(fnUnderTest) {
        var test1 = test.test1;
        var test2 = test.test2;

        it('Works as expected (1)', function() {
          expect(fnUnderTest(test1.val1, test1.val2)).to.equal(test1.result);
        });


        it('Works as expected (2)', function() {
          expect(fnUnderTest(test2.val1, test2.val2)).to.equal(test2.result);
        });


      });
    });


    var bitwiseNotSpec = {
      name: 'bitwiseNot',
      arity: 1
    };


    checkFunction(bitwiseNotSpec, maths.bitwiseNot, function(bitwiseNot) {
      it('Works as expected (1)', function() {
        expect(bitwiseNot(1)).to.equal(~1);
      });


      it('Works as expected (2)', function() {
        expect(bitwiseNot(-43)).to.equal(~(-43));
      });
    });


    var minSpec = {
      name: 'min',
      arity: 2
    };


    checkFunction(minSpec, maths.min, function(min) {
      it('Works as expected (1)', function() {
        expect(min(1, 2)).to.equal(Math.min(1, 2));
      });


      it('Works as expected (2)', function() {
        expect(min(42, 210)).to.equal(Math.min(42, 210));
      });


      it('Discards excess arguments', function() {
        expect(min(42, 45, 1)).to.equal(Math.min(42, 45));
      });
    });


    var maxSpec = {
      name: 'max',
      arity: 2
    };


    checkFunction(maxSpec, maths.max, function(max) {
      it('Works as expected (1)', function() {
        expect(max(1, 2)).to.equal(Math.max(1, 2));
      });


      it('Works as expected (2)', function() {
        expect(max(42, 21)).to.equal(Math.max(42, 21));
      });


      it('Discards excess arguments', function() {
        expect(max(42, 35, 1)).to.equal(Math.max(42, 35));
      });
    });


    var makeNumStringTest = function(desc, fnUnderTest, verifier, testData) {
      describe(desc, function() {
        it('Returns a string', function() {
          var n = 17;
          var result = fnUnderTest(2, n);

          expect(result).to.be.a('string');
        });


        testData.forEach(function(test, i) {
          it('Works correctly (' + (i + 1) + ')', function() {
            var n = test[0];
            var param = test[1];
            var result = fnUnderTest(param, n);

            expect(result).to.equal(n[verifier](param));
          });
        });
      });
    };


    var fixTests = [[17.051, 2], [17.051, 0], [17.051, 4], [17, 2]];
    makeNumStringTest('toFixed', maths.toFixed, 'toFixed', fixTests);


    var expTests = [[123.456, 1], [123.456, 2], [123.456, 0], [1, 4], [0.1, 2]];
    makeNumStringTest('toExponential', maths.toExponential, 'toExponential', expTests);


    var precisionTests = [[1, 1], [1, 2], [123.45, 2]];
    makeNumStringTest('toPrecision', maths.toPrecision, 'toPrecision', precisionTests);


    var baseTests = [[3, 2], [11, 10], [35, 36]];
    makeNumStringTest('toString', maths.toBaseAndString, 'toString', baseTests);


    describe('parseInt', function() {
      var parseInt = maths.parseInt;


      it('Returns a number', function() {
        var s = '17';
        var result = parseInt(s);

        expect(result).to.be.a('number');
      });


      it('Works correctly (2)', function() {
        var s = 'abc';
        var result = parseInt(s);

        expect(isNaN(result)).to.equal(true);
      });


      it('Ignores superfluous arguments', function() {
        var s = '101';
        var result = parseInt(s, 2);

        expect(result).to.equal(101);
      });
    });


    describe('stringToInt', function() {
      var stringToInt = maths.stringToInt;


      it('Returns a number', function() {
        var s = '17';
        var result = stringToInt(10, s);

        expect(result).to.be.a('number');
      });


      var addStringToIntTest = function(message, s, base) {
        it('Works correctly ' + message, function() {
          var result = stringToInt(base, s);

          expect(result).to.equal(parseInt(s, base));
        });
      };


      addStringToIntTest('(1)', '10', 10);
      addStringToIntTest('(2)', '10', 2);
      addStringToIntTest('(3)', '1z', 36);


      it('Works correctly (4)', function() {
        var s = 'abc';
        var base = 2;
        var result = stringToInt(base, s);

        expect(isNaN(result)).to.equal(true);
      });
    });


    // XXX FIXME
    var numToLocaleStringSpec = {
      name: 'numToLocaleString'
    };


    var addEvenOddTests = function(desc, fnUnderTest, isEven) {
      describe(desc, function() {
        it('Works correctly (1)', function() {
          var result = fnUnderTest(2);

          expect(result).to.equal(isEven ? true : false);
        });


        it('Works correctly (2)', function() {
          var result = fnUnderTest(3);

          expect(result).to.equal(isEven ? false : true);
        });


        it('Works correctly (3)', function() {
          var result = fnUnderTest(0);

          expect(result).to.equal(isEven ? true : false);
        });
      });
    };


    addEvenOddTests('even', maths.even, true);
    addEvenOddTests('odd', maths.odd, false);
  });
})();

},{"../../lib/components/maths":17,"./testingUtilities":63,"chai":64}],57:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var maybe = require('../../lib/components/maybe');

  var curryModule = require('../../lib/components/curry');
  var arityOf = curryModule.arityOf;
  var objectCurry = curryModule.objectCurry;

  var internalUtilities = require('../../lib/internalUtilities');
  var valueStringifier = internalUtilities.valueStringifier;

  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;
  var makeArrayLike = testUtils.makeArrayLike;
  var addCurryStyleTests = testUtils.addCurryStyleTests;


  describe('Maybe', function() {
    var expectedObjects = ['Maybe', 'Nothing'];
    var expectedFunctions = ['Just', 'getJustValue', 'isMaybe', 'isJust', 'isNothing', 'makeMaybeReturner'];
    checkModule('maybe', maybe, expectedObjects, expectedFunctions);


    var Maybe = maybe.Maybe;
    var Just = maybe.Just;
    var Nothing = maybe.Nothing;
    var getJustValue = maybe.getJustValue;
    var isJust = maybe.isJust;
    var isNothing = maybe.isNothing;


    describe('Maybe', function() {
      it('Is a function', function() {
        expect(Maybe).to.be.a('function');
      });


      it('Cannot be called directly (1)', function() {
        var fn = function() {
          var m = new Maybe();
        };

        expect(fn).to.throw(Error);
      });


      it('Cannot be called directly (2)', function() {
        var fn = function() {
          var m = Maybe();
        };

        expect(fn).to.throw(Error);
      });


      it('toString works correctly', function() {
        var s = Maybe.prototype.toString();

        expect(s).to.equal('Maybe');
      });
    });


    describe('Nothing', function() {
      it('Is an object', function() {
        expect(Nothing).to.be.an('object');
      });


      it('Has no own properties', function() {
        var ownProperties = Object.getOwnPropertyNames(Nothing);

        expect(ownProperties.length).to.equal(0);
      });


      it('New properties cannot be added', function() {
        var fn = function() {
          Nothing.foo = 1;
        };

        expect(fn).to.throw(TypeError);
      });


      it('Is a Maybe (1)', function() {
        var result = Nothing instanceof Maybe;

        expect(result).to.equal(true);
      });


      it('Is a Maybe (2)', function() {
        var result = Nothing.constructor === Maybe;

        expect(result).to.equal(true);
      });


      it('toString works correctly', function() {
        var s = Nothing.toString();

        expect(s).to.equal('Maybe {Nothing}');
      });
    });


    // Values to generate various tests
    var tests = [1, true, 'a', [], {}, function() {}, undefined, null];


    describe('Just', function() {
      it('Throws when called with no arguments (1)', function() {
        var fn = function() {
          new Just();
        };

        expect(fn).to.throw(TypeError);
      });


      it('Throws when called with no arguments (2)', function() {
        var fn = function() {
          Just();
        };

        expect(fn).to.throw(TypeError);
      });


      var makeJustTest = function(message, testMakerFn) {
        var withNew = function() {
          return new Just(1);
        };

        var noNew = function() {
          return Just(1);
        };

        it(message + ' when object created with new operator', testMakerFn(withNew));
        it(message + ' when object created without new operator', testMakerFn(noNew));
      };


      makeJustTest('Returns an object', function(justMaker) {
        return function() {
          var j = justMaker();

          expect(j).to.be.an('object');
        };
      });


      makeJustTest('instanceof correct', function(justMaker) {
        return function() {
          var j = justMaker();

          expect(j).to.be.an.instanceOf(Just);
        };
      });


      makeJustTest('Returned object is also a Maybe (1)', function(justMaker) {
        return function() {
          var j = justMaker();

          expect(j).to.be.an.instanceOf(Maybe);
        };
      });


      makeJustTest('Returned object is also a Maybe (2)', function(justMaker) {
        return function() {
        var result = Nothing.constructor === Maybe;

        expect(result).to.equal(true);
        };
      });


      makeJustTest('Object created has \'value\' property', function(justMaker) {
        return function() {
          var j = justMaker();
          var props = Object.getOwnPropertyNames(j);
          var result = props.indexOf('value') !== -1;

          expect(result).to.equal(true);
        };
      });


      makeJustTest('\'value\' property is not enumerable', function(justMaker) {
        return function() {
          var j = justMaker();
          var value = false;
          for (var prop in j)
            if (prop === 'value') value = true;
          var result = !value;

          expect(result).to.equal(true);
        };
      });


      makeJustTest('\'value\' is immutable', function(justMaker) {
        return function() {
          var j = justMaker();
          var fn = function() {
            j.value = 2;
          };

          expect(fn).to.throw(TypeError);
        };
      });


      makeJustTest('Returned object correct', function(justMaker) {
        return function() {
          var j = justMaker();

          expect(getJustValue(j)).to.equal(1);
        };
      });


      tests.forEach(function(t, i) {
        it('toString works correctly (' + (i + 1) + ')', function() {
          var j = new Just(t);
          var s = j.toString();

          expect(s).to.equal('Maybe {Just ' + valueStringifier(t) + '}');
        });
      });
    });


    var getJustValueSpec = {
      name: 'getJustValue',
      restrictions: [[Just]],
      validArguments: [[new Just(1)]]
    };


    checkFunction(getJustValueSpec, getJustValue, function(getJustValue) {
      it('Throws if called with Maybe', function() {
        var fn = function() {
          getJustValue(Maybe);
        };

        expect(fn).to.throw(TypeError);
      });


      it('Throws if called with Nothing', function() {
        var fn = function() {
          getJustValue(Nothing);
        };

        expect(fn).to.throw(TypeError);
      });


      tests.forEach(function(t, i) {
        it('Works correctly (' + (i + 1) + ')', function() {
          var j = new Just(t);

          expect(getJustValue(j)).to.equal(t);
        });


        it('Works correctly (' + (i + 2) + ')', function() {
          var j = Just(t);

          expect(getJustValue(j)).to.equal(t);
        });
      });
    });


    describe('isMaybe', function() {
      var isMaybe = maybe.isMaybe;


      it('Correct for Maybe', function() {
        expect(isMaybe(Maybe)).to.equal(true);
      });


      it('Correct for Nothing', function() {
        expect(isMaybe(Nothing)).to.equal(true);
      });


      tests.forEach(function(t, i) {
        it('Returns false if called with non-Maybe value (' + (i + 1) + ')', function() {
          expect(isMaybe(t)).to.equal(false);
        });


        it('Works correctly (' + (i + 1) + ')', function() {
          expect(isMaybe(Just(t))).to.equal(true);
        });
      });
    });


    describe('isNothing', function() {
      it('Correct for Maybe', function() {
        expect(isNothing(Maybe)).to.equal(false);
      });


      it('Correct for Nothing', function() {
        expect(isNothing(Nothing)).to.equal(true);
      });


      tests.forEach(function(t, i) {
        it('Returns false if called with non-Maybe value (' + (i + 1) + ')', function() {
          expect(isNothing(t)).to.equal(false);
        });


        it('Correct for Just (' + (i + 1) + ')', function() {
          expect(isNothing(Just(t))).to.equal(false);
        });
      });
    });


    describe('isJust', function() {
      it('Correct for Maybe', function() {
        expect(isJust(Maybe)).to.equal(false);
      });


      it('Correct for Nothing', function() {
        expect(isJust(Nothing)).to.equal(false);
      });


      tests.forEach(function(t, i) {
        it('Returns false if called with non-Maybe value (' + (i + 1) + ')', function() {
          expect(isJust(t)).to.equal(false);
        });


        it('Correct for Just (' + (i + 1) + ')', function() {
          expect(isJust(Just(t))).to.equal(true);
        });
      });
    });


    var maybeReturnerSpec = {
      name: 'makeMaybeReturner',
      restrictions: [['function']],
      validArguments: [[function(x) {}]]
    };


    checkFunction(maybeReturnerSpec, maybe.makeMaybeReturner, function(makeMaybeReturner) {
      it('Returns a function', function() {
        var result = makeMaybeReturner(function() {});

        expect(result).to.be.a('function');
      });


      var addSameArityTest = function(message, f) {
        it('Returned function has same arity ' + message, function() {
          var expected = arityOf(f);
          var newFn = makeMaybeReturner(f);

          expect(arityOf(newFn)).to.equal(arityOf(f));
        });
      };


      addSameArityTest('(1)', function() {});
      addSameArityTest('(2)', function(x, y, z) {});


      var addCallsOriginalTest = function(message, args) {
        it('Returned function calls original function with given args ' + message, function() {
          var called = false;
          var fArgs = null;

          var f = args.length > 1 ? function(x, y) {called = true; fArgs = [x, y]; return 0;} :
                                    function(x) {called = true; fArgs = [x]; return 0;};
          var newFn = makeMaybeReturner(f);
          newFn.apply(null, args);

          expect(called).to.equal(true);
          expect(fArgs).to.deep.equal(args);
        });
      };


      addCallsOriginalTest('(1)', [1, 2]);
      addCallsOriginalTest('(2)', ['a']);


      it('Returns Just <value> when function does not throw', function() {
        var f = function(x) {return x + 1;};
        var newFn = makeMaybeReturner(f);
        var good = [0, 1, 2, 3, 4];
        var result = good.every(function(v) {
          var r = newFn(v);
          return isJust(r) && getJustValue(r) === f(v);
        });

        expect(result).to.equal(true);
      });


      var thingsToThrow = [
        new Error(), new TypeError(), new SyntaxError(), new ReferenceError(),
        1, true, 'a', undefined, null, {}, function() {}, []];


      thingsToThrow.forEach(function(boom, i) {
        it('Doesn\'t throw if underlying function throws', function() {
          var f = function(x) {throw boom;};
          var newFn = makeMaybeReturner(f);
          var fn = function() {
            newFn(1);
          };

          expect(fn).to.not.throw(boom);
        });


        it('Returns Nothing when function throws (' + (i + 1) + ')', function() {
          var f = function(x) {throw boom;};
          var newFn = makeMaybeReturner(f);
          var r = newFn(1);
          var result = isNothing(r);

          expect(result).to.equal(true);
        });
      });


      addCurryStyleTests(function(f) { return makeMaybeReturner(f); });


      it('Passes execution context to original function', function() {
        var context;
        var f = objectCurry(function(x) { context = this; return 1; });
        var newFn = makeMaybeReturner(f);
        var obj = {};
        var r = newFn.apply(obj, [1]);

        expect(context).to.equal(obj);
      });
    });
  });
})();

},{"../../lib/components/curry":13,"../../lib/components/maybe":18,"../../lib/internalUtilities":27,"./testingUtilities":63,"chai":64}],58:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var deepEqual = require('deep-equal');

  var curryModule = require('../../lib/components/curry');
  var arityOf = curryModule.arityOf;
  var objectCurry = curryModule.objectCurry;

  var object = require('../../lib/components/object');

  var testingUtilities = require('./testingUtilities');
  var checkModule = testingUtilities.checkModule;
  var checkFunction = testingUtilities.checkFunction;
  var testCurriedFunction = testingUtilities.testCurriedFunction;
  var NO_RESTRICTIONS = testingUtilities.NO_RESTRICTIONS;

  var maybe = require('../../lib/components/maybe');
  var isJust = maybe.isJust;
  var isNothing = maybe.isNothing;
  var getJustValue = maybe.getJustValue;

  describe('Object', function() {
    var expectedObjects = [];
    var expectedFunctions = ['callProp', 'callPropWithArity', 'createObject', 'createObjectWithProps', 'createProp',
                             'curryOwn', 'defineProperties', 'defineProperty', 'deleteProp', 'descriptors',
                             'extend', 'extendOwn', 'extract', 'extractOrDefault', 'getOwnPropertyDescriptor',
                             'getOwnPropertyNames', 'hasOwnProperty', 'hasProperty', 'instanceOf', 'isPrototypeOf',
                             'keyValues', 'keys', 'maybeExtract', 'modify', 'safeCreateProp', 'safeDeleteProp',
                             'safeModify', 'safeSet', 'set', 'setOrThrow', 'shallowClone'];
    checkModule('object', object, expectedObjects, expectedFunctions);


    // Note: we allow the final parameter to be anything to allow the boxing coercions
    var cpwaSpec = {
      name: 'callPropWithArity',
      restrictions: [['string'], ['natural']],
      validArguments: [['toString'], [1]],
    };


    checkFunction(cpwaSpec, object.callPropWithArity, function(callPropWithArity) {
      var addReturnedCurriedArityTest = function(i) {
        it('Returned function is curried for arity ' + i, function() {
          var fn = callPropWithArity('prop', i);

          expect(fn.length).to.equal(1);
          if (i > 0)
            expect(arityOf(fn)).to.not.equal(1);
        });
      };


      var addReturnedArityTest = function(i) {
        it('Returned function has correct arity for arity ' + i, function() {
          var fn = callPropWithArity('prop', i);

          expect(arityOf(fn)).to.equal(i + 1);
        });
      };


      var functionalityArgs = [1, true, null, function() {}, []];
      var addCalledTest = function(i) {
        it('Returned function calls property on given object for arity ' + i, function() {
          var args = functionalityArgs.slice(0, i);
          var obj = {called: false, calledProp: function() {this.called = true;}};
          var caller = callPropWithArity('calledProp', i);
          caller.apply(null, args.concat([obj]));

          expect(obj.called).to.equal(true);
        });
      };


      var addReturnedValueTest = function(i) {
        it('Returned function returns correct result when called for arity ' + i, function() {
          var expected = functionalityArgs.slice(0, i);
          var obj = {calledProp: function() {return [].slice.call(arguments);}};
          var obj2 = {calledProp: function() {return 42;}};
          var caller = callPropWithArity('calledProp', i);
          var result = caller.apply(null, expected.concat([obj]));
          var result2 = caller.apply(null, expected.concat([obj2]));

          expect(result).to.deep.equal(expected);
          expect(result2).to.equal(42);
        });
      };


      var id = function(x) {return x;};
      var testObj;

      for (var i = 0; i < functionalityArgs.length; i++) {
        addReturnedCurriedArityTest(i);
        addReturnedArityTest(i);
        addCalledTest(i);
        addReturnedValueTest(i);
      }
    });


    var callPropSpec = {
      name: 'callProp',
      restrictions: [['string']],
      validArguments: [['toString']]
    };

    checkFunction(callPropSpec, object.callProp, function(callProp) {
      it('Returned function has correct arity', function() {
        var fn = callProp('prop');

        expect(fn.length).to.equal(1);
      });


      it('Returned function has correct \'real\' arity', function() {
        var fn = callProp('prop');

        expect(arityOf(fn)).to.equal(1);
      });


      it('Returned function calls prop on given object', function() {
        var obj = {called: false, calledProp: function() {this.called = true;}};
        var caller = callProp('calledProp');
        var result = caller(obj);

        expect(obj.called).to.equal(true);
      });


      it('Returned function returns correct result when called', function() {
        var obj = {calledProp: function() {return [].slice.call(arguments);}};
        var obj2 = {calledProp: function() {return 42;}};
        var caller = callProp('calledProp');
        var result = caller.call(null, obj);
        var result2 = caller.call(null, obj2);

        expect(result).to.deep.equal([]);
        expect(result2).to.equal(42);
      });
    });


    var hasOwnPropertySpec = {
      name: 'hasOwnProperty',
      restrictions: [['string'], NO_RESTRICTIONS],
      validArguments: [['toString'], [1]]
    };


    checkFunction(hasOwnPropertySpec, object.hasOwnProperty, function(hasOwnProperty) {
      it('Works correctly (1)', function() {
        var obj = {funkier: 1};
        var result = hasOwnProperty('funkier', obj);

        expect(result).to.equal(true);
      });


      it('Works correctly (2)', function() {
        var Constructor = function() {};
        Constructor.prototype.funkier = 1;
        var obj = new Constructor();
        var result = hasOwnProperty('funkier', obj);

        expect(result).to.equal(false);
      });


      it('Works correctly when object has custom hasOwnProperty function', function() {
       // hasOwnProperty lint warning suppression
       /* jshint -W001 */
        var obj = {
          'foo': 1,
          'hasOwnProperty': function(prop) {
            return prop !== 'foo';
          }
        };
        var result = hasOwnProperty('foo', obj);

        expect(result).to.equal(true);
      });


      it('Works correctly when object has null prototype', function() {
        var obj = Object.create(null);
        obj.foo = 1;
        var result = hasOwnProperty('foo', obj);

        expect(result).to.equal(true);
      });
    });


    var hpSpec = {
      name: 'hasProperty',
      restrictions: [['string'], NO_RESTRICTIONS],
      validArguments: [['toString'], [1]]
    };


    checkFunction(hpSpec, object.hasProperty, function(hasProperty) {
      it('Works correctly (1)', function() {
        var obj = {funkier: 1};
        var result = hasProperty('funkier', obj);

        expect(result).to.equal(true);
      });


      it('Works correctly (2)', function() {
        var Constructor = function() {};
        Constructor.prototype.funkier = 1;
        var obj = new Constructor();
        var result = hasProperty('funkier', obj);

        expect(result).to.equal(true);
      });
    });


    var ioSpec = {
      name: 'instanceOf',
      restrictions: [['function'], NO_RESTRICTIONS],
      validArguments: [[Object], [{}]]
    };


    checkFunction(ioSpec, object.instanceOf, function(instanceOf) {
      it('Works correctly (1)', function() {
        expect(instanceOf(Object, {})).to.equal(true);
      });


      it('Works correctly (2)', function() {
        var Constructor = function() {};
        var obj = new Constructor();

        expect(instanceOf(Constructor, obj)).to.equal(true);
      });


      it('Works correctly (3)', function() {
        var Constructor = function() {};
        var Proto = function() {};
        Constructor.prototype = Proto.prototype;
        var obj = new Constructor();

        expect(instanceOf(Proto, obj)).to.equal(true);
      });


      it('Works correctly (4)', function() {
        var Constructor = function() {};
        var Proto = function() {};
        var obj = new Constructor();

        expect(instanceOf(Proto, obj)).to.equal(false);
      });
    });


    describe('isPrototypeOf', function() {
      var isPrototypeOf = object.isPrototypeOf;


      it('Works correctly (1)', function() {
        expect(isPrototypeOf(Object.prototype, {})).to.equal(true);
      });


      it('Works correctly (2)', function() {
        var Constructor = function() {};
        var obj = new Constructor();

        expect(isPrototypeOf(Constructor.prototype, obj)).to.equal(true);
      });


      it('Works correctly (3)', function() {
        var Constructor = function() {};
        var Proto = function() {};
        Constructor.prototype = Proto.prototype;
        var obj = new Constructor();

        expect(isPrototypeOf(Proto.prototype, obj)).to.equal(true);
      });


      it('Works correctly (4)', function() {
        var Constructor = function() {};
        var Proto = function() {};
        var obj = new Constructor();

        expect(isPrototypeOf(Proto.prototype, obj)).to.equal(false);
      });


      it('Works correctly when object has custom isPrototypeOf function', function() {
        var obj = {
          'foo': 1,
          'isPrototypeOf': function(prop) {
            return true;
          }
        };
        var result = isPrototypeOf(obj, Object);

        expect(result).to.equal(false);
      });


      it('Works correctly when object has null prototype', function() {
        var obj = Object.create(null);
        obj.foo = 1;
        var result = isPrototypeOf(obj, Object);

        expect(result).to.equal(false);
      });
    });


    var coSpec = {
      name: 'createObject',
      restrictions: [['objectLikeOrNull']],
      validArguments: [[{}, function() {}, null, []]]
    };


    checkFunction(coSpec, object.createObject, function(createObject) {
      var isPrototypeOf = object.isPrototypeOf;
      var hasOwnProperty = object.hasOwnProperty;


      it('Returns an object', function() {
        var obj = {funkier: 1};
        var result = createObject(obj);

        expect(result).to.be.a('object');
      });


      it('Works correctly (1)', function() {
        var obj = {funkier: 1};
        var result = createObject(obj);

        expect(isPrototypeOf(obj, result)).to.equal(true);
      });


      it('Works correctly (2)', function() {
        var result = createObject(null);

        expect(Object.getPrototypeOf(result)).to.equal(null);
      });


      it('Ignores superfluous parameters', function() {
        var obj = {funkier: 1};
        var result = createObject(obj,
                      {prop1: {configurable: false, enumerable: false, writable: false, value: 42}});

        expect(hasOwnProperty('prop1', result)).to.equal(false);
      });
    });


    describe('createObjectWithProps', function() {
      var createObjectWithProps = object.createObjectWithProps;
      var isPrototypeOf = object.isPrototypeOf;
      var hasOwnProperty = object.hasOwnProperty;
      var descriptor = {prop1: {configurable: false, enumerable: false, writable: false, value: 42}};


      it('Returns an object', function() {
        var obj = {funkier: 1};
        var result = createObjectWithProps(obj, descriptor);

        expect(result).to.be.a('object');
      });


      var addWorksCorrectlyTests = function(message, proto) {
        it('Created objects have correct prototype ' + message, function() {
          var result = createObjectWithProps(proto, descriptor);

          expect(Object.getPrototypeOf(result)).to.equal(proto);
        });


        it('Created objects have correct properties ' + message, function() {
          var result = createObjectWithProps(proto, descriptor);

          // Need to call hasOwnProperty in this manner because of the null
          // proto test, which of course will not inherit from Object.prototype
          expect(Object.prototype.hasOwnProperty.call(result, 'prop1')).to.equal(true);
        });


        it('Created objects have correct descriptors ' + message, function() {
          var result = createObjectWithProps(proto, descriptor);

          var descriptorProps = descriptor.prop1;
          var actualDescriptor = Object.getOwnPropertyDescriptor(result, 'prop1');
          expect(actualDescriptor).to.deep.equal(descriptorProps);
        });
      };


      addWorksCorrectlyTests('for normal case', {});
      addWorksCorrectlyTests('when prototype is null', null);
    });


    var dpSpec = {
      name: 'defineProperty',
      restrictions: [['string'], ['object'], ['objectLike']],
      validArguments: [['myprop'], [{writable: true, value:42}], [{}, function() {}]]
    };


    checkFunction(dpSpec, object.defineProperty, function(defineProperty) {
      it('Returns the object', function() {
        var obj = {};
        var descriptor = {configurable: true, writable: false, enumerable: true, value: 42};
        var result = defineProperty('prop', descriptor, obj);

        expect(result).to.equal(obj);
      });


      it('Objects have the relevant property after calling defineProperty', function() {
        var obj = {};
        var descriptor = {configurable: true, writable: false, enumerable: true, value: 42};
        defineProperty('prop', descriptor, obj);

        expect(obj.hasOwnProperty('prop')).to.equal(true);
      });


      it('Objects have the property with the correct value after calling defineProperty', function() {
        var obj = {};
        var descriptor = {configurable: true, writable: false, enumerable: true, value: 42};
        defineProperty('prop', descriptor, obj);

        expect(obj.prop).to.deep.equal(descriptor.value);
      });


      it('The new property has the correct descriptor after calling defineProperty', function() {
        var obj = {};
        var descriptor = {configurable: true, writable: false, enumerable: true, value: 42};
        defineProperty('prop', descriptor, obj);
        var actualDescriptor = Object.getOwnPropertyDescriptor(obj, 'prop');

        expect(actualDescriptor).to.deep.equal(descriptor);
      });
    });


    var dpsSpec = {
      name: 'defineProperties',
      restrictions: [['object'], ['objectlike']],
      validArguments: [[{value: 42, writable: true}], [{}, function() {}]]
    };


    checkFunction(dpsSpec, object.defineProperties, function(defineProperties) {
      // Test data
      // Note: don't omit any optional properties, or we'll fail the equality check
      var descriptors = {
        prop1: {configurable: true, writable: false, enumerable: true, value: 42},
        prop2: {configurable: false, writable: true, enumerable: false, value: 'funkier'},
        prop3: {configurable: true, enumerable: true, get: function() {return false;}, set: undefined}
      };


      it('Returns the object', function() {
        var obj = {};
        var result = defineProperties(descriptors, obj);

        expect(result).to.equal(obj);
      });


      it('Objects have the relevant properties after calling defineProperties', function() {
        var obj = {};
        defineProperties(descriptors, obj);
        var newProps = Object.keys(descriptors);
        var allThere = newProps.every(function(p) {
          return obj.hasOwnProperty(p);
        });

        expect(allThere).to.equal(true);
      });


      it('Objects have the properties with the correct value after calling defineProperties', function() {
        var obj = {};
        defineProperties(descriptors, obj);
        var newProps = Object.keys(descriptors);

        newProps.forEach(function(p) {
          expect(obj[p]).to.deep.equal('get' in descriptors[p] ? descriptors[p].get() : descriptors[p].value);
        });
      });


      it('The new properties have the correct descriptors after calling defineProperties', function() {
        var obj = {};
        defineProperties(descriptors, obj);
        var newProps = Object.keys(descriptors);

        newProps.forEach(function(prop) {
          expect(Object.getOwnPropertyDescriptor(obj, prop)).to.deep.equal(descriptors[prop]);
        });
      });
    });


    describe('getOwnPropertyDescriptor', function() {
      var getOwnPropertyDescriptor = object.getOwnPropertyDescriptor;


      it('Returns undefined if property not present', function() {
        expect(getOwnPropertyDescriptor('prop', {})).to.equal(undefined);
      });


      it('Returns undefined if property exists only on prototype', function() {
        var Constructor = function() {};
        Constructor.prototype.prop = 42;
        var obj = new Constructor();

        expect(getOwnPropertyDescriptor('prop', obj)).to.equal(undefined);
      });


      it('Works correctly (1)', function() {
        var obj = {prop: 42};
        var realDescriptor = Object.getOwnPropertyDescriptor(obj, 'prop');
        var descriptor = getOwnPropertyDescriptor('prop', obj);

        expect(descriptor).to.deep.equal(realDescriptor);
      });


      it('Works correctly (2)', function() {
        // Let's use object itself as a reasonably complex object
        var keys = Object.keys(object);

        keys.forEach(function(k) {
          var realDescriptor = Object.getOwnPropertyDescriptor(object, k);
          var descriptor = getOwnPropertyDescriptor(k, object);
          expect(descriptor).to.deep.equal(realDescriptor);
        });
      });
    });


    var eSpec = {
      name: 'extract',
      restrictions: [['string'], ['objectLike']],
      validArguments: [['prop'], [{prop: 1}]]
    };


    checkFunction(eSpec, object.extract, function(extract) {
      it('Returns undefined if property not present (1)', function() {
        expect(extract('prop', {})).to.equal(undefined);
      });


      it('Returns undefined if property not present (2)', function() {
        var obj = {};
        // Define a property with no getter
        object.defineProperty('foo', {enumerable: true, set: function(x) {}});

        expect(extract('foo', obj)).to.equal(undefined);
      });


      it('Works correctly (1)', function() {
        var obj = {prop: 42};
        var result = extract('prop', obj);

        expect(result).to.deep.equal(obj.prop);
      });


      it('Works correctly (2)', function() {
        var obj = {funkier: function() {}};
        var result = extract('funkier', obj);

        expect(result).to.deep.equal(obj.funkier);
      });


      it('Works correctly (3)', function() {
        var Constructor = function() {};
        Constructor.prototype.prop = 42;
        var obj = new Constructor();
        var result = extract('prop', obj);

        expect(result).to.deep.equal(obj.prop);
      });
    });


    var eodSpec = {
      name: 'extractOrDefault',
      restrictions: [['string'], NO_RESTRICTIONS, ['objectLike']],
      validArguments: [['prop'], [2], [{prop: 1}]]
    };


    checkFunction(eodSpec, object.extractOrDefault, function(extractOrDefault) {
      it('Returns default if property not present (1)', function() {
        var defaultVal = 42;

        expect(extractOrDefault('prop', defaultVal, {})).to.equal(defaultVal);
      });


      it('Returns default if property not present (2)', function() {
        var defaultVal = 42;
        var obj = {};
        // Define a property with no getter
        object.defineProperty('foo', {enumerable: true, set: function(x) {}});

        expect(extractOrDefault('foo', defaultVal, obj)).to.equal(defaultVal);
      });


      it('Works correctly (1)', function() {
        var obj = {prop: 42};
        var defaultVal = 'default';
        var result = extractOrDefault('prop', defaultVal, obj);

        expect(result).to.deep.equal(obj.prop);
      });


      it('Works correctly (2)', function() {
        var obj = {funkier: function() {}};
        var defaultVal = 'default';
        var result = extractOrDefault('funkier', defaultVal, obj);

        expect(result).to.deep.equal(obj.funkier);
      });


      it('Works correctly (3)', function() {
        var Constructor = function() {};
        Constructor.prototype.prop = 42;
        var obj = new Constructor();
        var defaultVal = 'default';
        var result = extractOrDefault('prop', defaultVal, obj);

        expect(result).to.deep.equal(obj.prop);
      });


      it('Works correctly (4)', function() {
        var obj = {funkier: undefined};
        var defaultVal = 'default';
        var result = extractOrDefault('funkier', defaultVal, obj);

        expect(result).to.deep.equal(obj.funkier);
      });
    });


    var mbxSpec = {
      name: 'maybeExtract',
      restrictions: [['string'], ['objectLike']],
      validArguments: [['prop'], [{prop: 1}]]
    };


    checkFunction(mbxSpec, object.maybeExtract, function(maybeExtract) {
      it('Works correctly if property not present (1)', function() {
        expect(isNothing(maybeExtract('prop', {}))).to.equal(true);
      });


      it('Works correctly if property not present (2)', function() {
        var obj = {};
        // Define a property with no getter
        Object.defineProperty(obj, 'foo', {enumerable: true, set: function(x) {}});

        expect(isNothing(maybeExtract('foo', obj))).to.equal(true);
      });


      it('Works correctly (1)', function() {
        var obj = {prop: 42};
        var result = maybeExtract('prop', obj);

        expect(isJust(result)).to.equal(true);
        expect(getJustValue(result)).to.deep.equal(obj.prop);
      });


      it('Works correctly (2)', function() {
        var obj = {funkier: function() {}};
        var result = maybeExtract('funkier', obj);

        expect(isJust(result)).to.equal(true);
        expect(getJustValue(result)).to.deep.equal(obj.funkier);
      });
    });


    // The various object manipulation functions have a lot of commonality.
    // We generate common tests.

    var makeCommonTests = function(setter, shouldWrap) {
      var defineProperty = object.defineProperty;


      it('Behaves correctly if writable false (1)', function() {
        var a = {};
        defineProperty('foo', {writable: false, value: 1}, a);
        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, a);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });


      it('Behaves correctly if writable false (2)', function() {
        var A = function() {};
        defineProperty('foo', {enumerable: true, writable: false, value: 1}, A.prototype);

        var b = new A();
        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, b);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });


      it('Behaves correctly if no setter in descriptor (1)', function() {
        var a = (function() {
          var a = {};
          var privateProp = 1;
          var getter = function() {return privateProp;};
          defineProperty('foo', {get: getter}, a);
          return a;
        })();

        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, a);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });


      it('Behaves correctly if no setter in descriptor (2)', function() {
        var a = (function() {
          var A = function() {};
          var privateProp = 1;
          var getter = function() {return privateProp;};
          defineProperty('foo', {get: getter}, A.prototype);

          var b = new A();
          return b;
        })();

        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, a);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });


      it('Behaves correctly if preventExtensions has been called (1)', function() {
        var a = {};
        Object.preventExtensions(a);
        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, a);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });


      it('Behaves correctly if seal has been called (1)', function() {
        var a = {};
        Object.seal(a);
        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, a);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });


      it('Behaves correctly if freeze has been called (1)', function() {
        var a = {};
        Object.freeze(a);
        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, a);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });


      it('Behaves correctly if freeze has been called (2)', function() {
        var a = {foo: 1};
        Object.freeze(a);
        var val = 42;
        var result;
        var fn = function() {
          result = setter('foo', val, a);
        };

        if (shouldWrap) {
          expect(fn).to.not.throw();
          expect(isNothing(result)).to.equal(true);
        } else {
          expect(fn).to.throw();
        }
      });
    };


    var makeCommonModificationTests = function(setter, shouldWrap) {
      var defineProperty = object.defineProperty;
      var hasOwnProperty = object.hasOwnProperty;


      it('Returns object on success', function() {
        var a = {foo: 1};
        var result = setter('foo', 42, a);

        if (shouldWrap) {
          expect(isJust(result)).to.equal(true);
          expect(getJustValue(result)).to.equal(a);
        } else {
          expect(result).to.equal(a);
        }
      });


      it('Object has property afterwards', function() {
        var a = {foo: 1};
        setter('foo', 42, a);

        expect(hasOwnProperty('foo', a)).to.equal(true);
      });


      it('Object\'s property has correct value afterwards', function() {
        var a = {foo: 1};
        var val = 42;
        setter('foo', val, a);

        expect(a.foo).to.equal(val);
      });


      it('Behaves correctly if preventExtensions has been called (2)', function() {
        var a = {foo: 1};
        Object.preventExtensions(a);
        var val = 42;
        var result = setter('foo', val, a);

        if (shouldWrap) {
          expect(isJust(result)).to.equal(true);
          expect(getJustValue(result)).to.equal(a);
        } else {
          expect(result).to.equal(a);
        }

        expect(a.foo).to.equal(val);
      });


      it('Behaves correctly if seal has been called (2)', function() {
        var a = {foo: 1};
        Object.seal(a);
        var val = 42;
        var result = setter('foo', val, a);

        if (shouldWrap) {
          expect(isJust(result)).to.equal(true);
          expect(getJustValue(result)).to.equal(a);
        } else {
          expect(result).to.equal(a);
        }

        expect(a.foo).to.equal(val);
      });


      it('Propagates other errors', function() {
        var a = (function() {
          var a = {};
          var privateProp = 1;
          var getter = function() {return privateProp;};
          var badSetter = function() {throw new ReferenceError();};
          defineProperty('foo', {get: getter, set: badSetter}, a);
          return a;
        })();

        var val = 42;
        var fn = function() {
          setter('foo', val, a);
        };

        expect(fn).to.throw(Error);
      });


      if (!shouldWrap) {
        it('Propagates TypeErrors from causes other than the ones we suppress', function() {
          var a = (function() {
            var a = {};
            var privateProp = 1;
            var getter = function() {return privateProp;};
            var badSetter = function() {throw new TypeError();};
            defineProperty('foo', {get: getter, set: badSetter}, a);
            return a;
          })();

          var val = 42;
          var fn = function() {
            setter('foo', val, a);
          };

          expect(fn).to.throw(Error);
        });
      }
    };


    var makeCommonCreationTests = function(setter, shouldWrap) {
      var defineProperty = object.defineProperty;
      var hasOwnProperty = object.hasOwnProperty;


      it('Returns object on success', function() {
        var a = {};
        var result = setter('foo', 42, a);

        if (shouldWrap) {
          expect(isJust(result)).to.equal(true);
          expect(getJustValue(result)).to.equal(a);
        } else {
          expect(result).to.equal(a);
        }
      });


      it('Creates the property if it doesn\'t exist', function() {
        var a = {};
        var val = 42;
        setter('foo', val, a);

        expect(hasOwnProperty('foo', a)).to.equal(true);
      });


      it('Creates the property if it only exists on the prototype', function() {
        var A = function() {};
        A.prototype.foo = 1;
        var b = new A();
        var val = 42;
        setter('foo', val, b);

        expect(hasOwnProperty('foo', b)).to.equal(true);
        expect(b.foo).to.equal(val);
      });
    };


    var makeSetterTests = function(desc, setter, shouldWrap) {
      var spec = {
        name: desc,
        restrictions: [['string'], NO_RESTRICTIONS, ['objectlike']],
        validArguments: [['foo'], [1], [{}, function() {}]]
      };


      checkFunction(spec, setter, function(setter) {
        makeCommonTests(setter, shouldWrap);
        makeCommonModificationTests(setter, shouldWrap);
        makeCommonCreationTests(setter, shouldWrap);
      });
    };


    makeSetterTests('set', object.set, false);
    makeSetterTests('safeSet', object.safeSet, true);


    var makeModifierTests = function(desc, modifier, shouldWrap) {
      var spec = {
        name: desc,
        restrictions: [['string'], NO_RESTRICTIONS, ['objectlike']],
        validArguments: [['foo'], [1], [{}, function() {}]]
      };


      checkFunction(spec, modifier, function(modifier) {
        makeCommonTests(modifier, shouldWrap);
        makeCommonModificationTests(modifier, shouldWrap);


        it('Doesn\'t create the property if it doesn\'t exist', function() {
          var a = {};
          var val = 42;
          var result;
          var fn = function() {
            result = modifier('foo', val, a);
          };

          if (!shouldWrap) {
            expect(fn).to.throw();
          } else {
            expect(fn).to.not.throw();
            expect(isNothing(result)).to.equal(true);
          }

          expect(a).to.not.have.property('foo');
        });
      });
    };


    makeModifierTests('modify', object.modify, false);
    makeModifierTests('safeModify', object.safeModify, true);


    var makeCreatorTests = function(desc, creator, shouldWrap) {
      var spec = {
        name: desc,
        restrictions: [['string'], NO_RESTRICTIONS, ['objectlike']],
        validArguments: [['foo'], [1], [{}, function() {}]]
      };


      checkFunction(spec, creator, function(creator) {
        makeCommonTests(creator, shouldWrap);
        makeCommonCreationTests(creator, shouldWrap);


        it('Doesn\'t modify the property if it exists', function() {
          var a = {foo: 1};
          var val = 42;

          var result;
          var fn = function() {
            result = creator('foo', val, a);
          };

          if (!shouldWrap) {
            expect(fn).to.throw();
          } else {
            expect(fn).to.not.throw();
            expect(isNothing(result)).to.equal(true);
          }

          expect(a.foo).to.equal(1);
        });
      });
    };


    makeCreatorTests('createProp', object.createProp, false);
    makeCreatorTests('safeCreateProp', object.safeCreateProp, true);


    // The delete functions also have a similar structure
    var makeDeleterTests = function(desc, deleter, shouldWrap) {
      var spec = {
        name: desc,
        restrictions: [['string'], ['objectlike']],
        validArguments: [['abc'], [{}, function() {}]]
      };


      checkFunction(spec, deleter, function(deleter) {
        var hasOwnProperty = object.hasOwnProperty;
        var defineProperty = object.defineProperty;


        it('Object does not have property afterwards', function() {
          var a = {foo: 1};
          deleter('foo', a);

          expect(hasOwnProperty('foo', a)).to.equal(false);
        });


        it('Behaves correctly if object does not have property', function() {
          var a = {bar: 1};
          var result = deleter('foo', a);

          if (!shouldWrap) {
            expect(result).to.equal(a);
          } else {
            expect(isJust(result)).to.equal(true);
            expect(getJustValue(result)).to.equal(a);
          }
        });


        it('Behaves correctly if object does not have property but prototype does', function() {
          var A = function() {};
          A.prototype.foo = 1;
          var b = new A();
          var result = deleter('foo', b);

          if (!shouldWrap) {
            expect(result).to.equal(b);
          } else {
            expect(isJust(result)).to.equal(true);
            expect(getJustValue(result)).to.equal(b);
          }

          expect(hasOwnProperty('foo', Object.getPrototypeOf(b))).to.equal(true);
        });


        it('Behaves correctly if configurable false', function() {
          var a = {};
          defineProperty('foo', {configurable: false, value: 1}, a);
          var result;
          var fn = function() {
            result = deleter('foo', a);
          };

          if (!shouldWrap) {
            expect(fn).to.throw();
          } else {
            expect(fn).to.not.throw();
            expect(isNothing(result)).to.equal(true);
          }

          expect(a).to.have.property('foo');
          expect(a.foo).to.equal(1);
        });


        it('Behaves correctly if preventExtensions called (1)', function() {
          var a = {foo: 1};
          Object.preventExtensions(a);
          var result = deleter('foo', a);

          if (!shouldWrap) {
            expect(result).to.equal(a);
          } else {
            expect(isJust(result)).to.equal(true);
            expect(getJustValue(result)).to.equal(a);
          }

          expect(hasOwnProperty('foo', a)).to.equal(false);
        });


        it('Behaves correctly if preventExtensions called (2)', function() {
          var a = {};
          Object.preventExtensions(a);
          var result = deleter('foo', a);

          if (!shouldWrap) {
            expect(result).to.equal(a);
          } else {
            expect(isJust(result)).to.equal(true);
            expect(getJustValue(result)).to.equal(a);
          }
        });


        it('Behaves correctly if seal called (1)', function() {
          var a = {};
          Object.seal(a);
          var result = deleter('foo', a);

          if (!shouldWrap) {
            expect(result).to.equal(a);
          } else {
            expect(isJust(result)).to.equal(true);
            expect(getJustValue(result)).to.equal(a);
          }
        });


        it('Behaves correctly if seal called (2)', function() {
          var a = {foo: 1};
          Object.seal(a);
          var result;
          var fn = function() {
            result = deleter('foo', a);
          };

          if (!shouldWrap) {
            expect(fn).to.throw();
          } else {
            expect(fn).to.not.throw();
            expect(isNothing(result)).to.equal(true);
          }

          expect(a).to.have.property('foo');
        });


        it('Behaves correctly if freeze called (1)', function() {
          var a = {};
          Object.freeze(a);
          var result =  deleter('foo', a);

          if (!shouldWrap) {
            expect(result).to.equal(a);
          } else {
            expect(isJust(result)).to.equal(true);
            expect(getJustValue(result)).to.equal(a);
          }
        });


        it('Behaves correctly if freeze called (2)', function() {
          var a = {foo: 1};
          Object.freeze(a);
          var result;
          var fn = function() {
            result = deleter('foo', a);
          };

          if (!shouldWrap) {
            expect(fn).to.throw();
          } else {
            expect(fn).to.not.throw();
            expect(isNothing(result)).to.equal(true);
          }

          expect(a).to.have.property('foo');
        });
      });
    };


    makeDeleterTests('deleteProp', object.deleteProp, false);
    makeDeleterTests('safeDeleteProp', object.safeDeleteProp, true);


    var nonObjects = [
      {name: 'number', val: 1},
      {name: 'boolean', val: true},
      {name: 'string', val: 'a'},
      {name: 'undefined', val: undefined},
      {name: 'null', val: null}];


    var makeKeyBasedTests = function(desc, fnUnderTest, verifier, expectNonEnumerable) {
      var defineProperty = object.defineProperty;


      describe(desc, function() {
        var makeNonObjectTest = function(val) {
          return function() {
            var result = fnUnderTest(val);
            expect(result).to.deep.equal([]);
          };
        };


        nonObjects.forEach(function(test) {
          it('Returns empty array for value of type ' + test.name,
             makeNonObjectTest(test.val));
        });


        it('Returns empty array for empty object', function() {
          var result = fnUnderTest({});
          expect(result).to.deep.equal([]);
        });


        var addReturnsCorrectTest = function(message, obj) {
          it('Returns correct value for ' + message, function() {
            var expected = verifier(obj);
            var result = fnUnderTest(obj);

            expect(result).to.deep.equal(expected);
          });
        };


        addReturnsCorrectTest('object (1)', {foo: 1, bar: 2, baz: 3});
        addReturnsCorrectTest('object (2)', object);
        addReturnsCorrectTest('array', [1, 2, 3]);
        addReturnsCorrectTest('empty array', []);


        it('Only returns own properties', function() {
          var F = function() {this.baz = 42;};
          F.prototype = {foo: 1, bar: 2};
          var a = new F();
          var expected = verifier(a);
          var result = fnUnderTest(a);

          expect(result).to.deep.equal(expected);
        });


        it('Behaves correctly with non-enumerable properties', function() {
          var a = {foo: 1, bar: 2};
          defineProperty('baz', {enumerable: false, value: 1}, a);
          var result = fnUnderTest(a).indexOf('baz');

          expect(result !== -1).to.equal(expectNonEnumerable);
        });
      });
    };


    makeKeyBasedTests('keys', object.keys, Object.keys, false);
    makeKeyBasedTests('getOwnPropertyNames', object.getOwnPropertyNames, Object.getOwnPropertyNames, true);


    var makeKeyPairBasedTests = function(desc, fnUnderTest, verifier) {
      describe(desc, function() {
        var makeNonObjectTest = function(val) {
          return function() {
            var result = fnUnderTest(val);
            expect(result).to.deep.equal([]);
          };
        };


        nonObjects.forEach(function(test) {
          it('Returns empty array for value of type ' + test.name,
             makeNonObjectTest(test.val));
        });


        it('Returns empty array for empty object', function() {
          var result = fnUnderTest({});
          expect(result).to.deep.equal([]);
        });


        var verifyKeys = function(obj, result) {
          var keys = result.map(function(r) {return r[0];});
          var expected = Object.keys(obj);

          expect(Array.isArray(result)).to.equal(true);
          expect(result.every(function(val) {
            return Array.isArray(val) && val.length === 2;
          })).to.equal(true);
          expect(keys).to.deep.equal(expected);
        };


        var verifyValues = function(obj, result) {
          var keys = result.map(function(r) {return r[0];});
          var values = result.map(function(r) {return r[1];});
          return values.every(function(val, i) {
            var key = keys[i];
            return verifier(val, key, obj);
          });
        };


        var addReturnsCorrectTests = function(message, obj) {
          it('Returns correct keys for ' + message, function() {
            var result = fnUnderTest(obj);

            verifyKeys(obj, result);
          });


          it('Returns correct values for ' + message, function() {
            var result = fnUnderTest(obj);

            verifyValues(obj, result);
          });
        };


        addReturnsCorrectTests('object (1)', {foo: 1, bar: 2, baz: 3});
        addReturnsCorrectTests('object (2)', object);
        addReturnsCorrectTests('array', [1, 2, 3]);
        addReturnsCorrectTests('empty array', []);


        it('Only returns keys for own properties', function() {
          var F = function() {this.baz = 42;};
          F.prototype = {foo: 1, bar: 2};
          var a = new F();
          var result = fnUnderTest(a);

          verifyKeys(a, result);
        });


        it('Only returns values for own properties', function() {
          var F = function() {this.baz = 42;};
          F.prototype = {foo: 1, bar: 2};
          var a = new F();
          var result = fnUnderTest(a);

          verifyValues(a, result);
        });
      });
    };


    makeKeyPairBasedTests('keyValues', object.keyValues, function(val, key, obj) {return val === obj[key];});

    var propVerifier = function(val, key, obj) {
      return deepEqual(val, object.getOwnPropertyDescriptor(key, obj));
    };
    makeKeyPairBasedTests('descriptors', object.descriptors, propVerifier);


    var makeCloneTests = function(desc, fnUnderTest, additionalTests) {
      describe(desc, function() {
        var isPrototypeOf = object.isPrototypeOf;
        var keys = object.keys;
        var defineProperty = object.defineProperty;
        var getOwnPropertyNames = object.getOwnPropertyNames;
        var getOwnPropertyDescriptor = object.getOwnPropertyDescriptor;


        it('New object has does not have same prototype', function() {
          var F = function() {};
          var a = new F();
          var clone = fnUnderTest(a);

          expect(isPrototypeOf(Object.getPrototypeOf(a), clone)).to.equal(false);
        });


        it('New array does have same prototype', function() {
          var a = [1, 2, 3];
          var clone = fnUnderTest(a);

          expect(isPrototypeOf(Object.getPrototypeOf(a), clone)).to.equal(true);
        });


        it('New object has same own keys as original', function() {
          var a = {foo: 1, bar: 2, baz: 3};
          var clone = fnUnderTest(a);
          var origKeys = keys(a);
          var cloneKeys = keys(clone);

          expect(cloneKeys).to.deep.equal(origKeys);
        });


        it('New array has same length as original', function() {
          var a = [1, 2, 3];
          var clone = fnUnderTest(a);

          expect(clone.length).to.equal(a.length);
        });


        it('New object has non-enumerable keys from original', function() {
          var a = {foo: 1, bar: 2};
          defineProperty('baz', {enumerable: false, value: 42}, a);
          var clone = fnUnderTest(a);
          var origKeys = getOwnPropertyNames(a);
          var cloneKeys = getOwnPropertyNames(clone);

          expect(origKeys).to.deep.equal(cloneKeys);
        });


        it('Enumerable properties are enumerable on clone', function() {
          var a = {foo: 1, bar: 2};
          var clone = fnUnderTest(a);
          var fooDescriptor = getOwnPropertyDescriptor('foo', clone);
          var barDescriptor = getOwnPropertyDescriptor('bar', clone);

          expect(fooDescriptor.enumerable).to.equal(true);
          expect(barDescriptor.enumerable).to.equal(true);
        });


        it('Non-enumerable properties are enumerable on clone', function() {
          var a = {foo: 1, bar: 2};
          defineProperty('baz', {enumerable: false, value: 42}, a);
          var clone = fnUnderTest(a);
          var bazDescriptor = getOwnPropertyDescriptor('baz', clone);

          expect(bazDescriptor.enumerable).to.equal(false);
        });


        it('Additional properties on arrays are copied', function() {
          var a = [];
          a.foo = 42;
          a['2.1'] = 'foo';
          var clone = fnUnderTest(a);

          expect(clone.hasOwnProperty('foo')).to.equal(true);
          expect(clone.hasOwnProperty('2.1')).to.equal(true);
        });


        it('Additional properties on functions are copied', function() {
          var f = function() {};
          f.bar = 42;
          var clone = fnUnderTest(f);

          expect(clone.hasOwnProperty('bar')).to.equal(true);
        });


        it('Cloning copies properties all the way up the prototype chain', function() {
          var a = {};
          defineProperty('foo', {enumerable: true, value: 'a'}, a);
          defineProperty('bar', {enumerable: false, value: 1}, a);
          var F = function() {};
          F.prototype = Object.create(a);
          defineProperty('fizz', {enumerable: true, value: 3}, a);
          defineProperty('buzz', {enumerable: false, value: 5}, a);
          var b = new F();
          var clone = fnUnderTest(b);
          var cloneProps = getOwnPropertyNames(clone);
          var hasProp = function(p) {return cloneProps.indexOf(p) !== -1;};
          var expectedProps = ['foo', 'bar', 'fizz', 'buzz'];
          var result = expectedProps.every(hasProp);

          expect(result).to.equal(true);
        });


        it('Clones have Object.prototype as their prototype if in prototype chain of original (1)', function() {
          var a = {};
          var clone = fnUnderTest(a);

          expect(Object.getPrototypeOf(clone)).to.equal(Object.prototype);
        });


        it('Clones have Object.prototype as their prototype if in prototype chain of original (2)', function() {
          var a = {};
          var b = Object.create(a);
          var clone = fnUnderTest(b);

          expect(Object.getPrototypeOf(clone)).to.equal(Object.prototype);
        });


        it('Clones have null as their prototype if in prototype chain of original', function() {
          var a = Object.create(null);
          var clone = fnUnderTest(a);

          expect(Object.getPrototypeOf(clone)).to.equal(null);
        });


        it('Cloning doesn\'t copy Object.prototype values if Object.prototype in prototype chain (2)', function() {
          var clone = fnUnderTest(Object.prototype);
          var objProto = getOwnPropertyNames(Object.prototype);
          var cloneProps = getOwnPropertyNames(clone);
          var result = objProto.every(function(k) {
            return cloneProps.indexOf(k) === -1;
          });

          expect(result).to.equal(true);
        });


        it('Cloning doesn\'t copy Array.prototype values', function() {
          var a = [];
          var clone = fnUnderTest(a);
          var arrProto = getOwnPropertyNames(Array.prototype);
          var cloneProps = getOwnPropertyNames(clone);
          var result = arrProto.every(function(k) {
            // Array.prototype does have a length property!
            if (k === 'length') return true;

            return cloneProps.indexOf(k) === -1;
          });

          expect(result).to.equal(true);
        });


        it('Cloning returns functions unchanged', function() {
          var a = function() {};
          var clone = fnUnderTest(a);
          expect(clone).to.equal(a);
        });


        it('Properties from prototype chain are copied in correct order', function() {
          var a = {foo: 1};
          var b = Object.create(a);
          b.foo = 2;
          var clone = fnUnderTest(b);

          expect(clone.foo).to.equal(2);
        });


        it('Handles null correctly', function() {
          var a = null;
          var clone = fnUnderTest(a);

          expect(a).to.equal(clone);
        });


        additionalTests(fnUnderTest);
      });
    };


    makeCloneTests('shallowClone', object.shallowClone, function(shallowClone) {
      it('New array has same values as original', function() {
        var a = [1, 2, 3, function() {}, {foo: 7, bar: 42}];
        var clone = shallowClone(a);
        clone.forEach(function(val, i) {
          expect(val).to.equal(a[i]);
        });
      });


      it('New object has same values as original', function() {
        var a = {
          foo: 42,
          bar: function() {},
          baz: [1, 2, 3],
          other: {v1: true, v2: {foo: 7, bar: 9}, v3: null}
        };
        object.defineProperty('nonenum', {enumerable: false, value: 'a'}, a);

        var clone = shallowClone(a);
        var result = object.getOwnPropertyNames(clone).forEach(function(k) {
          expect(clone[k]).to.equal(a[k]);
        });
      });
    });


    /* TODO REINSTATE DEEPCLONE
    makeCloneTests('deepClone', object.deepClone, function(deepClone) {
      var isPrimitive = function(v) {
         return ['string', 'number', 'boolean', 'undefined', 'function'].indexOf(typeof(v)) !== -1;
      };


      it('New array has same values as original', function() {
        var a = [1, 2, 3, function() {}, {foo: 7, bar: 42}, [4, 5]];
        var clone = deepClone(a);
        clone.forEach(function(val, i) {
          if (isPrimitive(val)) {
            expect(val).to.equal(a[i]);
          } else {
            expect(val).to.not.equal(a[i]);
            expect(val).to.deep.equal(a[i]);
          }
        });
      });


      it('New object has same values as original', function() {
        var a = {
          foo: 42,
          bar: function() {},
          baz: [1, 2, 3],
          other: {v1: true, v2: {foo: 7, bar: 9}, v3: null}
        };
        defineProperty('nonenum', {enumerable: false, value: 'a'}, a);

        var clone = deepClone(a);
        var result = getOwnPropertyNames(clone).forEach(function(k) {
          var val = clone[k];

          if (isPrimitive(val)) {
            expect(val).to.equal(a[k]);
          } else {
            expect(val).to.not.equal(a[k]);
            expect(val).to.deep.equal(a[i]);
          }
        });
      });


      it('Circularity handled correctly (1)', function() {
        var a = {};
        a.foo = a;
        var clone = deepClone(a);

        expect(clone).to.deep.equal(a);
      });


      it('Circularity handled correctly (2)', function() {
        var a = {};
        var b = Object.create(a);
        a.foo = b;
        var clone = deepClone(b);

        expect(clone).to.deep.equal(b);
      });


      it('Circularity handled correctly (3)', function() {
        var a = [];
        a[0] = a;
        var clone = deepClone(a);

        expect(clone).to.deep.equal(a);
      });
    });
    */


    var makeExtendTests = function(desc, fnUnderTest, remainingTests) {
      var spec = {
        name: desc,
        restrictions: [NO_RESTRICTIONS, ['objectLike']],
        validArguments: [[{}], [{}, function() {}]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        it('Returns the destination object', function() {
          var dest = {};
          var result = fnUnderTest({}, dest);

          expect(result).to.equal(dest);
        });


        it('Every enumerable property in object afterwards', function() {
          var source = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
          var dest = {};
          fnUnderTest(source, dest);

          for (var key in source)
          expect(dest).to.have.ownProperty(key);
        });


        it('Every enumerable property has correct value afterwards', function() {
          var source = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
          var dest = {};
          fnUnderTest(source, dest);

          for (var key in source)
            expect(dest[key]).to.equal(source[key]);
        });


        it('Throws if preventExtensions has been called', function() {
          var source = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
          var dest = {};
          Object.preventExtensions(dest);

          var fn = function() {
            fnUnderTest(source, dest);
          };

          expect(fn).to.throw();
        });


        it('Behaves correctly if preventExtensions has been called and properties present', function() {
          var source = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
          var dest = {foo: 2, baz: 'b', bar: {}, fizz: [], buzz: 'a'};
          Object.preventExtensions(dest);

          var fn = function() {
            fnUnderTest(source, dest);
          };

          expect(fn).to.not.throw();
        });


        it('Throws if seal has been called', function() {
          var source = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
          var dest = {};
          Object.seal(dest);

          var fn = function() {
            fnUnderTest(source, dest);
          };

          expect(fn).to.throw();
        });


        it('Throws if seal has been called and properties already present but not writable', function() {
          var source = {foo: 1};
          var dest = {};
          Object.defineProperty(dest, 'foo', {foo: 2});
          Object.seal(dest);

          var fn = function() {
            fnUnderTest(source, dest);
          };

          expect(fn).to.throw();
        });


        it('Behaves correctly if seal has been called and properties already present', function() {
          var source = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
          var dest = {foo: 2, baz: 'b', bar: {}, fizz: [], buzz: 'a'};
          Object.seal(dest);

          var fn = function() {
            fnUnderTest(source, dest);
          };

          expect(fn).to.not.throw();
        });


        it('Throws if freeze has been called', function() {
          var source = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
          var dest = {};
          Object.freeze(dest);

          var fn = function() {
            fnUnderTest(source, dest);
          };

          expect(fn).to.throw();
        });


        it('Non-enumerable properties not copied', function() {
          var source = {};
          object.defineProperty('foo', {enumerable: false, value: 1}, source);
          var dest = {};
          fnUnderTest(source, dest);

          expect(dest).to.not.have.property('foo');
        });


        it('Existing values overwritten', function() {
          var source = {foo: 2};
          var dest = {foo: 1};
          fnUnderTest(source, dest);

          expect(dest.foo).to.equal(source.foo);
        });


        remainingTests(fnUnderTest);
      });
    };


    makeExtendTests('extend', object.extend, function(extend) {
      it('Every enumerable property from prototype chain in object afterwards', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {};
        extend(source, dest);

        for (var key in proto)
          expect(dest).to.have.ownProperty(key);
      });


      it('Every enumerable property from prototype has correct value afterwards', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {};
        extend(source, dest);

        for (var key in proto)
          expect(dest[key]).to.equal(proto[key]);
      });


      it('Values from prototype copied to dest, not dests prototype', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {};
        extend(source, dest);

        for (var key in proto)
          expect(dest.hasOwnProperty(key)).to.equal(true);
      });


      it('Throws if seal has been called and properties already present but not writable (2)', function() {
        var proto = {foo: 1};
        var source = Object.create(proto);
        var dest = {};
        Object.defineProperty(dest, 'foo', {foo: 2});
        Object.seal(dest);

        var fn = function() {
          fnUnderTest(source, dest);
        };

        expect(fn).to.throw();
      });


      it('Behaves correctly if seal has been called and properties already present (2)', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {foo: 2, baz: 'b', bar: {}, fizz: [], buzz: 'a'};
        Object.seal(dest);

        var fn = function() {
          extend(source, dest);
        };

        expect(fn).to.not.throw();
      });


      it('Behaves correctly if preventExtensions has been called and properties present (2)', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {foo: 2, baz: 'b', bar: {}, fizz: [], buzz: 'a'};
        Object.preventExtensions(dest);

        var fn = function() {
          extend(source, dest);
        };

        expect(fn).to.not.throw();
        Object.keys(proto).forEach(function(k) {
          expect(dest[k]).to.equal(proto[k]);
        });
      });
    });


    makeExtendTests('extendOwn', object.extendOwn, function(extendOwn) {
      it('No enumerable properties from prototype chain in object afterwards', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {};
        extendOwn(source, dest);

        for (var key in proto)
          expect(dest).to.not.have.property(key);
      });


      it('Non-enumerable properties not copied', function() {
        var proto = {};
        object.defineProperty('foo', {enumerable: false, value: 1}, proto);
        var source = Object.create(proto);
        var dest = {};
        extendOwn(source, dest);

        expect(dest).to.not.have.property('foo');
      });


      it('Behaves correctly if preventExtensions has been called (2)', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {};
        Object.preventExtensions(dest);

        var fn = function() {
          extendOwn(source, dest);
        };

        expect(fn).to.not.throw();
      });


      it('Behaves correctly if preventExtensions has been called and properties present (2)', function() {
        var proto = {foo: 1, baz: 'a', bar: {}, fizz: [], buzz: function() {}};
        var source = Object.create(proto);
        var dest = {foo: 2, baz: 'b', bar: {}, fizz: [], buzz: 'a'};
        Object.preventExtensions(dest);

        var fn = function() {
          extendOwn(source, dest);
        };

        expect(fn).to.not.throw();
        Object.keys(proto).forEach(function(k) {
          expect(dest[k]).to.not.equal(proto[k]);
        });
      });


      it('Does not throw if seal has been called and properties only present on prototype (2)', function() {
        var proto = {foo: 1};
        var source = Object.create(proto);
        var dest = {};
        Object.defineProperty(dest, 'foo', {foo: 2});
        Object.seal(dest);

        var fn = function() {
          extendOwn(source, dest);
        };

        expect(fn).to.not.throw();
      });
    });


    var curryOwnSpec = {
      name: 'curryOwn',
      restrictions: [['objectLike']],
      validArguments: [[{}, function() {}]]
    };


    checkFunction(curryOwnSpec, object.curryOwn, function(curryOwn) {
      it('Returns the object', function() {
        var foo = function(x, y) {};
        var bar = function(x, y, z) {};
        var obj = {foo: foo, bar: bar};

        expect(curryOwn(obj)).to.equal(obj);
      });


      it('Works correctly (1)', function() {
        var foo = function(x, y) {};
        var bar = function(x, y, z) {};
        var obj = {foo: foo, bar: bar};
        curryOwn(obj);

        // If its curried, recurrying won't change the function
        expect(objectCurry(obj.foo)).to.equal(obj.foo);
        expect(objectCurry(obj.bar)).to.equal(obj.bar);
      });


      it('Works correctly (2)', function() {
        var foo = function(x, y) { return this; };
        var bar = function(x, y, z) { return this; };
        var obj = {foo: foo, bar: bar};
        curryOwn(obj);

        expect(obj.foo(1)(2)).to.equal(obj);
        expect(obj.bar('a')('b')('c')).to.equal(obj);
      });


      it('Non-functional values should be untouched', function() {
        var foo = 42;
        var bar = {};
        var obj = {foo: foo, bar: bar};

        curryOwn(obj);

        expect(obj.foo).to.equal(foo);
        expect(obj.bar).to.equal(bar);
      });


      it('Values are unchanged if any function not writable', function() {
        var foo = function(x, y) {};
        var bar = function(x, y, z) {};
        var obj = {bar: bar};
        Object.defineProperty(obj, 'foo', {enumerable: true, value: foo});
        curryOwn(obj);

        // No need to check foo, we know it cannot be changed
        expect(obj.bar).to.equal(bar);
      });


      it('Functions with getters are unchanged', function() {
        var foo = function(x, y) {};
        var bar = function(x, y, z) {};
        var obj = {foo: foo, get bar() { return bar; }};
        Object.defineProperty(obj, 'foo', {value: foo});
        curryOwn(obj);

        expect(obj.bar).to.equal(bar);
        expect(objectCurry(obj.foo)).to.equal(obj.foo);
      });


      it('Functions with setters are unchanged', function() {
        var foo = function(x, y) {};
        var bar = function(x, y, z) {};
        var obj = {foo: foo, get bar() { return bar; }, set bar(f) { return bar; }};
        Object.defineProperty(obj, 'foo', {value: foo});
        curryOwn(obj);

        expect(obj.bar).to.equal(bar);
        expect(objectCurry(obj.foo)).to.equal(obj.foo);
      });


      it('Values are unchanged if not enumerable', function() {
        var foo = function(x, y) {};
        var obj = {};
        Object.defineProperty(obj, 'foo', {enumerable: false, value: foo});
        curryOwn(obj);

        // No need to check foo, we know it cannot be changed
        expect(obj.foo).to.equal(foo);
      });


      it('Behaves correctly if object sealed', function() {
        var foo = function(x, y) {};
        var bar = function(x, y, z) {};
        var obj = {foo: foo, bar: bar};
        Object.seal(obj);
        curryOwn(obj);

        // If its curried, recurrying won't change the function
        expect(objectCurry(obj.foo)).to.equal(obj.foo);
        expect(objectCurry(obj.bar)).to.equal(obj.bar);
      });


      it('Functions in prototype are unchanged', function() {
        var foo = function(x, y) {};
        var proto = {foo: foo};
        var obj = Object.create(proto);
        obj.bar = function(x, y, z) {};
        curryOwn(obj);

        expect(objectCurry(obj.bar)).to.equal(obj.bar);
        expect(proto.foo).to.equal(foo);
      });


      it('Unaffected by writable status of functions on prototype', function() {
        var foo = function(x, y) {};
        var proto = {};
        Object.defineProperty(proto, 'foo', {value: foo});
        var obj = Object.create(proto);
        obj.bar = function(x, y, z) {};
        curryOwn(obj);

        expect(objectCurry(obj.bar)).to.equal(obj.bar);
      });


      it('Unaffected by freeze status of functions on prototype', function() {
        var foo = function(x, y) {};
        var proto = {foo: foo};
        Object.freeze(proto);
        var obj = Object.create(proto);
        obj.bar = function(x, y, z) {};
        curryOwn(obj);

        expect(objectCurry(obj.bar)).to.equal(obj.bar);
      });
    });
  });
})();

},{"../../lib/components/curry":13,"../../lib/components/maybe":18,"../../lib/components/object":19,"./testingUtilities":63,"chai":64,"deep-equal":28}],59:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var pair = require('../../lib/components/pair');

  var curryModule = require('../../lib/components/curry');
  var arityOf = curryModule.arityOf;

  var utils = require('../../lib/internalUtilities');
  var valueStringifier = utils.valueStringifier;

  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;


  describe('Pair', function() {
    var expectedObjects = [];
    var expectedFunctions = ['Pair', 'fst', 'snd', 'isPair', 'asArray'];
    checkModule('pair', pair, expectedObjects, expectedFunctions);


    var Pair = pair.Pair;
    var fst = pair.fst;
    var snd = pair.snd;


    describe('Pair constructor', function() {
      it('Has correct arity', function() {
        expect(arityOf(Pair)).to.equal(2);
      });


      it('Throws when called with no arguments (1)', function() {
        var fn = function() {
          new Pair();
        };

        expect(fn).to.throw(TypeError);
      });


      it('Throws when called with no arguments (2)', function() {
        var fn = function() {
          Pair();
        };

        expect(fn).to.throw(TypeError);
      });


      var makePairTest = function(message, testMaker) {
        var withNew = function() {
          return new Pair(1, 2);
        };

        var noNew = function() {
          return Pair(1, 2);
        };


        it(message + ' (when pair constructed with new)', testMaker(withNew));
        it(message + ' (when pair constructed without new)', testMaker(noNew));
      };


      makePairTest('Returns an object', function(pairMaker) {
        return function() {
          var p = pairMaker();

          expect(p).to.be.an('object');
        };
      });


      makePairTest('instanceof correct', function(pairMaker) {
        return function() {
          var p = pairMaker();

          expect(p).to.be.an.instanceOf(Pair);
        };
      });


      makePairTest('constructor correct', function(pairMaker) {
        return function() {
          var p = pairMaker();

          expect(p.constructor).equal(Pair);
        };
      });


      makePairTest('Has \'first\' property', function(pairMaker) {
        return function() {
          var p = pairMaker();
          var props = Object.getOwnPropertyNames(p);
          var result = props.indexOf('first') !== -1;

          expect(result).to.equal(true);
        };
      });


      makePairTest('Has \'second\' property', function(pairMaker) {
        return function() {
          var p = pairMaker();
          var props = Object.getOwnPropertyNames(p);
          var result = props.indexOf('second') !== -1;

          expect(result).to.equal(true);
        };
      });


      makePairTest('\'first\' and \'second\' properties are not enumerable', function(pairMaker) {
        return function() {
          var p = pairMaker();
          var first = false;
          var second = false;
          for (var prop in p) {
            if (prop === 'first') first = true;
            if (prop === 'second') second = true;
          }
          var result = !first && !second;

          expect(result).to.equal(true);
        };
      });


      makePairTest('\'first\' is immutable', function(pairMaker) {
        return function() {
          var p = pairMaker();
          var fn = function() {
            p.first = 3;
          };

          expect(fn).to.throw(TypeError);
        };
      });


      makePairTest('\'second\' is immutable', function(pairMaker) {
        return function() {
          var p = pairMaker();
          var fn = function() {
            p.second = 3;
          };

          expect(fn).to.throw(TypeError);
        };
      });


      makePairTest('Returns function of arity 1 if called with one argument', function(pairMaker) {
        return function() {
          var p = new Pair(1);

          expect(p).to.be.a('function');
          expect(p.length).to.equal(1);
        };
      });


      var makeCurriedPairTest = function(message, testMaker) {
        var withNew = function() {
          return new Pair(1);
        };

        var noNew = function() {
          return Pair(1);
        };


        it(message + ' (when pair constructed with new', testMaker(withNew));
        it(message + ' (when pair constructed without new', testMaker(noNew));
      };


      makeCurriedPairTest('Returns Pair when called with 1 argument, and result is called with another', function(pairMaker) {
        return function() {
          var f = pairMaker();
          var p = f(2);

          expect(p).to.be.an('object');
          expect(p).to.be.an.instanceOf(Pair);
        };
      });


      makeCurriedPairTest('Returned function can be called with new', function(pairMaker) {
        return function() {
          var F = pairMaker();
          var p = new F(2);

          expect(p).to.be.an('object');
          expect(p).to.be.an.instanceOf(Pair);
        };
      });


      makeCurriedPairTest('Returned function can be called without new', function(pairMaker) {
        return function() {
          var f = pairMaker();
          var p = f(2);

          expect(p).to.be.an('object');
          expect(p).to.be.an.instanceOf(Pair);
        };
      });


      makeCurriedPairTest('instanceof also correct in terms of returned function (1)', function(pairMaker) {
        return function() {
          var F = pairMaker();
          var p = new F(2);

          expect(p).to.be.an.instanceOf(F);
        };
      });


      makeCurriedPairTest('instanceof also correct in terms of returned function (2)', function(pairMaker) {
        return function() {
          var f = pairMaker();
          var p = f(2);

          expect(p).to.be.an.instanceOf(f);
        };
      });


      makeCurriedPairTest('Returned object correct (1)', function(pairMaker) {
        return function() {
          var F = pairMaker();
          var p = new F(2);

          expect(fst(p)).to.equal(1);
          expect(snd(p)).to.equal(2);
        };
      });


      makeCurriedPairTest('Returned object correct (2)', function(pairMaker) {
        return function() {
          var f = pairMaker();
          var p = f(2);

          expect(fst(p)).to.equal(1);
          expect(snd(p)).to.equal(2);
        };
      });
    });


    // Test data for generating the fst and snd tests
    var tests = [
     [1, 'a'], [true, {}], [[2], null], [undefined, function() {}]
    ];


    var fstSpec = {
      name: 'fst',
      restrictions: [[Pair]],
      validArguments: [[new Pair(1, 2)]]
    };


    checkFunction(fstSpec, fst, function(fst) {
      tests.forEach(function(t, i) {
        it('Works correctly (' + (i + 1) + ')', function() {
          var p = Pair(t[0], t[1]);

          expect(fst(p)).to.equal(t[0]);
        });


        it('Works correctly (' + (i + 2) + ')', function() {
          var p = Pair(t[1], t[0]);

          expect(fst(p)).to.equal(t[1]);
        });
      });
    });


    var sndSpec = {
      name: 'snd',
      restrictions: [[Pair]],
      validArguments: [[new Pair(1, 2)]]
    };


    checkFunction(sndSpec, snd, function(snd) {
      tests.forEach(function(t, i) {
        it('Works correctly (' + (2 * i + 1) + ')', function() {
          var p = Pair(t[0], t[1]);

          expect(snd(p)).to.equal(t[1]);
        });


        it('Works correctly (' + (2 * i + 2) + ')', function() {
          var p = Pair(t[1], t[0]);

          expect(snd(p)).to.equal(t[0]);
        });
      });
    });


    describe('isPair', function() {
      var isPair = pair.isPair;


      tests.forEach(function(t, i) {
        it('Returns false if called with non-Pair value (' + (2 * i + 1) + ')', function() {
          expect(isPair(t[0])).to.equal(false);
        });

        it('Returns false if called with non-Pair value (' + (2 * i + 2) + ')', function() {
          expect(isPair(t[1])).to.equal(false);
        });

        it('Works correctly (' + (i + 1) + ')', function() {
          expect(isPair(Pair(t[0], t[1]))).to.equal(true);
        });
      });
    });


    describe('toString', function() {
      it('toString defined by prototype (1)', function() {
        var p = new Pair(1, 2);

        expect(p.hasOwnProperty('toString')).to.equal(false);
      });


      it('toString defined by prototype (2)', function() {
        var proto = Object.getPrototypeOf(Pair);

        expect(proto.hasOwnProperty('toString')).to.equal(true);
      });


      it('Has correct arity', function() {
        var proto = Object.getPrototypeOf(Pair);

        expect(arityOf(proto.toString)).to.equal(0);
      });


      tests.forEach(function(t, i) {
        it('Works correctly (' + (2 * i + 1) + ')', function() {
          var p = Pair(t[0], t[1]);
          var s = p.toString();

          expect(s).to.equal(['Pair (', valueStringifier(t[0]), ', ', valueStringifier(t[1]) + ')'].join(''));
        });


        it('Works correctly (' + (2 * i + 2) + ')', function() {
          var p = Pair(t[1], t[0]);
          var s = p.toString();

          expect(s).to.equal(['Pair (', valueStringifier(t[1]), ', ', valueStringifier(t[0]) + ')'].join(''));
        });
      });
    });


    var asArraySpec = {
      name: 'asArray',
      arity: 1,
      restrictions: [[Pair]],
      validArguments: [[new Pair(2, 3)]]
    };


    checkFunction(asArraySpec, pair.asArray, function(asArray) {
      tests.forEach(function(t, i) {
        it('Works correctly (' + (2 * i + 1) + ')', function() {
          var arr = asArray(Pair(t[0], t[1]));

          expect(Array.isArray(arr)).to.equal(true);
          expect(arr.length).to.equal(2);
          expect(arr[0]).to.equal(t[0]);
          expect(arr[1]).to.equal(t[1]);
        });


        it('Works correctly (' + (2 * i + 2) + ')', function() {
          var arr = asArray(Pair(t[1], t[0]));

          expect(Array.isArray(arr)).to.equal(true);
          expect(arr.length).to.equal(2);
          expect(arr[0]).to.equal(t[1]);
          expect(arr[1]).to.equal(t[0]);
        });
      });
    });
  });
})();

},{"../../lib/components/curry":13,"../../lib/components/pair":20,"../../lib/internalUtilities":27,"./testingUtilities":63,"chai":64}],60:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var result = require('../../lib/components/result');

  var curryModule = require('../../lib/components/curry');
  var arityOf = curryModule.arityOf;
  var objectCurry = curryModule.objectCurry;

  var base = require('../../lib/components/base');
  var id = base.id;
  var constant = base.constant;

  var internalUtilities = require('../../lib/internalUtilities');
  var valueStringifier = internalUtilities.valueStringifier;

  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;
  var addCurryStyleTests = testUtils.addCurryStyleTests;


  describe('Result', function() {
    var expectedObjects = ['Result'];
    var expectedFunctions = ['Ok', 'Err', 'getOkValue', 'getErrValue', 'isResult', 'isOk', 'isErr',
                             'makeResultReturner', 'either'];
    checkModule('result', result, expectedObjects, expectedFunctions);


    var Result = result.Result;
    var Ok = result.Ok;
    var Err = result.Err;
    var getOkValue = result.getOkValue;
    var getErrValue = result.getErrValue;
    var isOk = result.isOk;
    var isErr = result.isErr;


    describe('Result', function() {
      it('Is a function', function() {
        expect(Result).to.be.a('function');
      });


      it('Cannot be called directly (1)', function() {
        var fn = function() {
          var m = new Result();
        };

        expect(fn).to.throw(Error);
      });


      it('Cannot be called directly (2)', function() {
        var fn = function() {
          var r = Result();
        };

        expect(fn).to.throw(Error);
      });


      it('toString works correctly', function() {
        var s = Result.prototype.toString();

        expect(s).to.equal('Result');
      });
    });


    // Values to generate various tests
    var tests = [1, true, 'a', [], {}, function() {}, undefined, null];


    var makeConstructorTests = function(desc, ConstructorFunction, verifier, toStringText) {
      describe(desc, function() {
        it('Throws when called with no arguments (1)', function() {
          var fn = function() {
            new ConstructorFunction();
          };

          expect(fn).to.throw(TypeError);
        });


        it('Throws when called with no arguments (2)', function() {
          var fn = function() {
            ConstructorFunction();
          };

          expect(fn).to.throw(TypeError);
        });


        var makeTest = function(message, testMaker) {
          var withNew = function() {
            return new ConstructorFunction(1);
          };


          var withoutNew = function() {
            return ConstructorFunction(1);
          };


          it(message + ' (when called with new operator)', testMaker(withNew));
          it(message + ' (when called without new operator)', testMaker(withoutNew));
        };


        makeTest('Returns an object', function(resultMaker) {
          return function() {
            var o = resultMaker();

            expect(o).to.be.an('object');
          };
        });


        makeTest('instanceof correct', function(resultMaker) {
          return function() {
            var o = ConstructorFunction(1);

            expect(o).to.be.an.instanceOf(ConstructorFunction);
          };
        });


        makeTest('constructor correct', function(resultMaker) {
          return function() {
            var o = ConstructorFunction(1);

            expect(o.constructor).to.equal(Result);
          };
        });


        makeTest('Returned object is also a Result', function(resultMaker) {
          return function() {
            var o = resultMaker();

            expect(o).to.be.an.instanceOf(Result);
          };
        });


        makeTest('Has \'value\' property', function(resultMaker) {
          return function() {
            var o = resultMaker();
            var props = Object.getOwnPropertyNames(o);
            var result = props.indexOf('value') !== -1;

            expect(result).to.equal(true);
          };
        });


        makeTest('\'value\' property is not enumerable', function(resultMaker) {
          return function() {
            var o = resultMaker();
            var value = false;
            for (var prop in o)
              if (prop === 'value') value = true;
            var result = !value;

            expect(result).to.equal(true);
          };
        });


        makeTest('\'value\' is immutable', function(resultMaker) {
          return function() {
            var o = resultMaker();
            var fn = function() {
              o.value = 2;
            };

            expect(fn).to.throw(TypeError);
          };
        });


        makeTest('Returned object correct', function(resultMaker) {
          return function() {
            var o = resultMaker();

            expect(verifier(o)).to.equal(1);
          };
        });


        tests.forEach(function(t, i) {
          it('toString works correctly (' + (i + 1) + ')', function() {
            var o = new ConstructorFunction(t);
            var s = o.toString();

            expect(s).to.equal('Result {' + toStringText + ' ' + valueStringifier(t) + '}');
          });
        });
      });
    };


    makeConstructorTests('Ok', Ok, getOkValue, 'Ok');
    makeConstructorTests('Err', Err, getErrValue, 'Err');


    var makeCommonExtractorTests = function(desc, fnUnderTest, Correct, correctName, opposite, oppositeName) {
      var spec = {
        name: desc,
        restrictions: [[Result]],
        validArguments: [[Correct(1)]]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        it('Throws if called with Result', function() {
          var fn = function() {
            fnUnderTest(Result);
          };

          expect(fn).to.throw(TypeError);
        });


        it('Throws if called with ' + oppositeName, function() {
          var fn = function() {
            fnUnderTest(opposite(1));
          };

          expect(fn).to.throw(TypeError);
        });


        tests.forEach(function(t, i) {
          it('Works correctly (' + (i + 1) + ')', function() {
            var j = new Correct(t);

            expect(fnUnderTest(j)).to.equal(t);
          });


          it('Works correctly (' + (i + 2) + ')', function() {
            var j = Correct(t);

            expect(fnUnderTest(j)).to.equal(t);
          });
        });
      });
    };


    makeCommonExtractorTests('getOkValue', getOkValue, Ok, 'Ok', Err, 'Err');
    makeCommonExtractorTests('getErrValue', getErrValue, Err, 'Err', Ok, 'Ok');


    describe('isResult', function() {
      var isResult = result.isResult;


      it('Correct for Result', function() {
        expect(isResult(Result)).to.equal(true);
      });


      tests.forEach(function(t, i) {
        it('Returns false if called with non-Result value (' + (i + 1) + ')', function() {
          expect(isResult(t)).to.equal(false);
        });


        it('Works correctly for Ok (' + (i + 1) + ')', function() {
          expect(isResult(Ok(t))).to.equal(true);
        });


        it('Works correctly for Err (' + (i + 1) + ')', function() {
          expect(isResult(Err(t))).to.equal(true);
        });
      });
    });


    var makeIsTests = function(desc, fnUnderTest, constructorFn, name, opposite, oppositeName) {
      describe(desc, function() {
        it('Correct for Result', function() {
          expect(fnUnderTest(Result)).to.equal(false);
        });


        tests.forEach(function(t, i) {
          it('Returns false if called with non-Result value (' + (i + 1) + ')', function() {
            expect(fnUnderTest(t)).to.equal(false);
          });


          it('Correct for ' + oppositeName + ' (' + (i + 1) + ')', function() {
            expect(fnUnderTest(opposite(t))).to.equal(false);
          });


          it('Correct for ' + name + ' (' + (i + 1) + ')', function() {
            expect(fnUnderTest(constructorFn(t))).to.equal(true);
          });
        });
      });
    };


    makeIsTests('isOk', result.isOk, Ok, 'Ok', Err, 'Err');
    makeIsTests('isErr', result.isErr, Err, 'Err', Ok, 'Ok');


    var addCommonResultMakerTests = function(fnUnderTest, goodArgs) {
      it('Returns a function', function() {
        var result = fnUnderTest.apply(null, goodArgs);

        expect(result).to.be.a('function');
      });


      var addSameArityTest = function(message, f) {
        it('Returned function has same arity ' + message, function() {
          var expected = arityOf(f);
          var newFn = fnUnderTest.apply(null, goodArgs.length > 1 ? [goodArgs[0], f] : [f]);

          expect(arityOf(newFn)).to.equal(arityOf(f));
        });
      };


      addSameArityTest('(1)', function() {});
      addSameArityTest('(2)', function(x, y, z) {});


      var addCallsOriginalTest = function(message, args) {
        it('Returned function calls original function with given args ' + message, function() {
          var called = false;
          var fArgs = null;

          var f = args.length > 1 ? function(x, y) {called = true; fArgs = [x, y]; return 0;} :
                                      function(x) {called = true; fArgs = [x]; return 0;};
          var newFn = fnUnderTest.apply(null, goodArgs.length > 1 ? [goodArgs[0], f] : [f]);
          newFn.apply(null, args);

          expect(called).to.equal(true);
          expect(fArgs).to.deep.equal(args);
        });
      };


      addCallsOriginalTest('(1)', [1, 2]);
      addCallsOriginalTest('(2)', ['a']);


      it('Returned function preserves execution context', function() {
        var f = function() {f.exc = this;};
        f.exc = undefined;
        var newFn = fnUnderTest.apply(null, goodArgs.length > 1 ? [goodArgs[0], f] : [f]);
        var obj = {};
        newFn.apply(obj);

        expect(f.exc).to.equal(obj);
      });
    };


    var resultReturnerSpec = {
      name: 'makeResultReturner',
      restrictions: [['function']],
      validArguments: [[function() {}]]
     };


    checkFunction(resultReturnerSpec, result.makeResultReturner, function(makeResultReturner) {
      it('Returns a function', function() {
        var result = makeResultReturner(function() {});

        expect(result).to.be.a('function');
      });


      var addSameArityTest = function(message, f) {
        it('Returned function has same arity ' + message, function() {
          var expected = arityOf(f);
          var newFn = makeResultReturner(f);

          expect(arityOf(newFn)).to.equal(arityOf(f));
        });
      };


      addSameArityTest('(1)', function() {});
      addSameArityTest('(2)', function(x, y, z) {});


      var addCallsOriginalTest = function(message, args) {
        it('Returned function calls original function with given args ' + message, function() {
          var called = false;
          var calledArgs = null;

          var f = function(x) {called = true; calledArgs = [].slice.call(arguments); return 0;};
          var newFn = makeResultReturner(f);
          newFn.apply(null, args);

          expect(called).to.equal(true);
          expect(calledArgs).to.deep.equal(args);
        });
      };


      addCallsOriginalTest('(1)', [[1, 2]]);
      addCallsOriginalTest('(2)', ['a']);


      it('Returns Ok <value> when function does not throw', function() {
        var f = function(x) {return x + 1;};
        var newFn = makeResultReturner(f);
        var good = [0, 1, 2, 3, 4];
        var result = good.every(function(v) {
          var r = newFn(v);
          return isOk(r) && getOkValue(r) === f(v);
        });

        expect(result).to.equal(true);
      });


      var thingsToThrow = [
        new Error(), new TypeError(), new SyntaxError(), new ReferenceError(),
        1, true, 'a', undefined, null, {}, function() {}, []];


      thingsToThrow.forEach(function(boom, i) {
        it('Doesn\'t throw if underlying function throws', function() {
          var f = function(x) {throw boom;};
          var newFn = makeResultReturner(f);
          var fn = function() {
            newFn(1);
          };

          expect(fn).to.not.throw(boom);
        });


        it('Returns Err <value thrown> when function throws (' + (i + 1) + ')', function() {
          var f = function(x) {throw boom;};
          var newFn = makeResultReturner(f);
          var r = newFn(1);
          var result = isErr(r) && getErrValue(r) === boom;

          expect(result).to.equal(true);
        });
      });


      addCurryStyleTests(function(f) { return makeResultReturner(f); });


      it('Passes execution context to original function', function() {
        var context;
        var f = objectCurry(function(x) { context = this; return 1; });
        var newFn = makeResultReturner(f);
        var obj = {};
        var r = newFn.apply(obj, [1]);

        expect(context).to.equal(obj);
      });
    });


    var eitherSpec = {
      name: 'either',
      arity: 3,
      restrictions: [['function: minarity 1'], ['function: minarity 1'], [Result]],
      validArguments: [[id], [id], [Ok(1)]]
    };


    checkFunction(eitherSpec, result.either, function(either) {
      var notResults = [1, 'a', true, null, undefined, {}, []];

      notResults.forEach(function(test, i) {
        it('Throws if the last argument is not a Result (' + (i + 1) + ')', function() {
          var fn = function() {
            either(id, constant, test);
          };

          expect(fn).to.throw(TypeError);
        });
      });


      var addOKTest = function(message, val) {
        it('Calls first function if value is OK ' + message, function() {
          var ok = Ok(val);
          var called = false;
          var f = function(x) {called = true; return null;};
          called = false;
          either(f, id, ok);

          expect(called).to.equal(true);
        });


        it('Calls first function with wrapped value if OK ' + message, function() {
          var ok = Ok(val);
          var arg = null;
          var f = function(x) {arg = x; return null;};
          arg = null;
          either(f, id, ok);

          expect(arg).to.equal(val);
        });


        var addReturnsFirstTest = function(m, expected) {
          it('Returns result of first function if OK ' + m + ' ' + message, function() {
            var ok = Ok(val);
            var res = expected;
            var f = function(x) {return res;};
            var result = either(f, id, ok);

            expect(result).to.equal(expected);
          });
        };


        addReturnsFirstTest('(1)', 1);
        addReturnsFirstTest('(2)', 'funkier');
      };


      addOKTest('(1)', {foo: 1});
      addOKTest('(2)', 'abc');


      var addErrTest = function(message, val) {
        it('Calls second function if value is Err ' + message, function() {
          var err = Err(val);
          var called = false;
          var f = function(x) {called = true; return null;};
          either(id, f, err);

          expect(called).to.equal(true);
        });


        it('Calls second function with wrapped value if Err ' + message, function() {
          var err = Err(val);
          var arg = null;
          var f = function(x) {arg = x; return null;};
          either(id, f, err);

          expect(arg).to.equal(val);
        });


        var addReturnsSecondTest = function(m, expected) {
          it('Returns result of second function if Err ' + m + ' ' + message, function() {
            var err = Err(val);
            var res = expected;
            var f = function(x) {return res;};
            var result = either(id, f, err);

            expect(result).to.equal(expected);
          });
        };


        addReturnsSecondTest('(1)', 1);
        addReturnsSecondTest('(2)', 'funkier');
      };


      addErrTest('(1)', {foo: 42});
      addErrTest('(2)', 2);
    });
  });
})();

},{"../../lib/components/base":11,"../../lib/components/curry":13,"../../lib/components/result":21,"../../lib/internalUtilities":27,"./testingUtilities":63,"chai":64}],61:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var string = require('../../lib/components/string');

  var types = require('../../lib/components/types');
  var isArray = types.isArray;

  var testingUtilities = require('./testingUtilities');
  var checkModule = testingUtilities.checkModule;
  var checkFunction = testingUtilities.checkFunction;

  describe('string', function() {
    var expectedObjects = [];
    var expectedFunctions = ['chr', 'firstMatch', 'firstMatchFrom', 'matches', 'matchesFrom', 'ord', 'regExpSplit',
                             'regExpSplitMax',  /*'replaceOneString', 'replaceOneStringWith', 'replaceString',
                             'replaceStringWith',*/ 'split', 'splitMax', 'test', 'toCharCode', 'toLocaleLowerCase',
                             'toLocaleString', 'toLocaleUpperCase', 'toLowerCase', 'toString', 'toUpperCase', 'trim'];
    checkModule('string', string, expectedObjects, expectedFunctions);


    var toStringTests = [
      {name: 'number', value: 1000},
      {name: 'string', value: 'a'},
      {name: 'boolean', value: true},
      {name: 'function', value: function() {}},
      {name: 'object', value: {}},
      {name: 'array', value: [1]},
      {name: 'date', value: new Date(2000, 0, 0)}
    ];


    describe('toString', function() {
      var toString = string.toString;


      var makeToStringTest = function(val) {
        return function() {
          expect(toString(val)).to.equal(val.toString());
        };
      };


      toStringTests.forEach(function(test) {
        it('Works correctly for ' + test.name, makeToStringTest(test.value));
      });


      it('Works correctly for object with custom toString', function() {
        var a = {toString: function() {return 'foo';}};

        expect(toString(a)).to.equal(a.toString());
      });
    });


    describe('toLocaleString', function() {
      var toLocaleString = string.toLocaleString;


      var makeToLocaleStringTest = function(val) {
        return function() {
          expect(toLocaleString(val)).to.equal(val.toLocaleString());
        };
      };


      toStringTests.forEach(function(test) {
        it('Works correctly for ' + test.name, makeToLocaleStringTest(test.value));
      });


      it('Works correctly for object with custom toLocaleString', function() {
        var a = {toLocaleString: function() {return 'foo';}};

        expect(toLocaleString(a)).to.equal(a.toLocaleString());
      });
    });


    describe('toCharCode', function() {
      var toCharCode = string.toCharCode;


      it('Works correctly (1)', function() {
        var a = 'abc';
        var l = a.length;

        for (var i = 0; i < l; i++)
          expect(toCharCode(i, a)).to.equal(a.charCodeAt(i));
      });


      it('Works correctly (2)', function() {
        var a = 'abc';

        expect(isNaN(toCharCode(10, a))).to.equal(true);
      });
    });


    describe('ord', function() {
      var ord = string.ord;


      var addWorksTest = function(message, str) {
        it('Works correctly ' + message, function() {
          expect(ord(str)).to.equal(str.charCodeAt(0));
        });
      };


      addWorksTest('(1)', 'a');
      addWorksTest('(2)', 'F');
      addWorksTest('(3)', 'funkier');


      it('Works correctly (4)', function() {
        var a = '';

        expect(isNaN(ord(a))).to.equal(true);
      });
    });


    describe('chr', function() {
      var ord = string.ord;
      var chr = string.chr;


      var addWorksTest = function(message, str) {
        it('Works correctly ' + message, function() {
          var code = ord(str);

          expect(chr(code)).to.equal(str);
        });
      };


      addWorksTest('(1)', 'a');
      addWorksTest('(1)', 'F');


      it('Discards superfluous arguments', function() {
        var a = 'a';
        var aCode = ord(a);
        var bCode = ord('b');
        var cCode = ord('c');

        expect(chr(aCode, bCode, cCode)).to.equal(a);
      });
    });


    var makeStringCaseTest = function(desc, fnUnderTest, verifier) {
      describe(desc, function() {
        var addWorksTest = function(message, str) {
          it('Works correctly ' + message, function() {
            var result = fnUnderTest(str);

            expect(result).to.equal(str[verifier]());
          });
        };


        addWorksTest('(1)', 'abc');
        addWorksTest('(1)', 'ABC');
        addWorksTest('(1)', 'AbC');
      });
    };


    makeStringCaseTest('toLowerCase', string.toLowerCase, 'toLowerCase');
    makeStringCaseTest('toLocaleLowerCase', string.toLocaleLowerCase, 'toLocaleLowerCase');
    makeStringCaseTest('toUpperCase', string.toUpperCase, 'toUpperCase');
    makeStringCaseTest('toLocaleUpperCase', string.toLocaleUpperCase, 'toLocaleUpperCase');


    var splitSpec = {
      name: 'split',
      restrictions: [['string'], ['string']],
      validArguments: [['a'], ['banana']]
    };


    checkFunction(splitSpec, string.split, function(split) {
      var addReturnsArrayTest = function(message, splitStr, str) {
        it('Returns an array ' + message, function() {
          var result = split(splitStr, str);

          expect(isArray(result)).to.equal(true);
        });
      };


      addReturnsArrayTest('(1)', '-', 'a-b-c');
      addReturnsArrayTest('(2)', '*', 'a-b-c');


      it('Splitting string not present in results (1)', function() {
        var s = 'a-b-c';
        var result = split('-', s).every(function(sp) {
          return sp !== '-';
        });

        expect(result).to.equal(true);
      });


      it('Splitting string not present in results (2)', function() {
        var s = 'a-b-c';
        var result = split('-', s).every(function(sp) {
          return sp.indexOf('-') === -1;
        });

        expect(result).to.equal(true);
      });


      var addWorksCorrectlyTest = function(message, splitStr, str) {
        it('Works correctly ' + message, function() {
          var result = split(splitStr, str);

          expect(result).to.deep.equal(str.split(splitStr));
        });
      };


      addWorksCorrectlyTest('(1)', '-', 'd-e-f-g');
      addWorksCorrectlyTest('(2)', '*', 'd-e-f-g');
      addWorksCorrectlyTest('(3)', '--', 'd--e--f--g');
      addWorksCorrectlyTest('(4)', '', 'defg');
      addWorksCorrectlyTest('(5)', '--', 'd--e--f--g');
    });


    var regExpSplitSpec = {
      name: 'regExpSplit',
      restrictions: [[RegExp], ['string']],
      validArguments: [[/a/], ['banana']]
    };


    checkFunction(regExpSplitSpec, string.regExpSplit, function(regExpSplit) {
      var addReturnsArrayTest = function(message, pattern, str) {
        it('Returns an array ' + message, function() {
          var result = regExpSplit(pattern, str);

          expect(isArray(result)).to.equal(true);
        });
      };


      addReturnsArrayTest('(1)', /-/, 'a-b-c');
      addReturnsArrayTest('(2)', /\*/, 'a-b-c');


      it('Matched pattern not present in results (1)', function() {
        var s = 'a-b-c';
        var result = regExpSplit(/-/, s).every(function(sp) {
          return sp !== '-';
        });

        expect(result).to.equal(true);
      });


      it('Matched pattern not present in results (2)', function() {
        var s = 'a-b-c';
        var result = regExpSplit(/-/, s).every(function(sp) {
          return sp.indexOf('-') === -1;
        });

        expect(result).to.equal(true);
      });


      var addWorksCorrectlyTest = function(message, pattern, str) {
        it('Works correctly ' + message, function() {
          var result = regExpSplit(pattern, str);

          expect(result).to.deep.equal(str.split(pattern));
        });
      };


      addWorksCorrectlyTest('(1)', /-/, 'd-e-f-g');
      addWorksCorrectlyTest('(2)', /\*/, 'd-e-f-g');
      addWorksCorrectlyTest('(3)', /-{1}/, 'd--e--f--g');
    });


    var splitMaxSpec = {
      name: 'splitMax',
      restrictions: [['string'], ['integer'], ['string']],
      validArguments: [['a'], [2], ['banana']]
    };


    checkFunction(splitMaxSpec, string.splitMax, function(splitMax) {
      var addReturnsArrayTest = function(message, splitStr, str) {
        it('Returns an array ' + message, function() {
          var result = splitMax(splitStr, 1, str);

          expect(isArray(result)).to.equal(true);
        });
      };


      addReturnsArrayTest('(1)', '-', 'a-b-c');
      addReturnsArrayTest('(2)', '*', 'a-b-c');


      it('Splitting string not present in results (1)', function() {
        var s = 'a-b-c';
        var result = splitMax('-', 10, s).every(function(sp) {
          return sp !== '-';
        });

        expect(result).to.equal(true);
      });


      it('Splitting string not present in results (2)', function() {
        var s = 'a-b-c';
        var result = splitMax('-', 10, s).every(function(sp) {
          return sp.indexOf('-') === -1;
        });

        expect(result).to.equal(true);
      });


      var addWorksCorrectlyTest = function(message, splitStr, limit, str) {
        it('Works correctly ' + message, function() {
          var result = splitMax(splitStr, limit, str);

          expect(result).to.deep.equal(str.split(splitStr, limit));
        });
      };


      addWorksCorrectlyTest('(1)', '-', 10, 'd-e-f-g');
      addWorksCorrectlyTest('(2)', '-', 1, 'd-e-f-g');
      addWorksCorrectlyTest('(3)', '*', 2, 'd-e-f-g');
      addWorksCorrectlyTest('(4)', '--', 4, 'd--e--f--g');
      addWorksCorrectlyTest('(5)', '', 2, 'defg');
    });


    var regExpSplitMaxSpec = {
      name: 'regExpSplitMax',
      restrictions: [[RegExp], ['integer'], ['string']],
      validArguments: [[/a/], [10], ['banana']]
    };


    checkFunction(regExpSplitMaxSpec, string.regExpSplitMax, function(regExpSplitMax) {
      var addReturnsArrayTest = function(message, pattern, str) {
        it('Returns an array ' + message, function() {
          var result = regExpSplitMax(pattern, 10, str);

          expect(isArray(result)).to.equal(true);
        });
      };


      addReturnsArrayTest('(1)', /-/, 'a-b-c');
      addReturnsArrayTest('(2)', /\*/, 'a-b-c');


      it('Matched pattern not present in results (1)', function() {
        var s = 'a-b-c';
        var result = regExpSplitMax(/-/, 10, s).every(function(sp) {
          return sp !== '-';
        });

        expect(result).to.equal(true);
      });


      it('Matched pattern not present in results (2)', function() {
        var s = 'a-b-c';
        var result = regExpSplitMax(/-/, 10, s).every(function(sp) {
          return sp.indexOf('-') === -1;
        });

        expect(result).to.equal(true);
      });


      var addWorksCorrectlyTest = function(message, pattern, limit, str) {
        it('Works correctly ' + message, function() {
          var result = regExpSplitMax(pattern, limit, str);

          expect(result).to.deep.equal(str.split(pattern, limit));
        });
      };


      addWorksCorrectlyTest('(1)', /-/, 10, 'd-e-f-g');
      addWorksCorrectlyTest('(2)', /-/, 2, 'd-e-f-g');
      addWorksCorrectlyTest('(3)', /\*/, 4, 'd-e-f-g');
      addWorksCorrectlyTest('(4)', /-{1}/, 3, 'd--e--f--g');
    });


    /*
     * The search and modification tests are not yet ready for implementation: the API needs to be finalized

    var makeReplaceTest = function(desc, fnUnderTest, fn, once) {
      var spec = {
        name: desc,
        arity: 3
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        var invalids = [
          {name: 'number', value: 42},
          {name: 'boolean', value: false},
          {name: 'null', value: null},
          {name: 'undefined', value: undefined},
          {name: 'object', value: {}},
          {name: 'array', value: []}
        ];


        var nonRegExpes = invalids.concat([
          {name: 'string', value: 'abc'},
          {name: 'function', value: function() {}}
        ]);

        nonRegExpes.forEach(function(test) {
          it('Throws if from is a ' + test.name, function() {
            var s = 'funkier';
            var to = fn ? function(s) {return 'h';} : 'h';
            var f = function() {
              fnUnderTest(test.value, to, s);
            };

            expect(f).to.throw(TypeError);
          });
        });


        if (!fn) {
          var nonStrings = invalids.concat([
            {name: 'function', value: function() {return 'abc';}}
          ]);

          nonStrings.forEach(function(test) {
            it('Throws if replacement is a ' + test.name, function() {
              var s = 'funkier';
              var from = /u/;
              var f = function() {
                fnUnderTest(from, test.value, s);
              };

              expect(f).to.throw(TypeError);
            });
          });


          // If argument 2 isn't a function, then it's a string. Test the various
          //  special characters.

          it('Respects meaning of $1 in replacement', function() {
            var s = 'bana';
            var from = /(na)/;
            var to = '$1$1';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('banana');
          });


          it('Respects meaning of $& in replacement', function() {
            var s = 'ba';
            var from = /ba/;
            var to = 'ab$&';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('abba');
          });


          it('Respects meaning of $` in replacement', function() {
            var s = 'can-';
            var from = /-/;
            var to = '-$`';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('can-can');
          });


          it('Respects meaning of $\' in replacement', function() {
            var s = 'bana';
            var from = /ba/;
            var to = 'ba$\'';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('banana');
          });


          it('Respects meaning of $$ in replacement', function() {
            var s = 'let\'s make some dollar';
            var from = /dollar/;
            var to = '$$';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('let\'s make some $');
          });
        } else {
          var nonFunctions = invalids.concat([
            {name: 'string', value: 'abc'}
          ]);

          nonFunctions.forEach(function(test) {
            it('Throws if replacement is a ' + test.name, function() {
              var s = 'funkier';
              var from = /u/;
              var f = function() {
                fnUnderTest(from, test.value, s);
              };

              expect(f).to.throw(TypeError);
            });
          });


          it('Calls replacement function with matched groups', function() {
            var s = 'a111b222c';
            var from = /(\d+)b(\d+)/;
            var to = function(s, a, b) {to.arg1 = a; to.arg2 = b; return '';};
            to.arg1 = null;
            to.arg2 = null;
            var result = fnUnderTest(from, to, s);

            expect(to.arg1).to.equal('111');
            expect(to.arg2).to.equal('222');
          });


          it('Calls replacement function with matched substring', function() {
            var s = 'funkier';
            var from = /f/;
            var to = function(s) {to.s = s; return 'g';};
            to.s = null;
            var result = fnUnderTest(from, to, s);

            expect(to.s).to.equal('f');
          });
        }


        it('Returns original string when no matches found', function() {
          var s = 'funkier';
          var from = /g/;
          var to = fn ? function(s) {return 'h';} : 'h';
          var result = fnUnderTest(from, to, s);

          expect(result).to.equal(s);
        });


        it('Works correctly', function() {
          var s = 'funkier';
          var from = /f/;
          var to = fn ? function(s) {return 'g';} : 'g';
          var result = fnUnderTest(from, to, s);

          expect(result).to.equal('gunkier');
        });


        it('Replaces leftmost', function() {
          var s = 'bannna';
          var from = /nn/;
          var to = fn ? function(s) {return 'na';} : 'na';
          var result = fnUnderTest(from, to, s);

          expect(result).to.equal('banana');
        });


        it('Deletes if replacement is empty', function() {
          var s = 'funkier';
          var from = /u/;
          var to = fn ? function(s) {return '';} : '';
          var result = fnUnderTest(from, to, s);

          expect(result).to.equal('fnkier');
        });


        if (once) {
          it('Replaces exactly one instance when found', function() {
            var s = 'banana';
            var from = /a/;
            var to = fn ? function(s) {return 'i';} : 'i';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('binana');
          });


          it('Ignores global flag on regexp', function() {
            var s = 'banana';
            var from = /a/g;
            var to = fn ? function(s) {return 'i';} : 'i';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('binana');
          });
        } else {
          it('Replaces all instances found', function() {
            var s = 'banana';
            var from = /a/g;
            var to = fn ? function(s) {return 'i';} : 'i';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('binini');
          });


          it('Works correctly when replacement text matches', function() {
            var s = 'banana';
            var from = /a/g;
            var to = fn ? function(s) {return 'ai';} : 'ai';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('bainainai');
          });


          it('Works irrespective of regexp global flag', function() {
            var s = 'banana';
            var from = /a/;
            var to = fn ? function(s) {return 'i';} : 'i';
            var result = fnUnderTest(from, to, s);

            expect(result).to.equal('binini');
          });
        }
      });
    };

    makeReplaceTest('replaceOneString', string.replaceOneString, false, true);
    makeReplaceTest('replaceString', string.replaceString, false, false);
    makeReplaceTest('replaceOneStringWith', string.replaceOneStringWith, true, true);
    makeReplaceTest('replaceStringWith', string.replaceStringWith, true, false);
    */


    var testSpec = {
      name: 'test',
      restrictions: [[RegExp], []],
      validArguments: [[/a/], ['a']]
    };


    checkFunction(testSpec, string.test, function(test) {
      var invalids = [
        {name: 'number', value: 42},
        {name: 'boolean', value: false},
        {name: 'null', value: null},
        {name: 'undefined', value: undefined},
        {name: 'object', value: {}},
        {name: 'array', value: []},
        {name: 'function', value: function() {}}
      ];


      var nonRegExpes = invalids.concat([
        {name: 'string', value: 'abc'},
      ]);

      nonRegExpes.forEach(function(test) {
        it('Throws when first parameter is a ' + test.name, function() {
          var fn = function() {
            test(test.value, 'foo');
          };

          expect(fn).to.throw(TypeError);
        });
      });


      invalids.forEach(function(test) {
        it('Throws when second parameter is a ' + test.name, function() {
          var fn = function() {
            test(/a/, test.value);
          };

          expect(fn).to.throw(TypeError);
        });
      });


      var addReturnsBooleanTest = function(message, str) {
        it('Returns a boolean (1)', function() {
          var result = test(/a/, str);

          expect(result).to.be.a('boolean');
        });
      };


      addReturnsBooleanTest('(1)', 'b');
      addReturnsBooleanTest('(2)', 'a');


      var addWorksTest = function(message, str, expected) {
        it('Works correctly (1)', function() {
          var result = test(/a/, str);

          expect(result).to.equal(expected);
        });
      };


      addReturnsBooleanTest('(1)', 'b', false);
      addReturnsBooleanTest('(2)', 'a', true);
    });


    // Helper for the various match tests
    var resultIsCorrectShape = function(result) {
      // The match functions don't return a constructed object,
      // just a bare object with certain properties attached.

      var keys = Object.keys(result);
      var expectedKeys = ['index', 'matchedText', 'subexpressions'];

      if (keys.length !== expectedKeys.length)
        return false;

      return keys.every(function(k) {
        return expectedKeys.indexOf(k) !== -1;
      });
    };


    var makeMultiMatcherTests = function(desc, fnUnderTest, isFrom) {
      var spec = {
        name: desc,
        restrictions: isFrom ? [[RegExp], [], []] : [[RegExp], []],
        validArguments: isFrom ? [[/a/], [1], ['abc']] : [[/a/], ['abc']]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        it('Returns an empty array when there are no results', function() {
          var args = isFrom ? [/a/, 0, 'b'] : [/a/, 'b'];
          var result = fnUnderTest.apply(null, args);

          expect(result).to.be.an('array');
          expect(result.length).to.equal(0);
        });


        it('Returns an array of correct length (1)', function() {
          var s = 'a cat hat mat';
          // Our search string has 4 results: the from function should pick up 2 of them
          // based on the start position
          var expectedResults = isFrom ? 2 : 4;
          var r = /a/g;
          var args = isFrom ? [r, 5, s] : [r, s];
          var result = fnUnderTest.apply(null, args);

          expect(result.length).to.equal(expectedResults);
        });


        it('All results have correct form (1)', function() {
          var s = 'a cat hat mat';
          var r = /a/g;
          var args = isFrom ? [r, 5, s] : [r, s];
          var result = fnUnderTest.apply(null, args).every(resultIsCorrectShape);

          expect(result).to.equal(true);
        });


        it('All results have correct matched text (1)', function() {
          var s = 'a cat hat mat';
          var r = /a/g;
          var args = isFrom ? [r, 5, s] : [r, s];
          var result = fnUnderTest.apply(null, args).every(function(obj) {
            return obj.matchedText === 'a';
          });

          expect(result).to.equal(true);
        });


        it('All results have correct index (1)', function() {
          var s = 'a cat hat mat';
          var r = /a/g;
          var indices = [0, 3, 7, 11];
          var args = isFrom ? [r, 5, s] : [r, s];
          var result = fnUnderTest.apply(null, args).every(function(obj, i) {
            return obj.index === (isFrom ? indices[i + 2]  - 5 : indices[i]);
          });

          expect(result).to.equal(true);
        });


        it('All results have correct subexpressions (1)', function() {
          // This search has no subexpressions: the result should be an empty array
          var s = 'a cat hat mat';
          var r = /a/g;
          var args = isFrom ? [r, 5, s] : [r, s];
          var result = fnUnderTest.apply(null, args).every(function(res) {
            return Array.isArray(res.subexpressions) &&
                   res.subexpressions.length === 0;
          });

          expect(result).to.equal(true);
        });


        it('Returns an array of correct length (2)', function() {
          var s = 'a012 bca123 defa234 gha345';
          // Our search string has 4 results: the from function should pick up 2 of them
          // based on the start position
          var expectedResults = isFrom ? 2 : 4;
          var r = /a(\d)(\d)(\d)/g;
          var args = isFrom ? [r, 8, s] : [r, s];
          var result = fnUnderTest.apply(null, args);

          expect(result.length).to.equal(expectedResults);
        });


        it('All results have correct form (2)', function() {
          var s = 'a012 bca123 defa234 gha345';
          var r = /a(\d)(\d)(\d)/g;
          var args = isFrom ? [r, 8, s] : [r, s];
          var result = fnUnderTest.apply(null, args).every(resultIsCorrectShape);

          expect(result).to.equal(true);
        });


        it('All results have correct matched text (2)', function() {
          var s = 'a012 bca123 defa234 gha345';
          var r = /a(\d)(\d)(\d)/g;
          var args = isFrom ? [r, 8, s] : [r, s];
          var isDigit = function(c) {
            return c.length === 1 && c >= '0' && c <= '9';
          };
          var result = fnUnderTest.apply(null, args).every(function(obj) {
            return obj.matchedText.length === 4 &&
                   obj.matchedText[0] === 'a' && isDigit(obj.matchedText[1]) &&
                   isDigit(obj.matchedText[1]) && isDigit(obj.matchedText[2]);
          });

          expect(result).to.equal(true);
        });


        it('All results have correct index (2)', function() {
          var s = 'a012 bca123 defa234 gha345';
          var r = /a(\d)(\d)(\d)/g;
          var args = isFrom ? [r, 8, s] : [r, s];
          var indices = [0, 7, 15, 22];
          var result = fnUnderTest.apply(null, args).every(function(obj, i) {
            return obj.index === (isFrom ? indices[i + 2] - 8 : indices[i]);
          });

          expect(result).to.equal(true);
        });


        it('All results have correct subexpressions (2)', function() {
          var s = 'a012 bca123 defa234 gha345';
          var r = /a(\d)(\d)(\d)/g;
          var args = isFrom ? [r, 8, s] : [r, s];
          var result = fnUnderTest.apply(null, args).every(function(res, i) {
            var subs = res.subexpressions;
            var sub0 = '' + (isFrom ? i + 2 : i);
            var sub1 = '' + (isFrom ? i + 3 : i + 1);
            var sub2 = '' + (isFrom ? i + 4 : i + 2);
            return Array.isArray(subs) && subs.length === 3 && subs[0] === sub0 &&
                   subs[1] === sub1 && subs[2] === sub2;
          });

          expect(result).to.equal(true);
        });


        it('Works correctly when RegExp has no global flag', function () {
          var s = 'banana';
          var r = /n/;
          var args = isFrom ? [r, 0, s] : [r, s];
          var result = fnUnderTest.apply(null, args);

          expect(result.length).to.equal(2);
        });
      });
    };


    var makeSingleMatcherTests = function(desc, fnUnderTest, isFrom, multiEquivalent) {
      var spec = {
        name: desc,
        arity: isFrom ? 3 : 2,
        restrictions: isFrom ? [[RegExp], [], []] : [[RegExp], []],
        validArguments: isFrom ? [[/a/], [1], ['abc']] : [[/a/], ['abc']]
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        it('Returns null when there are no results', function() {
          var args = isFrom ? [/a/, 0, 'b'] : [/a/, 'b'];
          var result = fnUnderTest.apply(null, args);

          expect(result).to.equal(null);
        });


        it('Works correctly (1)', function() {
          var s = 'a cat hat mat';
          var r = /a/g;
          var args = isFrom ? [r, 5, s] : [r, s];
          var result = fnUnderTest.apply(null, args);

          expect(result).to.deep.equal(multiEquivalent.apply(null, args)[0]);
        });


        it('Works correctly (2)', function() {
          var s = 'a012 bca123 defa234 gha345';
          var r = /a(\d)(\d)(\d)/g;
          var args = isFrom ? [r, 8, s] : [r, s];
          var result = fnUnderTest.apply(null, args);

          expect(result).to.deep.equal(multiEquivalent.apply(null, args)[0]);
        });


        it('Works correctly when RegExp has global flag', function () {
          var s = 'banana';
          var r = /n/g;
          var args = isFrom ? [r, 0, s] : [r, s];
          var result = fnUnderTest.apply(null, args);

          expect(result).to.not.equal(null);
          expect(result.index).to.equal(2);
        });
      });
    };


    makeMultiMatcherTests('matches', string.matches, false);
    makeMultiMatcherTests('matchesFrom', string.matchesFrom, true);
    makeSingleMatcherTests('firstMatch', string.firstMatch, false, string.matches);
    makeSingleMatcherTests('firstMatchFrom', string.firstMatchFrom, true, string.matchesFrom);


    describe('trim', function() {
      var trim = string.trim;


      var addWorksCorrectlyTest = function(message, str) {
        it('Works correctly ' + message, function() {
          var result = trim(str);

          expect(result).to.equal(str.trim());
        });
      };


      addWorksCorrectlyTest('(1)', 'abc');
      addWorksCorrectlyTest('(2)', '  abc');
      addWorksCorrectlyTest('(3)', 'abc  ');
      addWorksCorrectlyTest('(4)', '  abc  ');
    });
  });
})();

},{"../../lib/components/string":22,"../../lib/components/types":23,"./testingUtilities":63,"chai":64}],62:[function(require,module,exports){
(function() {
  "use strict";


  var expect = require('chai').expect;

  var types = require('../../lib/components/types');

  var testUtils = require('./testingUtilities');
  var checkModule = testUtils.checkModule;
  var checkFunction = testUtils.checkFunction;
  var NO_RESTRICTIONS = testUtils.NO_RESTRICTIONS;
  var ANYVALUE = testUtils.ANYVALUE;


  describe('Types', function() {
    var expectedObjects = [];
    var expectedFunctions = ['deepEqual', 'equals', 'getType', 'is', 'isArray', 'isBoolean', 'isNull', 'isNumber',
                             'isObject', 'isRealObject', 'isString', 'isUndefined', 'notEqual', 'strictEquals',
                             'strictNotEqual'];


    checkModule('types', types, expectedObjects, expectedFunctions);


    // The following array is used for generating tests for both equality and strictEquality
    // They are not an exhaustive check of all possible type coercions.
    var equalityTests = [
      {value: 1, coercible: ['1', true, {valueOf: function() {return 1;}}],
                 notEqual: [0, NaN, false, undefined, null, function() {}, '2', {valueOf: function() {return 2;}}]},
      {value: '1', coercible: [true, {toString: function() {return '1';}}],
                 notEqual: [0, NaN, '0', undefined, null, function() {}, 'false', {toString: function() {return '0';}}]},
      {value: false, coercible: [0, '0', {valueOf: function() {return 0;}}],
                 notEqual: [NaN, true, undefined, null, function() {}, 'false', {valueOf: function() {return 1;}}]},
      {value: undefined, coercible: [null],
                 notEqual: [NaN, 'undefined', true, function() {}, 'false', {valueOf: function() {return 1;}}]},
      {value: null, coercible: [], // we've already tried permissible coercions in earlier tests
                 notEqual: [NaN, true, function() {}, 'false', {valueOf: function() {return 1;}}]},
      {value: {}, coercible: [], // we've already tried permissible coercions in earlier tests
                 notEqual: [NaN, true, function() {}, 'false', {}]}];


      var makeAnEqualityTest = function(equalityFn, expectedResult, val1, val2) {
        return function() {
          expect(equalityFn(val1, val2)).to.equal(expectedResult);
        };
      };


     var makeEqualsTests = function(name, fnUnderTest, isStrict, isNot) {
        var spec = {
          name: name,
        };


        checkFunction(spec, fnUnderTest, function(fnUnderTest) {
          equalityTests.forEach(function(test) {
            var val = test.value;
            var type = val !== null ? typeof(val) : 'null';

            it('Correct for value of type ' + type + ' when testing value with itself',
               makeAnEqualityTest(fnUnderTest, !isNot, val, val));

            var coercible = test.coercible;
            coercible.forEach(function(cVal) {
            var cType = cVal !== null ? typeof(cVal) : 'null';
            it('Correct for value of type ' + type + ' when testing value with coercible value of type ' + cType,
               makeAnEqualityTest(fnUnderTest, !(isStrict ^ isNot), val, cVal));
          });

          var notEqual = test.notEqual;
          notEqual.forEach(function(nVal) {
            var nType = nVal !== null ? typeof(nVal) : 'null';
            it('Correct for value of type ' + type + ' when testing value with unequal value of type ' + nType,
               makeAnEqualityTest(fnUnderTest, isNot, val, nVal));
          });
        });
      });
    };


    makeEqualsTests('equals', types.equals, false, false);
    makeEqualsTests('strictEquals', types.strictEquals, true, false);
    makeEqualsTests('notEqual', types.notEqual, false, true);
    makeEqualsTests('strictNotEqual', types.strictNotEqual, true, true);


    var deepEqualSpec = {
      name: 'deepEqual',
    };


    checkFunction(deepEqualSpec, types.deepEqual, function(deepEqual) {
      var addWorksCorrectlyTest = function(message, a, b, expected) {
        it('Works correctly for ' + message, function() {
          expect(deepEqual(a, b)).to.equal(expected);
        });
      };


      var deTests = [
        {name: 'number', value: 1},
        {name: 'string', value: 'a'},
        {name: 'boolean', value: true},
        {name: 'undefined', value: undefined},
        {name: 'function', value: function() {}},
        {name: 'null', value: null},
        {name: 'array', value: []},
        {name: 'object', value: {}}];


      deTests.forEach(function(deTest, i) {
        var name = deTest.name;
        var value = deTest.value;

        deTests.forEach(function(deTest2, j) {
          var name2 = deTest2.name;
          var value2 = deTest2.value;

          var expected = (i === j);
          addWorksCorrectlyTest('values of type ' + name + ' and ' + name2, value, value2, expected);
        });
      });


      it('Works correctly for objects with non-identical prototypes (1)', function() {
        var F = function() {this.foo = 1;};
        F.prototype = {};
        var G = function() {this.foo = 1;};
        G.prototype = {};
        var f = new F();
        var g = new G();

        expect(deepEqual(f, g)).to.equal(false);
      });


      addWorksCorrectlyTest('objects with different keys', {foo: 5}, {baz: 1}, false);
      addWorksCorrectlyTest('objects with different property values', {foo: 5}, {foo: 1}, false);
      addWorksCorrectlyTest('objects with properties that are not deep equal (1)', {foo: {bar: 1}},
                                                                                   {foo: {bar: 2}}, false);
      addWorksCorrectlyTest('objects with properties that are not deep equal (2)', {foo: [1, 2, 3]},
                                                                                   {foo: [4, 5]}, false);
      addWorksCorrectlyTest('objects with same keys and values', {foo: 4, bar: 3}, {foo: 4, bar: 3}, true);
      addWorksCorrectlyTest('objects with properties that are deep equal (1)', {foo: {bar: 1}}, {foo: {bar: 1}}, true);
      addWorksCorrectlyTest('objects with properties that are deep equal (2)', {foo: [1, 2, 3]}, {foo: [1, 2, 3]}, true);
      addWorksCorrectlyTest('arrays with different lengths', [1], [], false);
      addWorksCorrectlyTest('arrays with different values', [1, 2], [1, 3], false);
      addWorksCorrectlyTest('arrays that aren\'t deep equal (1)', [1, {foo: 5}], [1, {foo: 6}], false);
      addWorksCorrectlyTest('arrays that aren\'t deep equal (2)', [1, [1]], [1, [2]], false);
      addWorksCorrectlyTest('arrays with same lengths and  values', [1, 2], [1, 2], true);
      addWorksCorrectlyTest('arrays that are deep equal (1)', [1, {foo: 5}], [1, {foo: 5}], true);
      addWorksCorrectlyTest('arrays that are deep equal (2)', [1, [2]], [1, [2]], true);


      it('Works correctly for objects with non-identical prototypes (2)', function() {
        // The object literals here will not be identical
        var f = Object.create({foo: 1});
        var g = Object.create({foo: 1});

        expect(deepEqual(f, g)).to.equal(false);
      });


      it('Works correctly for objects with same prototypes', function() {
        var F = function() {this.foo = 1;};
        F.prototype = {};
        var f = new F();
        var g = new F();

        expect(deepEqual(f, g)).to.equal(true);
      });


      it('Non-enumerable properties do not affect deep equality', function() {
        var f = {buzz: 42};
        var g = {buzz: 42};
        Object.defineProperty(f, 'foo', {enumerable: false, value: 'a'});

        expect(deepEqual(f, g)).to.equal(true);
      });


      it('Works correctly for equal recursive array (1)', function() {
        var a = [1, 2, 3];
        a[3] = a;
        var b = [1, 2, 3];
        b[3] = a;

        expect(deepEqual(a, b)).to.equal(true);
      });


      it('Works correctly for equal recursive array (2)', function() {
        var a = [1, 2, 3];
        a[3] = a;
        var b = [1, 2, 3];
        b[3] = b;

        expect(deepEqual(a, b)).to.equal(true);
      });


      it('Works correctly for equal recursive array (3)', function() {
        var a = [1, 2, 3];
        a[3] = a;
        var b = [1, 2, 3, 4];

        expect(deepEqual(a, b)).to.equal(false);
      });


      it('Works correctly for equal recursive array (4)', function() {
        var a = [1, 2, 3, 4];
        var b = [1, 2, 3];
        a[3] = b;

        expect(deepEqual(a, b)).to.equal(false);
      });


      it('Works correctly for equal recursive array (5)', function() {
        var a = [1, 2, 3];
        a[4] = [4, 5, a];
        var b = [1, 2, 3];
        b[4] = [4, 5, b];

        expect(deepEqual(a, b)).to.equal(true);
      });


      it('Works correctly for equal recursive object (1)', function() {
        var o = {foo: 42};
        var a = {bar: o};
        o.bar = a;

        expect(deepEqual(o, o)).to.equal(true);
      });


      it('Works correctly for equal recursive object (2)', function() {
        var o1 = {foo: 42};
        var a = {bar: o1};
        o1.bar = a;

        var o2 = {foo: 42};
        var b = {bar: o2};
        o2.bar = b;

        expect(deepEqual(o1, o2)).to.equal(true);
      });


      it('Works correctly for equal recursive object (3)', function() {
        var o1 = {foo: 42};
        var a = {bar: o1};
        o1.bar = a;

        var o2 = {foo: 43};
        var b = {bar: o2};
        o2.bar = b;

        expect(deepEqual(o1, o2)).to.equal(false);
      });


      it('Works correctly for equal recursive object (4)', function() {
        var o1 = {foo: 42, bar: {}};
        o1.bar.baz = o1;

        var o2 = {foo: 42, bar: {}};
        o2.bar.baz = o2;

        expect(deepEqual(o1, o2)).to.equal(true);
      });


      it('Works correctly for equal recursive object (5)', function() {
        var o1 = {foo: 42, bar: {}};
        o1.bar.baz = o1;

        var o2 = {foo: 42, bar: {}};
        var other = {foo: 43, bar: {}};
        other.bar.baz = other;
        o2.bar.baz = other;

        expect(deepEqual(o1, o2)).to.equal(false);
      });


      it('Works correctly for array with custom properties (1)', function() {
        var a = [1, 2, 3];
        a.foo = 'bar';
        var b = [1, 2, 3];

        expect(deepEqual(a, b)).to.equal(false);
      });


      it('Works correctly for array with custom properties (2)', function() {
        var a = [1, 2, 3];
        a.foo = 'bar';
        var b = [1, 2, 3];
        b.foo = 'bar';

        expect(deepEqual(a, b)).to.equal(true);
      });
    });


    var isTestData = [
      {name: 'number', primitive: true, types: ['number'], value: 1},
      {name: 'string', primitive: true, types: ['string'], value: 'a'},
      {name: 'undefined', primitive: true, types: ['undefined'], value: undefined},
      {name: 'boolean', primitive: true, types: ['boolean'], value: true},
      {name: 'function', primitive: true, types: ['function'], value: function() {}},
      {name: 'object', primitive: true, types: ['realObject', 'object'], value: {}},
      {name: 'null', primitive: false, types: ['object', 'null'], value: null},
      {name: 'array', primitive: false, types: ['object', 'array'], value: [1]}
    ];


    var isSpec = {
      name: 'is',
      restrictions: [['string'], NO_RESTRICTIONS],
      validArguments: [['number'], ANYVALUE]
    };


    checkFunction(isSpec, types.is, function(is) {
      var primitiveIsTests = isTestData.filter(function(o) {return o.primitive;});


      var addIsCheck = function(name, test2) {
        it('Works correctly for type ' + name + ' and value ' + test2.name, function() {
          var result = is(name, test2.value);
          var expected = test2.types.indexOf(name) !== -1;

          expect(result).to.equal(expected);
        });
      };


      primitiveIsTests.forEach(function(primTest) {
        var name = primTest.name;

        isTestData.forEach(function(test2) {
          addIsCheck(primTest.name, test2);
        });
      });
    });


    var addSpecialisedIsCheck = function(name, fnUnderTest, test, accepts) {
      it('Works correctly for type ' + name, function() {
        var result = fnUnderTest(test.value);
        var expected = test.types.indexOf(accepts) !== -1;

        expect(result).to.equal(expected);
      });
    };


    var addSpecialisedIsTest = function(desc, fnUnderTest, accepts) {
      var spec = {
        name: desc,
      };


      checkFunction(spec, fnUnderTest, function(fnUnderTest) {
        isTestData.forEach(function(test) {
          var name = test.name;
          addSpecialisedIsCheck(name, fnUnderTest, test, accepts);
        });
      });
    };


    addSpecialisedIsTest('isNumber', types.isNumber, 'number');
    addSpecialisedIsTest('isString', types.isString, 'string');
    addSpecialisedIsTest('isBoolean', types.isBoolean, 'boolean');
    addSpecialisedIsTest('isUndefined', types.isUndefined, 'undefined');
    addSpecialisedIsTest('isObject', types.isObject, 'object');
    addSpecialisedIsTest('isArray', types.isArray, 'array');
    addSpecialisedIsTest('isNull', types.isNull, 'null');
    addSpecialisedIsTest('isRealObject', types.isRealObject, 'realObject');


    var getTypeSpec = {
      name: 'getType',
    };


    checkFunction(getTypeSpec, types.getType, function(getType) {
      var typeTests = [
        {name: 'number', val: 1},
        {name: 'boolean', val: true},
        {name: 'string', val: 'a'},
        {name: 'undefined', val: undefined},
        {name: 'null', val: null},
        {name: 'array', val: []},
        {name: 'function', val: function() {}},
        {name: 'object', val: {}}];

      typeTests.forEach(function(tt) {
        var name = tt.name;
        var val = tt.val;

        it('Works correctly for value of type ' + name, function() {
          expect(getType(val)).to.equal(typeof(val));
        });
      });
    });
  });
})();

},{"../../lib/components/types":23,"./testingUtilities":63,"chai":64}],63:[function(require,module,exports){
module.exports = (function() {
  "use strict";


  var expect = require('chai').expect;


  var curryModule = require('../../lib/components/curry');
  var arityOf = curryModule.arityOf;
  var curry = curryModule.curry;
  var curryWithArity = curryModule.curryWithArity;
  var bind = curryModule.bind;
  var bindWithContextAndArity = curryModule.bindWithContextAndArity;
  var objectCurry = curryModule.objectCurry;
  var objectCurryWithArity = curryModule.objectCurryWithArity;


  /*
   * Return a function that tests if an object has the given property
   *
   */

  var exportsProperty = function(obj, prop) {
    return function() {
      expect(obj).to.have.property(prop);
    };
  };


  /*
   * Return a function that tests if an object has the given function
   *
   */

  var exportsFunction = function(obj, prop) {
    return function() {
      expect(obj[prop]).to.be.a('function');
    };
  };


  /*
   * Generate a test suite that ensures a module exports all the expected values and functions
   *
   */

  var checkModule = function(name, moduleUnderTest, moduleDescription) {
    var testDescription = name[0].toUpperCase() + name.slice(1);

    describe(testDescription + ' exports', function() {
      // Generate existence tests for each expected object
      if ('expectedObjects' in moduleDescription) {
        moduleDescription.expectedObjects.forEach(function(o) {
          it(name + '.js exports \'' + o + '\' property', exportsProperty(moduleUnderTest, o));
        });
      }

      // ... and each expected function
      if ('expectedFunctions' in moduleDescription) {
        moduleDescription.expectedFunctions.forEach(function(f) {
          it(name + '.js exports \'' + f + '\' property', exportsProperty(moduleUnderTest, f));
          it('\'' + f + '\' property of ' + name + '.js is a function', exportsFunction(moduleUnderTest, f));
        });
      }
    });
  };


//    var positions = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth'];


  /*
   * A special sentinel value to denote that there are no type restrictions on a particular argument position.
   *
   */

  var NO_RESTRICTIONS = {};
  Object.freeze(NO_RESTRICTIONS);


  /*
   * A special sentinel value to denote that we want the test harness to generate valid arguments for a particular
   * argument position.
   *
   */

  var ANYVALUE = {};
  Object.freeze(ANYVALUE);


  var typeclasses = [/*arraylike', 'integer', */ 'function: arity 1', 'function: minarity 1', 'function: minarity 2',
                     'natural', 'objectLike', 'objectLikeorNull', 'positive', 'strictArrayLike', 'strictNatural'];

  var isTypeClass = function(restriction) {
    if (typeclasses.indexOf(restriction) !== -1)
      return true;

    return false;
  };


  /*
   * Certain typeclasses demand more than one example of their ilk. We call these multiTypeClasses. They are as
   * follows:
   *   objectLike:       values can be arrays, objects, or functions
   *   objectLikeOrNull: values can be arrays, objects, functions, or null
   *   strictArrayLike:  values can be arrays, or array-like objects with length and equivalent numeric parmeters
   *                     but not strings
   *   strictArrayLike:  values can be arrays, or array-like objects with length and equivalent numeric parmeters
   *                     but not strings
   *
   */

  var isMultiTypeClass = function(restriction) {
    return ['objectLike', 'objectLikeOrNull', 'strictArrayLike'].indexOf(restriction) !== -1;
//    return ['arraylike', 'strictarraylike', 'objectLike', 'objectLikeorNull'].indexOf(restriction) !== -1;
  };


  var verifyMultiTypeClassRestriction = function(typeClass, values, failBecause) {
    var expectedTypesForClass = {
      'objectLikeOrNull': ['array', 'object', 'function', 'null'],
      'strictArrayLike': ['array', 'object']
    };

    var typesFound = values.map(function(v) {
      var verifier = restrictionVerifiers[typeClass];
      if (verifier === undefined)
        failBecause('No verifier for typeclass ' + typeClass);

      if (!verifier(v))
        failBecause('type is incorrect found ' + typeof(v) + ' but restriction demands ' + typeClass);

      return Array.isArray(v) ? 'array' : (v === null ? 'null' : typeof(v));
    });

    var typesRequired = expectedTypesForClass[typeClass];
    if (typesRequired === undefined)
      failBecause('Typeclass ' + typeClass + ' is incorrectly defined. Please fix verifyMultiTypeClassRestriction');

    if (typesFound.length !== typesFound.length)
      failBecause('Mismatch in terms of number of examples provided for ' + typeClass + ' typeclass. Expected ' +
                  typesRequired.length + ' but found ' + typesFound.length);

    typesFound.sort();
    typesRequired.sort();
    typesFound.forEach(function(t, i) {
      if (t !== typesRequired[i])
        failBecause('Unexpected type ' + t + ' found');
    });
  };



  var primitiveTypeOf = {
    'function': 'function',
    'function: arity 1': 'function',
    'function: arity 2': 'function',
    'function: minarity 1': 'function',
    'function: minarity 2': 'function',
    'function: maxarity 2': 'function',
    'natural':  'number',
    'objectLike': 'object',
    'objectLikeOrNull': 'object',
    'positive':  'number',
    'strictNatural':  'number',
    'string': 'string'
  };


  var restrictionVerifiers = {
    'function': function(f) { return typeof(f) === 'function'; },
    'function: arity 1': function(f) { return typeof(f) === 'function' && f.length === 1; },
    'function: arity 2': function(f) { return typeof(f) === 'function' && f.length === 2; },
    'function: minarity 1': function(f) { return typeof(f) === 'function' && f.length >= 1; },
    'function: minarity 2': function(f) { return typeof(f) === 'function' && f.length >= 2; },
    'function: maxarity 2': function(f) { return typeof(f) === 'function' && f.length <= 2; },
    'natural': function(n) { return (n - 0) >= 0 && (n - 0) !== Number.POSITIVE_INFINITY; },
    'objectLike': function(o) { return (typeof(o) === 'object' && o !== null) || typeof(o) === 'function' ||
                                        typeof(o) === 'string'; },
    'objectLikeOrNull': function(o) { return typeof(o) === 'object' || typeof(o) === 'function'; },
    'positive': function(n) { return (n - 0) > 0 && (n - 0) !== Number.POSITIVE_INFINITY; },
    'strictArrayLike': function(a) { return typeof(a) !== 'string' &&
                                     (Array.isArray(a) || (('0' in a) && ('length' in a))); },
    'strictNatural': function(n) { return typeof(n) === 'number' && n >= 0 && n !== Number.POSITIVE_INFINITY; },
    'string': function(f) { return typeof(f) === 'string'; },
  };


  // Before checkTypeRestrictions generates the type tests, it is prudent to confirm I wrote  the spec correctly.
  // Specifically, we need to ensure that if that, for example, the "restrictions" field requires parameter 0 to be a
  // number or boolean, then the "validArguments" for that parameter should contain a number and a boolean (at the
  // same indices as their respective restrictions).
  //
  // The task is complicated somewhat by the function typeclasses for functions of specific arity, and the "multi"
  // typeclasses: arraylike etc, which map to more than one type.
  //

  var verifyRestrictions = function(name, restrictions, typicalArguments) {
    // Assumption: caller has checked that restrictions is an array
    restrictions.forEach(function(typeRestrictions, i) {
      var failBecause = function(reason) {
        throw new Error(name + ': Spec error for positional argument ' + (i + 1) + ': ' + reason);
      };

      if (typeRestrictions === NO_RESTRICTIONS) return;

      // typeRestrictions is an array of restrictions for parameter i
      typeRestrictions.forEach(function(expectedType, j) {
        var typicalValue = typicalArguments[i][j];

        // Again, trust that the code will generate correct values for a particular restriction
        if (typicalValue === ANYVALUE) return;

        // If a function accepts a specific type of object e.g. RegExp, then that should be the only possible
        // restriction for that position: for example, we shouldn't have a parameter that can be a RegExp or a boolean.
        if (typeof(expectedType) === 'function') {
          if (typeRestrictions.length > 1)
            failBecause('A constructor must be the only restriction for that parameter!');

          if (!(typicalValue instanceof expectedType))
            failBecause('The example argument is not an instance of the given constructor');

          return;
        }

        // The restriction is not a constructor function: it must be a string
        if (typeof(expectedType) !== 'string')
          failBecause('Restriction ' + (j + 1) + ' isn\'t the name of a type: it\'s a ' + typeof(r));

        // If the restriction is a typeclass, it should be the only one
        if (isTypeClass(expectedType) && typeRestrictions.length > 1)
          failBecause('A typeclass must be the only restriction for that parameter!');

        if (isMultiTypeClass(expectedType))
          return;

        if (typeof(typicalValue) !== primitiveTypeOf[expectedType])
          failBecause('Sample argument ' + (j + 1) + ' has type ' + typeof(typicalValue) +
                      ', restriction demands ' + expectedType);

        if (!isTypeClass(expectedType)) return;
        if (!restrictionVerifiers[expectedType](typicalValue))
            failBecause('Typical value ' + (j + 1) + ' for parameter ' + (i + 1) + ' is not of type ' + expectedType);
      });

      // For a multi typeclass, examples should have been provided for each possible type in the typeclass
      if (isMultiTypeClass(typeRestrictions[0]))
        verifyMultiTypeClassRestriction(typeRestrictions[0], typicalArguments[i], failBecause);
    });

    if (restrictions.every(function(r) { return r === NO_RESTRICTIONS; }))
      throw new Error(name + 'has an unneccesary restrictions property. Please remove it');
  };


  /*
   * Given an array containing either a single constructor function, or one or more strings, generate an array of
   * values that would not satisfy that restriction.
   *
   */

  var makeBogusFor = function(restrictionsForPosition) {
    // Note that the typeclasses indicate what typeclass an instance of the type *could* be a value of after coercsion,
    // not necessarily the typeclass of the value given
    var bogusPrimitives = [
      {type: 'number',    value: 2,             typeclasses: [/*'integer',*/ 'natural', 'positive', 'strictNatural']},
      {type: 'boolean',   value: true,          typeclasses: [/*'integer',*/ 'natural', 'positive']},
      {type: 'string',    value: 'x',
         typeclasses: [/* 'integer', */ 'natural', 'positive', /* 'arraylike',*/ 'objectLike', 'objectLikeorNull']},
      {type: 'undefined', value: undefined,     typeclasses: []},
      {type: 'null',      value: null,          typeclasses: [/*'integer',*/ 'natural', 'objectLikeorNull']},
      {type: 'function',  value: function() {}, typeclasses: ['function: maxarity 2', 'objectLike',  'objectLikeorNull']},
      {type: 'object',    value: {foo: 4},      typeclasses: [/*'integer', */ 'natural', 'positive', 'objectLike','objectLikeorNull']},
      {type: 'array',     value: [4, 5, 6],     typeclasses: [/*'arraylike', */ 'natural', 'objectLike', 'positive', 'strictArrayLike', 'objectLikeorNull']}
    ];

    var naturalCommon = [
      {type: 'negative', value: -1}, {type: 'positive infinity', value: Number.POSITIVE_INFINITY},
      {type: 'negative infinity', value: Number.NEGATIVE_INFINITY}, {type: 'non-integral', value: 1.5},
      {type: 'NaN', value: Number.NaN}, {type: 'string coercing to negative', value: '-1'},
      {type: 'string coercing to non-integral', value: '1.2'},
      {type: 'object coercing to negative', value: {valueOf: function() { return -1; }}},
      {type: 'object coercing to infinity', value: {valueOf: function() { return Number.POSITIVE_INFINITY; }}},
      {type: 'object coercing to negative infinity', value: {valueOf: function() { return Number.NEGATIVE_INFINITY; }}},
      {type: 'object coercing to non-integral', value: {valueOf: function() { return 1.2; }}}];


    var bogusForTypeClass = {
      'function: arity 1':    [{type: 'function with arity 0', value: function() {}},
                               {type: 'function with arity 2', value: function(x, y) {}}],
      'function: arity 2':    [{type: 'function with arity 0', value: function() {}},
                               {type: 'function with arity 1', value: function(x) {}},
                               {type: 'function with arity 3', value: function(x, y, z) {}}],
      'function: minarity 1': [{type: 'function with arity 0', value: function() {}}],
      'function: minarity 2': [{type: 'function with arity 0', value: function() {}},
                               {type: 'function with arity 1', value: function(x) {}}],
      'function: maxarity 2': [{type: 'function with arity 3', value: function(x, y, z) {}},
                               {type: 'function with arity 4', value: function(w, x, y, z) {}}],
      natural: naturalCommon,
      objectLike: [],
      objectLikeOrNull: [],
      positive: naturalCommon.concat([{type: 'zero', value: 0}]),
      strictArrayLike: [],
      strictNatural: naturalCommon.concat([{type: 'object coercing to 0 via null',
                                            value: {valueOf: function() { return null; }}},
                                           {type: 'object coercing to boolean',
                                            value: {valueOf: function() { return true; }}},
                                           {type: 'object coercing to number via string',
                                            value: {valueOf: function() { return '1'; }}}])
    };

    // If the restriction is the constructor of a given type, then all of the above are invalid
    if (restrictionsForPosition.length === 1 && typeof(restrictionsForPosition[0]) === 'function')
      return bogusPrimitives.slice();

    var bogus = bogusPrimitives.filter(function(v) {
      return restrictionsForPosition.indexOf(v.type) === -1 && v.typeclasses.every(function(t) {
        return restrictionsForPosition.indexOf(t) === -1;
      });
    });

    return bogus.concat(restrictionsForPosition.reduce(function(soFar, restriction) {
      if (!isTypeClass(restriction)) return soFar;

      if (bogusForTypeClass[restriction] === undefined)
        throw new Error('No bogus arguments defined for typeclass ' + restriction + ': please fix makeBogusFor');

      return soFar.concat(bogusForTypeClass[restriction]);
    }, []));
  };


  /*
   * Helper functions for building positional arguments that can be supplied to Function.prototype.apply.
   *
   */

  var pickValidForRestriction = function(restriction) {
    var types = {
      'function': function() {},
      'function: minarity 1': function(x) {},
      'function: minarity 2': function(x, y) {},
      'function: maxarity 2': function(x, y) {},
      'natural': 0,
      'number': 0,
      'objectLike': {},
      'objectLikeOrNull': {},
      'positive': 1,
      'strictArrayLike': [],
      'string': ''
    };

    return {type: restriction, value: types[restriction]};
  };


  var buildAnArgumentsArray = function(typicalArguments, restrictions) {
    var buildArgumentsForPosition = function(arr, restrictions) {
      if (restrictions === NO_RESTRICTIONS) {
        if (arr === ANYVALUE) return [[{type: 'number', value: 42}]];
        return arr.map(function(val) { return [{type: typeof(val), value: val}]; });
      }

      if (arr === ANYVALUE) return restrictions.map(function(r) { return [pickValidForRestriction(r)]; });
      return arr.map(function(arg, i) { return [{type: restrictions[i], value: arg}]; });
    };

    // Assumption: typicalArguments and restrictions have the same length
    if (typicalArguments.length === 0) return [];

    var remaining = buildAnArgumentsArray(typicalArguments.slice(1), restrictions.slice(1));

    var firstPositionalArguments = buildArgumentsForPosition(typicalArguments[0], restrictions[0]);
    if (remaining.length > 0) {
      return firstPositionalArguments.reduce(function(soFar, call) {
        soFar = soFar.concat(remaining.map(function(arr) { return call.concat(arr); }));
        return soFar;
      }, []);
    } else {
      return firstPositionalArguments;
    }
  };


  /*
   * We often want to test that functions throw if certain parameters are not of the required type. This function
   * generates such tests. As well as the function's name (for producing test descriptions) and the function under
   * test, the following arrays must be supplied:
   *
   *  - restrictions:      An array of length equal to the function under test's arity. Each element describes the
   *                       types of permissible values for a particular argument position. It can take one of the
   *                       following forms:
   *                         - The sentinel value NO_RESTRICTIONS exported by this module, indicating that this
   *                           parameter may take any value
   *                         - An array of strings representing the valid types for this parameter
   *                         - A single element which is the constructor function of the only valid object type for this
   *                         position.
   *
   *                       For example,
   *                         [['string'], ['object', 'array'], [[RegExp]]
   *                       denotes a function whose first argument must be a string, whose second can be an object or an
   *                       array and whose last parameter must be a RegExp. Note that 'object' means a real object:
   *                       include 'null' or 'array' if those types are acceptable.
   *
   *                       When supplied a constructor function, an instanceof test is made: any value that has a value
   *                       of the correct type somewhere in its prototype chain will pass.
   *                       TODO: Clarify what things like object mean, w.r.t arrays, functions etc
   *
   *  - typicalArguments:  Either the special sentinel value ANYVALUE, or an array of length equal to the arity of the
   *                       function being tested.
   *
   *                       If equal to ANYVALUE, the test generator will pick arguments that match the restrictions.
   *                       However, if the function being tested has certain expectations about the values it will be
   *                       invoked with, then this array should contain such positional arguments.
   *
   *                       Each element of the array corresponds to a particular positional argument. If this positional
   *                       argument has no particular requirements, then ANYVALUE can be specified here.
   *
   *                       Otherwise the element should be a subarray, with length equal to the correspoding subarray in
   *                       the restrictions array. Each element of the subarray should specify a typical value of type
   *                       specified by the restrictions array. Again, ANYVALUE can be used within this array to let
   *                       the test generator pick.
   *
   *                       If the member of restrictions for a particular position is NO_RESTRICTIONS, then the subarray
   *                       can contain any number of typical values, but must contain at least one.
   *
   * Throws at test generation time if the given restrictions and typical arguments don't match.
   *
   */

  var checkTypeRestrictions = function(name, fnUnderTest, restrictions, typicalArguments) {
    // TODO: This has become over-complicated and hard to reason about. Fix
    return;

    /*
    // First, we perform various sanity checks to ensure I have written the spec correctly
    var arity = arityOf(fnUnderTest);

    // We assume checkFunction has ensured that both restrictions and typicalArguments are arrays, and in particular
    // has already converted ANYVALUE to an array of ANYVALUE the same length as restrictions
    if (restrictions.length !== arity)
      throw new Error('Too few restrictions provided to test generation function for ' + name + ': it has arity ' +
                       arity + ' but only ' + restrictions.length + ' restrictions provided.');

    if (typicalArguments.length !== arity)
      throw new Error('Too few valid arguments provided to test generation function for ' + name + ': it has arity ' +
                       arity + ' but only ' + restrictions.length + ' restrictions provided.');

    typicalArguments.forEach(function(g, i) {
      if (g === ANYVALUE) {
        typicalArguments[i] = restrictions[i] !== NO_RESTRICTIONS ?
                                restrictions[i].map(function(_) { return ANYVALUE; }) : [ANYVALUE];
      } else {
        if (g.length === 0)
          throw new Error('No valid arguments supplied for parameter ' + (i + 1) + ' of ' + name);
      }
    });



    // TODO: This has become over-complicated and hard to reason about. Fix
    //verifyRestrictions(name, restrictions, typicalArguments);

    var addOne = function(call) {
      var args = call.map(function(c) { return c.value; });
      var signature = '(' + call.map(function(c) {
        if (c.type === undefined) throw new Error('No type for bogus arg: ' + c.value + ': please fix makeBogusFor!');
        return c.type;
      }).join(', ') + ')';


      it('Throws with type signature ' + signature, function() {
        var fn = function() {
          fnUnderTest.apply(null, args);
        };

        expect(fn).to.throw();
      });
    };

    // Now we've checked that I'm not an idiot, we can generate the tests!
    restrictions.forEach(function(typeRestrictions, i) {
      // Skip if its impossible for an argument at this position to have an invalid type
      if (typeRestrictions === NO_RESTRICTIONS)
        return;

      var left = typicalArguments.slice(0, i);
      var right = typicalArguments.slice(i + 1);
      var argumentsLeft = buildAnArgumentsArray(left, restrictions.slice(0, i));
      var argumentsRight = buildAnArgumentsArray(right, restrictions.slice(i + 1));
      var bogusArguments = makeBogusFor(typeRestrictions);

      var getType = function(t) { return t === null ? null : (Array.isArray(t) ? 'array' : typeof(t)); };

      // Note: we must forEach over bogusArguments first: one or both of the valid argument arrays might
      // be degenerate

      bogusArguments.forEach(function(badArg) {
        if (argumentsLeft.length > 0) {
          argumentsLeft.forEach(function(left) {
            if (argumentsRight.length > 0) {
              argumentsRight.forEach(function(right) {
                addOne(left.concat([badArg]).concat(right));
              });
            } else {
              addOne(left.concat([badArg]));
            }
          });
        } else if (argumentsRight.length > 0) {
          argumentsRight.forEach(function(right) {
            addOne([badArg].concat(right));
          });
        } else {
          addOne([badArg]);
        }
      });
    });

    */
  };


  // Generate a text fixture code containing tests that check the function throws when invoked with various combinations
  // of bad parameters, and then calls remainingTests to add function-specific tests
  var checkFunction = function(spec, fnUnderTest, remainingTests) {
    var name = spec.name;

    describe(name, function() {
      if ('restrictions' in spec) {
        // It would be somewhat pointless to explicitly say there are no restrictions at all, but check for it
        // just in case
        if (spec.restrictions !== NO_RESTRICTIONS) {
          if (!Array.isArray(spec.restrictions) || (spec.validArguments !== undefined &&
                                                    spec.validArguments !== ANYVALUE &&
                                                    !Array.isArray(spec.validArguments)))
            throw new Error('One (or both) of the restrictions and validArguments in ' + name + '\'s spec is malformed');

          if (spec.validArguments === undefined || spec.validArguments === ANYVALUE)
            spec.validArguments = spec.restrictions.map(function(_) { return ANYVALUE; });

          checkTypeRestrictions(name, fnUnderTest, spec.restrictions, spec.validArguments);
        } else {
          if (spec.validArguments !== undefined && spec.validArguments !== ANYVALUE)
            throw new Error(name + 'has an unneccesary validArguments property. Please remove it');
        }
      } else if ('validArguments' in spec) {
        throw new Error(name + 'has an unneccesary validArguments property. Please remove it');
      }

      remainingTests(fnUnderTest);
    });
  };


  /*
   * Helper function for testing function manipulating other functions. This adds tests that the results are curried
   * in the same "style" as the manipulated function. We make the following assumptions:
   *
   *  - The function being manipulated must have an arity of at least 1
   *  - The caller can supply a function which will take the function to be manipulated and return the result
   *
   * Optionally takes an options object containing the following properties:
   *   - arity:   the arity of the function to supply to the manipulator
   *   - returns: the value to return from the function supplied to the manipulator
   *
   * Note that this function does not provide tests showing that the result of the function manipulator passes on its
   * execution context to any object-curried inputs. The client must define these manually.
   *
   */

  var addCurryStyleTests = function(manipulator, options) {
    options = options || {};
    var arity = options.arity || 1;

    it('When original function is object curried, result is considered object curried for currying purposes',
          function() {
      var f = objectCurryWithArity(arity, function(x) { return options.returns; });
      var manipulated = manipulator(f);
      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        objectCurry(fn);
      };

      expect(fn).to.not.throw();
    });


    it('When original function is bind curried, result is considered bind curried for currying purposes',
        function() {
      var obj = {};
      var f = bindWithContextAndArity(arity, obj, function(x, y) { return options.returns; });
      var manipulated = manipulator(f);
      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        bind(fn);
      };

      expect(fn).to.not.throw();
    });


    it('When original function is curried, result is considered curried for currying purposes', function() {
      var obj = {};
      var f = curryWithArity(arity, function(x) { return options.returns; });
      var manipulated = manipulator(f);
      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        bind(fn);
      };

      expect(fn).to.not.throw();
    });


    it('When original function is not curried, result is considered curried for currying purposes', function() {
      var args = ['a', 'b', 'c', 'd', 'e', 'f'];
      var obj = {};
      var fBody = 'return ' + (options.returns ? options.returns.toString() : 'undefined') + ';';
      var f = Function.apply(Object.create(Function.prototype), args.slice(0, arity).concat([fBody]));
      var manipulated = manipulator(f);
      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        curry(fn);
      };

      expect(fn).to.not.throw();
    });
  };


  /*
   * Helper function for testing function manipulating pairs of other functions. This adds tests that the results are curried
   * in the most consistent "style" as the manipulated functions. We make the following assumptions:
   *
   *  - The caller has exercised the usual case of functions being curried with "curry" or not curried
   *  - The functions being manipulated must have an arity of at least 1
   *  - The caller can supply a function which will take the functions to be manipulated and return the result
   *
   * Optionally takes values to be returned by the functions being manipulated
   *
   */

  var addDoubleCurryStyleTests = function(manipulator, f1Return, f2Return) {
    it('If both functions are object curried, then the result is too', function() {
      var context = null;
      var f1 = objectCurry(function(x) { context = this; return f1Return; });
      var f2 = objectCurry(function(x) {return f2Return; });
      var obj = {};
      obj.manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      obj.manipulated(1);

      expect(context).to.equal(obj);
      var fn = function() {
        if (!arityOf._isCurried(obj.manipulated)) throw new Error('Not curried!');
        // If the result is also objectCurried, then objectCurrying it again won't throw
        objectCurry(obj.manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is object curried, then the result is too (1)', function() {
      var context = null;
      var f1 = objectCurry(function(x) { context = this;  return f1Return; });
      var f2 = function(x) { return f2Return; };
      var obj = {};
      obj.manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      obj.manipulated(1);

      expect(context).to.equal(obj);
      var fn = function() {
        if (!arityOf._isCurried(obj.manipulated)) throw new Error('Not curried!');
        // If the result is also objectCurried, then objectCurrying it again won't throw
        objectCurry(obj.manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is object curried, then the result is too (2)', function() {
      var context = null;
      var f1 = objectCurry(function(x) { context = this;  return f1Return; });
      var f2 = curry(function(x) { return f2Return; });
      var obj = {};
      obj.manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      obj.manipulated(1);

      expect(context).to.equal(obj);
      var fn = function() {
        if (!arityOf._isCurried(obj.manipulated)) throw new Error('Not curried!');
        // If the result is also objectCurried, then objectCurrying it again won't throw
        objectCurry(obj.manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is object curried, then the result is too (3)', function() {
      var context = null;
      var f1 = objectCurry(function(x) { context = this;  return f1Return; });
      var f2 = bind({}, function(x) { return f2Return; });
      var obj = {};
      obj.manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      obj.manipulated(1);

      expect(context).to.equal(obj);
      var fn = function() {
        if (!arityOf._isCurried(obj.manipulated)) throw new Error('Not curried!');
        // If the result is also objectCurried, then objectCurrying it again won't throw
        objectCurry(obj.manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is object curried, then the result is too (4)', function() {
      var context = null;
      var f1 = function(x) { return f1Return; };
      var f2 = objectCurry(function(x) { context = this;  return f2Return; });
      var obj = {};
      obj.manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      obj.manipulated(1);

      expect(context).to.equal(obj);
      var fn = function() {
        if (!arityOf._isCurried(obj.manipulated)) throw new Error('Not curried!');
        // If the result is also objectCurried, then objectCurrying it again won't throw
        objectCurry(obj.manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is object curried, then the result is too (5)', function() {
      var context = null;
      var f1 = curry(function(x) { return f1Return; });
      var f2 = objectCurry(function(x) { context = this;  return f2Return; });
      var obj = {};
      obj.manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      obj.manipulated(1);

      expect(context).to.equal(obj);
      var fn = function() {
        if (!arityOf._isCurried(obj.manipulated)) throw new Error('Not curried!');
        // If the result is also objectCurried, then objectCurrying it again won't throw
        objectCurry(obj.manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is object curried, then the result is too (6)', function() {
      var context = null;
      var f1 = bind({}, function(x) { return f1Return; });
      var f2 = objectCurry(function(x) { context = this;  return f2Return; });
      var obj = {};
      obj.manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      obj.manipulated(1);

      expect(context).to.equal(obj);
      var fn = function() {
        if (!arityOf._isCurried(obj.manipulated)) throw new Error('Not curried!');
        // If the result is also objectCurried, then objectCurrying it again won't throw
        objectCurry(obj.manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If both functions are bound to the same context, then the result is too', function() {
      var context = null;
      var obj = {};
      var f1 = bind(obj, function(x) { return f1Return; });
      var f2 = bind(obj, function(x) { return f2Return; });
      var manipulated = manipulator(f1, f2);
      // Assume that the returned function has arity at least 1
      manipulated(1);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is also bound, then binding it again with the same context won't throw
        bind(obj, manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If both functions are bound to different contexts, then the result is curried in the standard fashion', function() {
      var obj = {};
      var obj2 = {};
      var f1 = bind(obj, function(x) { return f1Return; });
      var f2 = bind(obj2, function(x) { return f2Return; });
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is bound, the other not, then the result is curried in the standard fashion (1)', function() {
      var obj = {};
      var f1 = bind(obj, function(x) { return f1Return; });
      var f2 = function(x) { return f2Return; };
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is bound, the other not, then the result is curried in the standard fashion (2)', function() {
      var obj = {};
      var f1 = bind(obj, function(x) { return f1Return; });
      var f2 = curry(function(x) { return f2Return; });
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is bound, the other not, then the result is curried in the standard fashion (3)', function() {
      var obj = {};
      var f1 = function(x) { return f1Return; };
      var f2 = bind(obj, function(x) { return f2Return; });
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one function is bound, the other not, then the result is curried in the standard fashion (4)', function() {
      var context;
      var obj = {};
      var f1 = curry(function(x) { return f1Return; });
      var f2 = bind(obj, function(x) { return f2Return; });
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If both functions are curried, then the result is too', function() {
      var context;
      var f1 = curry(function(x) { return f1Return; });
      var f2 = curry(function(x) { return f2Return; });
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one functions is curried, the other not, then the result is curried in the standard manner (1)', function() {
      var f1 = curry(function(x) { return f1Return; });
      var f2 = function(x) { return f2Return; };
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If one functions is curried, the other not, then the result is curried in the standard manner (2)', function() {
      var f1 = function(x) { return f1Return; };
      var f2 = curry(function(x) { return f2Return; });
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });


    it('If neither functions is curried then the result is', function() {
      var f1 = function(x) { return f1Return; };
      var f2 = function(x) { return f2Return; };
      var manipulated = manipulator(f1, f2);

      var fn = function() {
        if (!arityOf._isCurried(manipulated)) throw new Error('Not curried!');
        // If the result is curried, then currying again won't throw
        curry(manipulated);
      };

      expect(fn).to.not.throw();
    });
  };


  var makeArrayLike = function() {
    var args = [].slice.call(arguments);

    var result = {};
    if (args.length === 1 && typeof(args[0]) === 'object' && ('length' in args[0])) {
      // We've been passed an arraylike: copy it
      for (var k in args[0])
        result[k] = args[0][k];

      return result;
    }

    args.forEach(function(arg, i) {
      result[i] = arg;
    });

    result.length = args.length;

    // We provide every, indexOf and slice for testing convenience
    result.every = function() {
      return [].every.apply(this, arguments);
    };

    result.slice = function() {
      return makeArrayLike(this);
    };

    result.indexOf = function(val, from) {
      from = from || 0;

      for (var i = from, l = this.length; i < l; i++)
        if (this[i] === val)
          return i;

      return -1;
    };

    return result;
  };


  var toExport = {
    addCurryStyleTests: addCurryStyleTests,
    addDoubleCurryStyleTests: addDoubleCurryStyleTests,
    checkFunction: checkFunction,
    checkModule:   checkModule,
    makeArrayLike: makeArrayLike
  };


  // Ensure our tests don't screw up the sentinel values
  Object.defineProperty(toExport, 'NO_RESTRICTIONS', {configurable: false, enumerable: true,
                                                      writable: false, value: NO_RESTRICTIONS});
  Object.defineProperty(toExport, 'ANYVALUE', {configurable: false, enumerable: true, writable: false, value: ANYVALUE});


  return toExport;
})();

},{"../../lib/components/curry":13,"chai":64}],64:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":65}],65:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.9.1';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":66,"./chai/config":67,"./chai/core/assertions":68,"./chai/interface/assert":69,"./chai/interface/expect":70,"./chai/interface/should":71,"./chai/utils":82,"assertion-error":91}],66:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":67}],67:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],68:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        matcher(obj)
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , matcher(obj)
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],69:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],70:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],71:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],72:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":67,"./flag":75,"./transferFlags":89}],73:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":67,"./flag":75}],74:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],75:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],76:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],77:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],78:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":75,"./getActual":76,"./inspect":83,"./objDisplay":84}],79:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],80:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],81:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],82:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":72,"./addMethod":73,"./addProperty":74,"./flag":75,"./getActual":76,"./getMessage":78,"./getName":79,"./getPathValue":80,"./inspect":83,"./objDisplay":84,"./overwriteChainableMethod":85,"./overwriteMethod":86,"./overwriteProperty":87,"./test":88,"./transferFlags":89,"./type":90,"deep-eql":92}],83:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// https://gist.github.com/1044128/
var getOuterHTML = function(element) {
  if ('outerHTML' in element) return element.outerHTML;
  var ns = "http://www.w3.org/1999/xhtml";
  var container = document.createElementNS(ns, '_');
  var elemProto = (window.HTMLElement || window.Element).prototype;
  var xmlSerializer = new XMLSerializer();
  var html;
  if (document.xmlVersion) {
    return xmlSerializer.serializeToString(element);
  } else {
    container.appendChild(element.cloneNode(false));
    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
    container.innerHTML = '';
    return html;
  }
};

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If it's DOM elem, get outer HTML.
  if (isDOMElement(value)) {
    return getOuterHTML(value);
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":77,"./getName":79,"./getProperties":81}],84:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":67,"./inspect":83}],85:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],86:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],87:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],88:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":75}],89:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],90:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],91:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],92:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":93}],93:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":31,"type-detect":94}],94:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":95}],95:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}]},{},[1]);
